{"ast":null,"code":"import _assertThisInitialized from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\assertThisInitialized.js\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\possibleConstructorReturn.js\";\nimport _isNativeReflectConstruct from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\isNativeReflectConstruct.js\";\nimport _get from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  var scheduler = async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\nvar WindowTimeOperator = /*#__PURE__*/function () {\n  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    _classCallCheck(this, WindowTimeOperator);\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n  _createClass(WindowTimeOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    }\n  }]);\n  return WindowTimeOperator;\n}();\nvar CountedSubject = /*#__PURE__*/function (_Subject) {\n  _inherits(CountedSubject, _Subject);\n  function CountedSubject() {\n    var _this;\n    _classCallCheck(this, CountedSubject);\n    _this = _callSuper(this, CountedSubject, arguments);\n    _this._numberOfNextedValues = 0;\n    return _this;\n  }\n  _createClass(CountedSubject, [{\n    key: \"next\",\n    value: function next(value) {\n      this._numberOfNextedValues++;\n      _get(_getPrototypeOf(CountedSubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"numberOfNextedValues\",\n    get: function get() {\n      return this._numberOfNextedValues;\n    }\n  }]);\n  return CountedSubject;\n}(Subject);\nvar WindowTimeSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(WindowTimeSubscriber, _Subscriber);\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    var _this2;\n    _classCallCheck(this, WindowTimeSubscriber);\n    _this2 = _callSuper(this, WindowTimeSubscriber, [destination]);\n    _this2.destination = destination;\n    _this2.windowTimeSpan = windowTimeSpan;\n    _this2.windowCreationInterval = windowCreationInterval;\n    _this2.maxWindowSize = maxWindowSize;\n    _this2.scheduler = scheduler;\n    _this2.windows = [];\n    var window = _this2.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: _assertThisInitialized(_this2),\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: _assertThisInitialized(_this2),\n        scheduler: scheduler\n      };\n      _this2.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      _this2.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: _assertThisInitialized(_this2),\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n      _this2.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n    return _this2;\n  }\n  _createClass(WindowTimeSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var windows = this.windows;\n      var len = windows.length;\n      for (var i = 0; i < len; i++) {\n        var window = windows[i];\n        if (!window.closed) {\n          window.next(value);\n          if (window.numberOfNextedValues >= this.maxWindowSize) {\n            this.closeWindow(window);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      var windows = this.windows;\n      while (windows.length > 0) {\n        windows.shift().error(err);\n      }\n      this.destination.error(err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var windows = this.windows;\n      while (windows.length > 0) {\n        var window = windows.shift();\n        if (!window.closed) {\n          window.complete();\n        }\n      }\n      this.destination.complete();\n    }\n  }, {\n    key: \"openWindow\",\n    value: function openWindow() {\n      var window = new CountedSubject();\n      this.windows.push(window);\n      var destination = this.destination;\n      destination.next(window);\n      return window;\n    }\n  }, {\n    key: \"closeWindow\",\n    value: function closeWindow(window) {\n      window.complete();\n      var windows = this.windows;\n      windows.splice(windows.indexOf(window), 1);\n    }\n  }]);\n  return WindowTimeSubscriber;\n}(Subscriber);\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n    windowTimeSpan = state.windowTimeSpan,\n    window = state.window;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n    subscriber = state.subscriber,\n    scheduler = state.scheduler,\n    windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n    window = state.window,\n    context = state.context;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map","map":null,"metadata":{},"sourceType":"module"}