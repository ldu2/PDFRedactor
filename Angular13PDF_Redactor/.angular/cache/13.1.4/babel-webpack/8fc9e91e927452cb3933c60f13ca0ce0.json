{"ast":null,"code":"\"use strict\";\n\nvar PDFString = require(\"./object/string\");\nvar precision = 3;\n\n// low level PDF operations\nmodule.exports = {\n  BT: function BT() {\n    return this.write(\"BT\");\n  },\n  ET: function ET() {\n    return this.write(\"ET\");\n  },\n  Tf: function Tf(font, size) {\n    return this.write(font, size, \"Tf\");\n  },\n  // use SC instead\n  // rg(r, g, b) {\n  //   return this.write(r, g, b, 'rg')\n  // },\n  Tm: function Tm(a, b, c, d, e, f) {\n    return this.write(a, b, c, d, e, f, \"Tm\");\n  },\n  Tj: function Tj(str, asHex) {\n    return this.write(str, \"Tj\");\n  },\n  TJ: function TJ(arr) {\n    var _this = this;\n    return this.write(\"[\" + arr.map(function (v) {\n      if (typeof v === \"number\") {\n        return _this.toFixed(v, precision);\n      } else {\n        return v;\n      }\n    }).join(\" \") + \"]\", \"TJ\");\n  },\n  Td: function Td(x, y) {\n    return this.write(x, y, \"Td\");\n  },\n  // set the current color space to use for stroking operations\n  CS: function CS(name) {\n    return this.write(name, \"CS\");\n  },\n  // same as CS but used for nonstroking operations.\n  cs: function cs(name) {\n    return this.write(name, \"cs\");\n  },\n  // set the color to use for stroking operations\n  SC: function SC(c1, c2, c3) {\n    return this.write(c1, c2, c3, \"SC\");\n  },\n  // same as SC but used for nonstroking operations.\n  sc: function sc(c1, c2, c3) {\n    return this.write(c1, c2, c3, \"sc\");\n  },\n  // modify the current transformation matrix\n  // translate: [ 1 0 0 1 x y ]\n  // scale:     [ x 0 0 y 0 0 ]\n  // rotate:    [ cosθ sinθ −sinθ cosθ 0 0 ]\n  cm: function cm(a, b, c, d, e, f) {\n    return this.write(a, b, c, d, e, f, \"cm\");\n  },\n  // save the current graphics state on the graphics state stack\n  q: function q() {\n    return this.write(\"q\");\n  },\n  // restore the graphics state by removing the most recently saved state from the stack\n  Q: function Q() {\n    return this.write(\"Q\");\n  },\n  // append a rectangle to the current path as a complete subpath\n  re: function re(x, y, width, height) {\n    return this.write(x, y, width, height, \"re\");\n  },\n  // fill the path\n  f: function f() {\n    return this.write(\"f\");\n  },\n  // set the text leading (used by T*)\n  TL: function TL(leading) {\n    return this.write(leading, \"TL\");\n  },\n  // T* move to the start of the next line, same as: 0 leading Td\n  Tstar: function Tstar() {\n    return this.write(\"T*\");\n  },\n  // paint xobject\n  Do: function Do(alias) {\n    return this.write(alias, \"Do\");\n  },\n  // line width\n  w: function w(lineWidth) {\n    return this.write(lineWidth, \"w\");\n  },\n  // stroke the path\n  S: function S() {\n    var args = Array.prototype.slice.call(arguments);\n    args.push(\"S\");\n    return this.write.apply(this, args);\n  },\n  write: function write() {\n    var _this2 = this;\n    var line = Array.prototype.map.call(arguments, function (arg) {\n      if (arg === undefined || arg === null) {\n        console.warn(\"received an undefined/null operation argument\");\n      }\n      // TODO: use precision option\n      return typeof arg === \"number\" ? _this2.toFixed(arg, precision) : arg;\n    });\n    return line.join(\" \") + \"\\n\";\n  },\n  toFixed: function toFixed(num, precision) {\n    return (+(Math.floor(+(num + \"e\" + precision)) + \"e\" + -precision)).toFixed(precision);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}