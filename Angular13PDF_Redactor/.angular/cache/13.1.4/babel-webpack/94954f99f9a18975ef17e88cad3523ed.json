{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\nvar _createClass = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\nvar Lexer = require(\"../parser/lexer\");\nvar PDFString = /*#__PURE__*/function () {\n  function PDFString(str) {\n    _classCallCheck(this, PDFString);\n    this.str = str;\n  }\n  _createClass(PDFString, [{\n    key: \"toHexString\",\n    value: function toHexString() {\n      // convert to hex string\n      var hex = \"\";\n      for (var i = 0, len = this.str.length; i < len; ++i) {\n        var h = (this.str.charCodeAt(i) - 31).toString(16);\n        // left pad zeroes\n        h = (\"0000\" + h).slice(-4);\n        hex += h;\n      }\n      return \"<\" + hex + \">\";\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"(\" + this.str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\") + \")\";\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(xref, lexer, trial) {\n      var literal = PDFString.parseLiteral(lexer, trial);\n      var hex = literal === undefined && PDFString.parseHex(lexer, trial);\n      if (!literal && !hex) {\n        if (trial) {\n          return undefined;\n        }\n        throw new Error(\"Invalid string\");\n      }\n      return literal || hex;\n    }\n  }, {\n    key: \"parseLiteral\",\n    value: function parseLiteral(lexer, trial) {\n      if (lexer.getString(1) !== \"(\") {\n        if (trial) {\n          return undefined;\n        }\n        throw new Error(\"Invalid literal string\");\n      }\n      lexer.shift(1);\n      var str = \"\";\n      var done = false;\n      var open = 0;\n      var c;\n      while (!done && (c = lexer._nextCharCode()) >= 0) {\n        switch (c) {\n          case 0x28:\n            // (\n            open++;\n            str += String.fromCharCode(\"(\");\n            break;\n          case 0x29:\n            // )\n            if (open === 0) {\n              done = true;\n            } else {\n              open--;\n              str += String.fromCharCode(\")\");\n            }\n            break;\n          case 0x5c:\n            // \\\n            c = lexer._nextCharCode();\n            switch (c) {\n              case 0x6e:\n                // \\n\n                str += \"\\n\";\n                break;\n              case 0x72:\n                // \\r\n                str += \"\\r\";\n                break;\n              case 0x74:\n                // \\t\n                str += \"\\t\";\n                break;\n              case 0x62:\n                // \\b\n                str += \"\\b\";\n                break;\n              case 0x66:\n                // \\f\n                str += \"\\f\";\n                break;\n              case 0x28: // '('\n              case 0x29: // ')'\n              case 0x5c:\n                // '\\'\n                str += String.fromCharCode(c);\n                break;\n              case 0x30: // 0\n              case 0x31: // 1\n              case 0x32: // 2\n              case 0x33: // 3\n              case 0x34: // 4\n              case 0x35: // 5\n              case 0x36: // 6\n              case 0x37: // 7\n              case 0x38: // 8\n              case 0x39:\n                // 9\n                var oct = String.fromCharCode(c) + lexer.readString(2);\n                str += String.fromCharCode(parseInt(oct, 8));\n                break;\n              default:\n                lexer.shift(-1);\n                break;\n            }\n            break;\n          case 0x0d: // CR\n          case 0x0a:\n            // LF\n            // ignore EOL characters\n            break;\n          default:\n            str += String.fromCharCode(c);\n            break;\n        }\n      }\n      return new PDFString(str);\n    }\n  }, {\n    key: \"parseHex\",\n    value: function parseHex(lexer, trial) {\n      if (lexer.getString(1) !== \"<\") {\n        if (trial) {\n          return undefined;\n        }\n        throw new Error(\"Invalid hex string\");\n      }\n      lexer.shift(1);\n      var str = \"\";\n      var done = false;\n      var digits = [];\n      var addCharacter = function addCharacter(force) {\n        if (digits.length !== 2) {\n          if (digits.length === 1 && force) {\n            digits.push(\"0\");\n          } else {\n            return;\n          }\n        }\n        str += String.fromCharCode(parseInt(digits.join(\"\"), 16));\n        digits.length = 0;\n      };\n      var c;\n      while (!done && (c = lexer._nextCharCode()) >= 0) {\n        switch (true) {\n          case c === 0x3e:\n            // >\n            done = true;\n            break;\n          case c >= 0x30 && c <= 0x39: // 0 - 9\n          case c >= 0x41 && c <= 0x5a: // A - B\n          case c >= 0x61 && c <= 0x7a:\n            // a - b\n            digits.push(String.fromCharCode(c));\n            addCharacter();\n            break;\n          case Lexer.isWhiteSpace(c):\n            break;\n          default:\n            lexer._warning(\"invalid character `\" + String.fromCharCode(c) + \"` in hex string\");\n            break;\n        }\n      }\n      addCharacter(true);\n      return new PDFString(str);\n    }\n  }]);\n  return PDFString;\n}();\nmodule.exports = PDFString;","map":null,"metadata":{},"sourceType":"script"}