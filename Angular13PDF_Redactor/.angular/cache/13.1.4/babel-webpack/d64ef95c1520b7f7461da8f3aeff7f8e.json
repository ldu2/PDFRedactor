{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\defineProperty.js\").default;\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\nvar _createClass = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\possibleConstructorReturn.js\").default;\nvar _isNativeReflectConstruct = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\isNativeReflectConstruct.js\").default;\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\getPrototypeOf.js\").default;\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\assertThisInitialized.js\").default;\nvar _inherits = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\inherits.js\").default;\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nvar Cursor = require(\"./cursor\");\nvar Fragment = require(\"./fragment\");\nvar ops = require(\"./ops\");\nvar PDF = require(\"./object\");\nvar Readable = require(\"readable-stream\");\nvar _require = require(\"uuid\"),\n  uuidv4 = _require.v4;\nvar util = require(\"./util\");\nvar ContentChunk = require(\"./content\");\nvar ExternalDocument = require(\"./external\");\nvar Font = require(\"./font/base\");\nvar version = require(\"../package.json\").version;\n\n// constants\nvar RESOLVE = Promise.resolve();\nvar Document = /*#__PURE__*/function (_Readable) {\n  _inherits(Document, _Readable);\n  function Document(opts) {\n    var _this;\n    _classCallCheck(this, Document);\n    if (!opts) {\n      opts = {};\n    }\n\n    // readable stream options\n    _this = _callSuper(this, Document, [{\n      highWaterMark: opts.highWaterMark || 16384 // 16kB\n    }]);\n    _this.version = \"1.6\";\n    _this.info = Object.assign({}, opts.properties, {\n      id: uuidv4()\n    });\n    _this.width = opts.width || 595.296;\n    _this.height = opts.height || 841.896;\n    _this._nextObjectId = 1;\n    _this._xref = new PDF.Xref();\n    _this._reading = false; // wheater someone is reading data from the underlying Readable\n    _this._length = 0; // keeps track of the total document length (in byte)\n\n    // header\n    var header = \"%PDF-\".concat(_this.version, \"\\n\") +\n    // The PDF format mandates that we add at least 4 commented binary characters\n    // (ASCII value >= 128), so that generic tools have a chance to detect\n    // that it's a binary file\n    \"%\\xFF\\xFF\\xFF\\xFF\\n\\n\";\n\n    // a backlog of pending operations\n    _this._pending = [function () {\n      return _this._write(header);\n    }];\n    // this is the current operation that is executed (operations are executed sequentially)\n    _this._pending.current = null;\n\n    // init default styling opts\n    _this.defaultFont = opts.font || require(\"../font/Helvetica\");\n    _this.defaultFontSize = opts.fontSize || 11;\n    _this.defaultColor = opts.color && util.colorToRgb(opts.color) || [0, 0, 0];\n    _this.defaultLineHeight = opts.lineHeight || 1.15;\n    if (!Font.isFont(_this.defaultFont)) {\n      throw new TypeError(\"opts.font must be set to a valid default font\");\n    }\n\n    // create document and page font dict\n    _this._fonts = {};\n    _this._xobjects = {};\n    _this._pageFonts = {};\n    _this._annotations = [];\n\n    // these properties are used to keep track of used Font and Image objects and assign ids to\n    // them in a document-scoped way\n    _this._aliases = new AliasGenerator();\n    _this._mapping = new WeakMap();\n\n    // a page could consist out of multiple content chunks, which are keept track of using the\n    // following properties\n    _this._currentContent = null;\n    _this._contents = [];\n    _this._contentObjCreator = null;\n\n    // this array can be used to register callbacks that are executed when finalizing the document\n    // e.g. rendering the total page count\n    _this._finalize = [];\n    _this._header = _this._footer = _this._template = null;\n\n    // init cursor\n    // TODO: test for valid values\n    var padding = opts.padding >= 0 ? opts.padding : 20;\n    _this.paddingTop = util.defaults(opts.paddingTop, padding);\n    _this.paddingBottom = util.defaults(opts.paddingBottom, padding);\n    _this.paddingLeft = util.defaults(opts.paddingLeft, padding);\n    _this.paddingRight = util.defaults(opts.paddingRight, padding);\n    _this._cursor = new Cursor(_this.width - _this.paddingLeft - _this.paddingRight, _this.height - _this.paddingTop - _this.paddingBottom,\n    // width, height\n    _this.paddingLeft, _this.height - _this.paddingTop) // x, y\n    ;\n\n    // init pages catalog\n    _this._pages = new PDF.Array();\n    _this._pagesObj = new PDF.Object(\"Pages\");\n    _this._registerObject(_this._pagesObj);\n\n    // init destinations name tree\n    _this._destinations = new PDF.NameTree();\n\n    // init outlines hierarchy\n    _this._outlines = [];\n\n    // init color space\n    _this._colorSpace = new PDF.Object();\n    var iccProfile = require(\"./sRGB_IEC61966-2-1_black_scaled\") + \"~>\";\n    _this._colorSpace.content = \"stream\\n\" + iccProfile + \"\\nendstream\\n\";\n    _this._colorSpace.prop(\"Length\", iccProfile.length);\n    _this._colorSpace.prop(\"N\", 3);\n    _this._colorSpace.prop(\"Alternate\", \"DeviceRGB\");\n    // this._colorSpace.prop('Filter', new PDF.Array([\n    //   new PDF.Name('ASCII85Decode'), new PDF.Name('FlateDecode')\n    // ]))\n    _this._colorSpace.prop(\"Filter\", new PDF.Name(\"ASCII85Decode\"));\n    _this._registerObject(_this._colorSpace);\n    _this._currentColorSpace = \"/CS1\";\n\n    // start to work the _pending queue\n    _this._next();\n    Fragment.prototype._init.call(_assertThisInitialized(_this), _assertThisInitialized(_this), _assertThisInitialized(_this));\n    return _this;\n  }\n\n  /// private API\n  _createClass(Document, [{\n    key: \"_next\",\n    value: function _next() {\n      var _this2 = this;\n      // return if there is already an operation worked on\n      if (this._pending.current) {\n        return this._pending.current;\n      }\n\n      // variables used to traverse the nested queue\n      var parent = this._pending;\n      var next = parent[0];\n\n      // if there is nothing in the queue, we are done here\n      if (!next) {\n        return RESOLVE;\n      }\n\n      // the operation queue is a nested array, e.g.: [op1, [op2, op3, [ op4 ]], op5]\n      // it is therefore necessary traverse the first element until the first non array element\n      // is encountered\n      while (Array.isArray(next)) {\n        // if the first element is an empty array, remove it and start over\n        if (next.length === 0) {\n          parent.shift();\n          return this._next();\n        }\n        parent = next;\n        next = next[0];\n      }\n\n      // remove next from the queue\n      parent.shift();\n\n      // TODO: still necessary?\n      // if (!next) {\n      //   return this._next()\n      // }\n\n      // return and set the current operation that is being executed\n      return this._pending.current = next().then(function () {\n        // once the execution finished, continue in the queue\n        _this2._pending.current = null;\n        return _this2._next();\n      });\n    }\n\n    // This is method is used by Node.js stream.Readable class, which we inherit from.\n    // The method is called, if data is available from the resource, which means that we should\n    // start pushing data into the read queue (using `this.push(dataChunk)`). It should continue\n    // reading from the resoruce and pushing data until `this.push()` return `false`. Only when it\n    // is called again aft it has stopped should it resume pushing additional data onto the\n    // read queue.\n  }, {\n    key: \"_read\",\n    value: function _read( /* size */\n    ) {\n      this._reading = true;\n      this.emit(\"read\");\n    }\n\n    // This method is used to push data onto the read queue. If the Readable stream is currently\n    // not read from, the writing is postponed.\n  }, {\n    key: \"_write\",\n    value: function _write(chunk) {\n      var _this3 = this;\n      if (this._reading) {\n        if (!this.push(chunk, \"binary\")) {\n          this._reading = false;\n        }\n        this._length += chunk.length;\n        return RESOLVE;\n      } else {\n        return new Promise(function (resolve) {\n          _this3.once(\"read\", function () {\n            resolve(_this3._write(chunk));\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_useFont\",\n    value: function _useFont(font) {\n      var alias;\n      if (this._mapping.has(font)) {\n        alias = this._mapping.get(font);\n        // if the alias exists but is now blocked (e.g. because of having set a new template with\n        // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n        if (this._aliases.isBlocked(alias)) {\n          this._mapping.delete(font);\n          alias = undefined;\n        }\n      }\n      if (!alias) {\n        alias = new PDF.Name(this._aliases.next(\"F\"));\n        this._mapping.set(font, alias);\n        var fontObj = new PDF.Object(\"Font\");\n        this._fonts[alias] = {\n          f: font.instance(),\n          o: fontObj\n        };\n        this._registerObject(fontObj);\n      }\n      if (this._currentContent && !(alias in this._currentContent._fonts)) {\n        this._currentContent._fonts[alias] = this._fonts[alias].o.toReference();\n      }\n      return alias;\n    }\n  }, {\n    key: \"_fontAlias\",\n    value: function _fontAlias(instance) {\n      return this._useFont(instance.parent);\n    }\n  }, {\n    key: \"_fontInstance\",\n    value: function _fontInstance(font) {\n      return this._fonts[this._useFont(font)].f;\n    }\n  }, {\n    key: \"_useXObject\",\n    value: function _useXObject(xobj) {\n      var alias;\n      if (this._mapping.has(xobj)) {\n        alias = this._mapping.get(xobj);\n        // if the alias exists but is now blocked (e.g. because of having set a new template with\n        // colliding aliases), remove the mapping and unset the alias to force creation of a new one\n        if (this._aliases.isBlocked(alias)) {\n          this._mapping.delete(xobj);\n          alias = undefined;\n        }\n      }\n      if (!alias) {\n        alias = new PDF.Name(this._aliases.next(\"X\"));\n        this._mapping.set(xobj, alias);\n        var xobjObjs = [];\n        for (var i = 0; i < xobj.xobjCount; ++i) {\n          var xobjObj = new PDF.Object(\"XObject\");\n          this._registerObject(xobjObj);\n          xobjObjs.push(xobjObj);\n        }\n        this._xobjects[alias] = {\n          x: xobj,\n          o: xobjObjs\n        };\n      }\n      if (this._currentContent && !(alias in this._currentContent._xobjects)) {\n        for (var _i = 0; _i < this._xobjects[alias].o.length; ++_i) {\n          this._currentContent._xobjects[alias + \".\" + _i] = this._xobjects[alias].o[_i].toReference();\n        }\n      }\n      var aliases = [];\n      for (var _i2 = 0; _i2 < this._xobjects[alias].o.length; ++_i2) {\n        aliases.push(alias + \".\" + _i2);\n      }\n      return aliases;\n    }\n  }, {\n    key: \"_startPage\",\n    value: function () {\n      var _startPage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var page, taken, alias, i, chunk, _i3, obj, _alias, _chunk, _i4, _obj, _alias2;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._currentPage) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error(\"There is already a started page\");\n            case 2:\n              page = this._currentPage = new PDF.Object(\"Page\");\n              this._pages.push(page.toReference());\n              if (this._template) {\n                taken = {};\n                for (alias in this._template.colorSpaces) {\n                  taken[alias] = null;\n                }\n                i = 1;\n                for (1; (\"/CS\" + i in taken); ++i) {}\n                this._currentColorSpace = \"/CS\" + i;\n              } else {\n                this._currentColorSpace = \"/CS1\";\n              }\n              _context.next = 7;\n              return this._startContentObject();\n            case 7:\n              if (!this._header) {\n                _context.next = 14;\n                break;\n              }\n              chunk = \"\";\n              for (_i3 in this._header._objects) {\n                obj = this._header._objects[_i3];\n                _alias = new PDF.Name(this._aliases.next(\"H\"));\n                this._currentContent._xobjects[_alias] = obj.toReference();\n                chunk += ops.Do(_alias);\n              }\n              _context.next = 12;\n              return this._write(chunk);\n            case 12:\n              _context.next = 14;\n              return this._header._render();\n            case 14:\n              if (!this._footer) {\n                _context.next = 21;\n                break;\n              }\n              _chunk = \"\";\n              for (_i4 in this._footer._objects) {\n                _obj = this._footer._objects[_i4];\n                _alias2 = new PDF.Name(this._aliases.next(\"F\"));\n                this._currentContent._xobjects[_alias2] = _obj.toReference();\n                _chunk += ops.Do(_alias2);\n              }\n              _context.next = 19;\n              return this._write(_chunk);\n            case 19:\n              _context.next = 21;\n              return this._footer._render();\n            case 21:\n              this._cursor.reset();\n              if (this._header) {\n                this._cursor.y -= this._header.height;\n              }\n              if (this._footer) {\n                this._cursor.bottomOffset = this._footer.height;\n              }\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function _startPage() {\n        return _startPage2.apply(this, arguments);\n      }\n      return _startPage;\n    }()\n  }, {\n    key: \"_endPage\",\n    value: function () {\n      var _endPage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var fonts, xobjects, _iterator, _step, content, _alias7, _alias8, page, colorSpace, resources, contents, alias, _alias3, _alias4, extGStates, _alias5, shadings, _alias6;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this._currentPage) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              _context2.next = 4;\n              return this._endContentObject();\n            case 4:\n              fonts = new PDF.Dictionary({});\n              xobjects = new PDF.Dictionary({});\n              _iterator = _createForOfIteratorHelper(this._contents);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  content = _step.value;\n                  for (_alias7 in content._fonts) {\n                    fonts.add(_alias7, content._fonts[_alias7]);\n                  }\n                  for (_alias8 in content._xobjects) {\n                    xobjects.add(_alias8, content._xobjects[_alias8]);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              page = this._currentPage;\n              page.prop(\"Parent\", this._pagesObj.toReference());\n              colorSpace = new PDF.Dictionary(_defineProperty({}, this._currentColorSpace, new PDF.Array([new PDF.Name(\"ICCBased\"), this._colorSpace.toReference()])));\n              resources = new PDF.Dictionary({\n                ColorSpace: colorSpace,\n                ProcSet: new PDF.Array([new PDF.Name(\"PDF\"), new PDF.Name(\"Text\"), new PDF.Name(\"ImageB\"), new PDF.Name(\"ImageC\"), new PDF.Name(\"ImageI\")]),\n                Font: fonts,\n                XObject: xobjects\n              });\n              page.prop(\"Resources\", resources);\n              if (this._annotations.length > 0) {\n                page.prop(\"Annots\", new PDF.Array(this._annotations));\n                this._annotations = [];\n              }\n              contents = this._contents.map(function (c) {\n                return c._object.toReference();\n              });\n              page.prop(\"Contents\", new PDF.Array(contents));\n              if (this._template) {\n                contents.unshift.apply(contents, this._template.contents);\n                for (alias in this._template.colorSpaces) {\n                  colorSpace.dictionary[alias] = this._template.colorSpaces[alias];\n                }\n                for (_alias3 in this._template.fonts) {\n                  fonts.dictionary[_alias3] = this._template.fonts[_alias3];\n                }\n                for (_alias4 in this._template.xobjects) {\n                  xobjects.dictionary[_alias4] = this._template.xobjects[_alias4];\n                }\n                extGStates = new PDF.Dictionary({});\n                for (_alias5 in this._template.extGStates) {\n                  extGStates.dictionary[_alias5] = this._template.extGStates[_alias5];\n                }\n                if (extGStates.length > 0) {\n                  resources.set(\"ExtGState\", extGStates);\n                }\n                shadings = new PDF.Dictionary({});\n                for (_alias6 in this._template.shadings) {\n                  shadings.dictionary[_alias6] = this._template.shadings[_alias6];\n                }\n                if (shadings.length > 0) {\n                  resources.set(\"Shading\", shadings);\n                }\n              }\n              _context2.next = 19;\n              return this._writeObject(page);\n            case 19:\n              this._currentContent = this._currentPage = null;\n              this._contents.length = 0;\n              if (this._template && this._template.firstPageOnly) {\n                this._template = null;\n              }\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _endPage() {\n        return _endPage2.apply(this, arguments);\n      }\n      return _endPage;\n    }()\n  }, {\n    key: \"_pageBreak\",\n    value: function () {\n      var _pageBreak2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this._currentPage) {\n                _context3.next = 3;\n                break;\n              }\n              _context3.next = 3;\n              return this._startPage();\n            case 3:\n              _context3.next = 5;\n              return this._cursor.reset();\n            case 5:\n              _context3.next = 7;\n              return this._endPage();\n            case 7:\n              _context3.next = 9;\n              return this._startPage();\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _pageBreak() {\n        return _pageBreak2.apply(this, arguments);\n      }\n      return _pageBreak;\n    }(\n      /* level */\n    )\n  }, {\n    key: \"_startContentObject\",\n    value: function () {\n      var _startContentObject2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(obj, force) {\n        var content, chunk;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(!force && this._length - 16 == this._contentStart)) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt(\"return\", this._currentContent);\n            case 2:\n              if (!this._currentContent) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 5;\n              return this._endContentObject();\n            case 5:\n              if (this._contentObjCreator) {\n                obj = this._contentObjCreator();\n              }\n              content = this._currentContent = new ContentChunk(this, obj);\n              this._contents.push(content);\n              this._xref.add(content._object.id, {\n                offset: this._length,\n                obj: content._object\n              });\n              chunk = content._object.id + \" \" + content._object.rev + \" obj\\n\" + content._object.properties.toString() + \"\\n\" + \"stream\\n\";\n              this._contentStart = this._length + chunk.length;\n\n              // set color space\n              chunk += ops.CS(this._currentColorSpace) + ops.cs(this._currentColorSpace);\n              _context4.next = 14;\n              return this._write(chunk);\n            case 14:\n              return _context4.abrupt(\"return\", content);\n            case 15:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _startContentObject(_x, _x2) {\n        return _startContentObject2.apply(this, arguments);\n      }\n      return _startContentObject;\n    }()\n  }, {\n    key: \"_endContentObject\",\n    value: function () {\n      var _endContentObject2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var chunk;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this._currentContent) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 2:\n              this._currentContent._length.content = this._length - this._contentStart - 1;\n              if (this._currentContent._length.content < 0) {\n                this._currentContent._length.content = 0;\n              }\n              chunk = \"endstream\\nendobj\\n\\n\";\n              _context5.next = 7;\n              return this._write(chunk);\n            case 7:\n              _context5.next = 9;\n              return this._writeObject(this._currentContent._length);\n            case 9:\n              this._currentContent = null;\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _endContentObject() {\n        return _endContentObject2.apply(this, arguments);\n      }\n      return _endContentObject;\n    }()\n  }, {\n    key: \"_registerObject\",\n    value: function _registerObject(object, force) {\n      if (object instanceof PDF.Stream) {\n        object = object.object;\n      }\n      if (!force && object.id) {\n        return;\n      }\n      object.id = this._nextObjectId;\n      this._nextObjectId++;\n    }\n  }, {\n    key: \"_writeObject\",\n    value: function _writeObject(object) {\n      if (object instanceof PDF.Stream) {\n        object = object.object;\n      }\n      if (!object.id) {\n        this._registerObject(object);\n      }\n      this._xref.add(object.id, {\n        offset: this._length,\n        obj: object\n      });\n      return this._write(object.toString() + \"\\n\\n\");\n    }\n  }, {\n    key: \"_updateOutlinesCount\",\n    value: function _updateOutlinesCount(id) {\n      if (this._outlines[id].data.count < 1) {\n        this._outlines[id].data.count -= 1;\n        this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n      } else {\n        this._outlines[id].data.count = -1;\n        this._outlines[id].prop(\"Count\", this._outlines[id].data.count);\n      }\n      var nextParent = this._outlines[id].data.parentIndex;\n      if (nextParent !== undefined) {\n        this._updateOutlinesCount(nextParent);\n      }\n    }\n\n    // public API\n  }, {\n    key: \"end\",\n    value: function () {\n      var _end = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _iterator2, _step2, fn, alias, font, _alias9, xobj, catalog, destsObj, i, infoObj, key, startxref, objectsCount, trailer;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return Fragment.prototype.end.call(this);\n            case 2:\n              _context6.next = 4;\n              return this._next();\n            case 4:\n              _context6.next = 6;\n              return this._endPage();\n            case 6:\n              _iterator2 = _createForOfIteratorHelper(this._finalize);\n              _context6.prev = 7;\n              _iterator2.s();\n            case 9:\n              if ((_step2 = _iterator2.n()).done) {\n                _context6.next = 15;\n                break;\n              }\n              fn = _step2.value;\n              _context6.next = 13;\n              return fn();\n            case 13:\n              _context6.next = 9;\n              break;\n            case 15:\n              _context6.next = 20;\n              break;\n            case 17:\n              _context6.prev = 17;\n              _context6.t0 = _context6[\"catch\"](7);\n              _iterator2.e(_context6.t0);\n            case 20:\n              _context6.prev = 20;\n              _iterator2.f();\n              return _context6.finish(20);\n            case 23:\n              this._pagesObj.prop(\"MediaBox\", new PDF.Array([0, 0, this.width, this.height]));\n              this._pagesObj.prop(\"Kids\", this._pages);\n              this._pagesObj.prop(\"Count\", this._pages.length);\n              _context6.next = 28;\n              return this._writeObject(this._pagesObj);\n            case 28:\n              _context6.next = 30;\n              return this._writeObject(this._colorSpace);\n            case 30:\n              _context6.t1 = _regeneratorRuntime().keys(this._fonts);\n            case 31:\n              if ((_context6.t2 = _context6.t1()).done) {\n                _context6.next = 38;\n                break;\n              }\n              alias = _context6.t2.value;\n              font = this._fonts[alias];\n              _context6.next = 36;\n              return font.f.write(this, font.o);\n            case 36:\n              _context6.next = 31;\n              break;\n            case 38:\n              _context6.t3 = _regeneratorRuntime().keys(this._xobjects);\n            case 39:\n              if ((_context6.t4 = _context6.t3()).done) {\n                _context6.next = 46;\n                break;\n              }\n              _alias9 = _context6.t4.value;\n              xobj = this._xobjects[_alias9];\n              _context6.next = 44;\n              return xobj.x.write(this, xobj.o);\n            case 44:\n              _context6.next = 39;\n              break;\n            case 46:\n              catalog = new PDF.Object(\"Catalog\");\n              catalog.prop(\"Pages\", this._pagesObj.toReference());\n              if (!(this._destinations.length > 0)) {\n                _context6.next = 54;\n                break;\n              }\n              destsObj = new PDF.Object();\n              destsObj.prop(\"Dests\", this._destinations);\n              _context6.next = 53;\n              return this._writeObject(destsObj);\n            case 53:\n              catalog.prop(\"Names\", destsObj.toReference());\n            case 54:\n              if (!(this._outlines.length > 0)) {\n                _context6.next = 63;\n                break;\n              }\n              i = 0;\n            case 56:\n              if (!(i < this._outlines.length)) {\n                _context6.next = 62;\n                break;\n              }\n              _context6.next = 59;\n              return this._writeObject(this._outlines[i]);\n            case 59:\n              i += 1;\n              _context6.next = 56;\n              break;\n            case 62:\n              catalog.prop(\"Outlines\", this._outlines[0].toReference());\n            case 63:\n              _context6.next = 65;\n              return this._writeObject(catalog);\n            case 65:\n              // document info\n              this.info.creationDate = formatDate(\n              // Default to now and convert to string\n              this.info.creationDate || new Date());\n              if (!this.info.producer) {\n                // Set default producer if not one provided\n                this.info.producer = \"pdfjs v\".concat(version, \" (github.com/rkusa/pdfjs)\");\n              }\n              if (\"modDate\" in this.info) {\n                this.info.modDate = formatDate(this.info.modDate);\n              }\n              infoObj = new PDF.Object();\n              for (key in InfoKeys) {\n                if (key in this.info) {\n                  infoObj.prop(InfoKeys[key], new PDF.String(this.info[key]));\n                }\n              }\n              this._writeObject(infoObj);\n\n              // to support random access to individual objects, a PDF file\n              // contains a cross-reference table that can be used to locate\n              // and directly access pages and other important objects within the file\n              startxref = this._length;\n              _context6.next = 74;\n              return this._write(this._xref.toString());\n            case 74:\n              // trailer\n              objectsCount = this._nextObjectId - 1;\n              trailer = new PDF.Trailer(objectsCount + 1, catalog, this.info.id, infoObj);\n              _context6.next = 78;\n              return this._write(trailer.toString() + \"\\n\");\n            case 78:\n              _context6.next = 80;\n              return this._write(\"startxref\\n\" + startxref + \"\\n%%EOF\");\n            case 80:\n              // close readable stream\n              this.push(null);\n            case 81:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[7, 17, 20, 23]]);\n      }));\n      function end() {\n        return _end.apply(this, arguments);\n      }\n      return end;\n    }()\n  }, {\n    key: \"asBuffer\",\n    value: function asBuffer(opts, callback) {\n      var _this4 = this;\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = undefined;\n      }\n      var shouldEnd = !opts || opts.end !== false;\n      var p = new Promise(function (resolve, reject) {\n        var chunks = [];\n        _this4.on(\"data\", function (chunk) {\n          return chunks.push(chunk);\n        });\n        _this4.on(\"end\", function () {\n          return resolve(Buffer.concat(chunks));\n        });\n        _this4.on(\"error\", reject);\n        if (shouldEnd) {\n          _this4.end().catch(reject);\n        }\n      });\n      if (typeof callback === \"function\") {\n        p = p.then(function (data) {\n          return callback(null, data);\n        }).catch(callback);\n      }\n      return p;\n    }\n  }, {\n    key: \"header\",\n    value: function header() {\n      var _this5 = this;\n      var Header = require(\"./header\");\n      var ctx = new Header(this, this);\n      this._begin(ctx);\n      this._pending.push(function () {\n        _this5._header = ctx;\n        return ctx._start();\n      });\n      return ctx;\n    }\n  }, {\n    key: \"footer\",\n    value: function footer() {\n      var _this6 = this;\n      var Footer = require(\"./footer\");\n      var ctx = new Footer(this, this);\n      this._begin(ctx);\n      this._pending.push(function () {\n        _this6._footer = ctx;\n        return ctx._start();\n      });\n      return ctx;\n    }\n  }, {\n    key: \"addPagesOf\",\n    value: function addPagesOf(external) {\n      var _this7 = this;\n      if (!(external instanceof ExternalDocument)) {\n        throw new TypeError(\"argument must be of type ExternalDocument\");\n      }\n      this._begin(null);\n      this._pending.push(function () {\n        return external.write(_this7);\n      });\n    }\n  }, {\n    key: \"addPageOf\",\n    value: function addPageOf(page, external) {\n      var _this8 = this;\n      if (!(external instanceof ExternalDocument)) {\n        throw new TypeError(\"argument must be of type ExternalDocument\");\n      }\n      if (!page || page < 1 || page > external.pageCount) {\n        throw new TypeError(\"ExternalDocument does not have page \" + page);\n      }\n      this._begin(null);\n      this._pending.push(function () {\n        return external.write(_this8, page);\n      });\n    }\n  }, {\n    key: \"setTemplate\",\n    value: function setTemplate(external) {\n      var _this9 = this;\n      var firstPageOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!(external instanceof ExternalDocument)) {\n        throw new TypeError(\"argument must be of type ExternalDocument\");\n      }\n      this._begin(null);\n      this._pending.push(function () {\n        return external.setAsTemplate(_this9, firstPageOnly);\n      });\n    }\n  }, {\n    key: \"outline\",\n    value: function outline(title, destination, parent) {\n      // Skip empty titles and/or destination\n      if (title === undefined || destination === undefined) return;\n\n      // Create the root outline the first time this method is called\n      if (this._outlines.length === 0) {\n        this._outlines[0] = new PDF.Object(\"Outlines\");\n        this._outlines[0].data = {\n          type: \"Outlines\"\n        };\n        this._registerObject(this._outlines[0]);\n      }\n      // Find parent item\n      var parentIndex;\n      if (typeof parent === \"number\" && parent >= 0 && parent <= this._outlines.length) {\n        // the user provided a valid index number: use it as the parentIndex\n        parentIndex = parent;\n      } else {\n        // the user did not provide a valid index number: search for it in the outline array\n        // if it is not found, create the corresponding parent at root level\n        if (parent === undefined || parent === \"\") {\n          parentIndex = 0;\n        } else {\n          parentIndex = this._outlines.findIndex(function (item, index) {\n            return item.data.title === parent;\n          });\n          if (parentIndex === -1) parentIndex = this.outline(parent, destination);\n        }\n      }\n\n      // Find siblings\n      var siblingsIndexes = this._outlines.reduce(function (result, item, index) {\n        if (index !== 0 && item.data.parentIndex === parentIndex) result.push(index);\n        return result;\n      }, []);\n\n      // Create item\n      var outline = new PDF.Object();\n      outline.data = {\n        title: title,\n        destination: destination,\n        parent: parent\n      };\n      outline.prop(\"Title\", new PDF.String(title));\n      outline.prop(\"Parent\", this._outlines[parentIndex].toReference());\n      outline.prop(\"A\", new PDF.Dictionary({\n        S: \"GoTo\",\n        D: new PDF.String(destination)\n      }));\n      this._registerObject(outline);\n      var outlineIndex = this._outlines.push(outline) - 1;\n\n      // Chain to siblings\n      var prevSiblingIndex = siblingsIndexes[siblingsIndexes.length - 1];\n      if (prevSiblingIndex > 0) {\n        // Next\n        this._outlines[prevSiblingIndex].data.nextId = outlineIndex;\n        this._outlines[prevSiblingIndex].prop(\"Next\", this._outlines[outlineIndex].toReference());\n        // Prev\n        this._outlines[outlineIndex].data.prevId = prevSiblingIndex;\n        this._outlines[outlineIndex].prop(\"Prev\", this._outlines[prevSiblingIndex].toReference());\n      }\n\n      // Chain to parents\n      this._outlines[outlineIndex].data.parentIndex = parentIndex;\n      if (siblingsIndexes.length === 0) {\n        // First\n        this._outlines[parentIndex].data.firstIndex = outlineIndex;\n        this._outlines[parentIndex].prop(\"First\", this._outlines[outlineIndex].toReference());\n      }\n      // Last\n      this._outlines[parentIndex].data.lastIndex = outlineIndex;\n      this._outlines[parentIndex].prop(\"Last\", this._outlines[outlineIndex].toReference());\n      // Count(s)\n      this._updateOutlinesCount(parentIndex);\n      return outlineIndex;\n    }\n  }]);\n  return Document;\n}(Readable);\nObject.assign(Document.prototype, {\n  _begin: Fragment.prototype._begin,\n  _end: Fragment.prototype._end,\n  _opts: Fragment.prototype._opts,\n  text: Fragment.prototype.text,\n  cell: Fragment.prototype.cell,\n  table: Fragment.prototype.table,\n  image: Fragment.prototype.image,\n  pageBreak: Fragment.prototype.pageBreak,\n  op: Fragment.prototype.op,\n  destination: Fragment.prototype.destination\n});\nvar AliasGenerator = /*#__PURE__*/function () {\n  function AliasGenerator() {\n    _classCallCheck(this, AliasGenerator);\n    this.nextId = {};\n    this.blocked = new Set();\n  }\n  _createClass(AliasGenerator, [{\n    key: \"next\",\n    value: function next(prefix) {\n      if (!(prefix in this.nextId)) {\n        this.nextId[prefix] = 1;\n      }\n      var next;\n      do {\n        next = prefix + this.nextId[prefix]++;\n      } while (this.blocked.has(next));\n      return next;\n    }\n  }, {\n    key: \"block\",\n    value: function block(alias) {\n      alias = String(alias);\n      if (alias[0] === \"/\") {\n        alias = alias.slice(1);\n      }\n      this.blocked.add(alias);\n    }\n  }, {\n    key: \"isBlocked\",\n    value: function isBlocked(alias) {\n      alias = String(alias);\n      if (alias[0] === \"/\") {\n        alias = alias.slice(1);\n      }\n      return this.blocked.has(alias);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(prefix) {\n      this.nextId[prefix] = 1;\n    }\n  }]);\n  return AliasGenerator;\n}();\nvar InfoKeys = {\n  title: \"Title\",\n  author: \"Author\",\n  subject: \"Subject\",\n  keywords: \"Keywords\",\n  creator: \"Creator\",\n  producer: \"Producer\",\n  creationDate: \"CreationDate\",\n  modDate: \"ModDate\"\n};\nfunction formatDate(date) {\n  var str = \"D:\" + date.getFullYear() + (\"00\" + (date.getMonth() + 1)).slice(-2) + (\"00\" + date.getDate()).slice(-2) + (\"00\" + date.getHours()).slice(-2) + (\"00\" + date.getMinutes()).slice(-2) + (\"00\" + date.getSeconds()).slice(-2);\n  var offset = date.getTimezoneOffset();\n  var rel = offset === 0 ? \"Z\" : offset > 0 ? \"-\" : \"+\";\n  offset = Math.abs(offset);\n  var hoursOffset = Math.floor(offset / 60);\n  var minutesOffset = offset - hoursOffset * 60;\n  str += rel + (\"00\" + hoursOffset).slice(-2) + \"'\" + (\"00\" + minutesOffset).slice(-2) + \"'\";\n  return str;\n}\nmodule.exports = Document;","map":null,"metadata":{},"sourceType":"script"}