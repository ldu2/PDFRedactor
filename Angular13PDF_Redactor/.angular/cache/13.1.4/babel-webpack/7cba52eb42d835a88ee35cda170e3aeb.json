{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\nvar _createClass = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\nvar Lexer = require(\"./lexer\");\nvar PDF = require(\"../object\");\nvar util = require(\"../util\");\nvar Parser = /*#__PURE__*/function () {\n  // ab ... ArrayBuffer\n  function Parser(ab) {\n    _classCallCheck(this, Parser);\n    this.src = new Uint8Array(util.toArrayBuffer(ab));\n  }\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse() {\n      var index = lastIndexOf(this.src, \"startxref\", 128);\n      if (index === -1) {\n        throw new Error(\"Invalid PDF: startxref not found\");\n      }\n      index += \"startxref\".length;\n\n      // skip whitespaces\n      while (Lexer.isWhiteSpace(this.src[++index])) {}\n      var str = \"\";\n      while (this.src[index] >= 0x30 && this.src[index] <= 0x39) {\n        // between 0 and 9\n        str += String.fromCharCode(this.src[index++]);\n      }\n      var startXRef = parseInt(str, 10);\n      if (isNaN(startXRef)) {\n        throw new Error(\"Invalid PDF: startxref is not a number\");\n      }\n      var lexer = new Lexer(this.src);\n      lexer.shift(startXRef);\n      this.xref = PDF.Xref.parse(null, lexer);\n      this.trailer = this.xref.trailer || PDF.Trailer.parse(this.xref, lexer);\n      var trailer = this.trailer;\n      while (trailer.has(\"Prev\")) {\n        var prevTrailerPos = trailer.get(\"Prev\");\n        // Ignore prev pointers to the document beginning. This is not according to the PDF spec, but\n        // there are PDFs out there doing it anyway.\n        if (prevTrailerPos === 0) {\n          break;\n        }\n        lexer.pos = trailer.get(\"Prev\");\n        var xref = PDF.Xref.parse(null, lexer);\n        for (var i = 0; i < xref.objects.length; ++i) {\n          var obj = xref.objects[i];\n          if (obj && !this.xref.objects[i]) {\n            this.xref.objects[i] = obj;\n          }\n        }\n        trailer = xref.trailer || PDF.Trailer.parse(xref, lexer);\n      }\n    }\n  }], [{\n    key: \"addObjectsRecursive\",\n    value: function addObjectsRecursive(objects, value) {\n      switch (true) {\n        case value instanceof PDF.Reference:\n          if (objects.indexOf(value.object) > -1) {\n            break;\n          }\n\n          // skip references to other pages\n          var type = value.object.properties.get(\"Type\");\n          if (type && type.toString() === \"/Page\") {\n            break;\n          }\n          objects.push(value.object);\n          Parser.addObjectsRecursive(objects, value.object);\n          break;\n        case value instanceof PDF.Object:\n          Parser.addObjectsRecursive(objects, value.properties);\n          Parser.addObjectsRecursive(objects, value.content);\n          break;\n        case value instanceof PDF.Dictionary:\n          for (var key in value.dictionary) {\n            if (key === \"/Parent\") {\n              // ignore parent property to prevent moving above Page objects\n              continue;\n            }\n            Parser.addObjectsRecursive(objects, value.dictionary[key]);\n          }\n          break;\n        case Array.isArray(value):\n          value.forEach(function (item) {\n            Parser.addObjectsRecursive(objects, item);\n          });\n          break;\n      }\n    }\n  }]);\n  return Parser;\n}();\nmodule.exports = Parser;\nfunction lastIndexOf(src, key, step) {\n  if (!step) step = 1024;\n  var pos = src.length,\n    index = -1;\n  while (index === -1 && pos > 0) {\n    pos -= step - key.length;\n    index = find(src, key, Math.max(pos, 0), step, true);\n  }\n  return index;\n}\nfunction find(src, key, pos, limit, backwards) {\n  if (pos + limit > src.length) {\n    limit = src.length - pos;\n  }\n  var str = String.fromCharCode.apply(null, src.subarray(pos, pos + limit));\n  var index = backwards ? str.lastIndexOf(key) : str.indexOf(key);\n  if (index > -1) {\n    index += pos;\n  }\n  return index;\n}","map":null,"metadata":{},"sourceType":"script"}