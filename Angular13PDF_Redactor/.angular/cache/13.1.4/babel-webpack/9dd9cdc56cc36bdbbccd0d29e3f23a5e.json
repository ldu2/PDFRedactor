{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\classCallCheck.js\").default;\nvar _createClass = require(\"C:\\\\Users\\\\Lubuntu\\\\Desktop\\\\mGit\\\\PDFRedactor\\\\Angular7PDF_Redactor\\\\node_modules\\\\@angular-devkit\\\\build-angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createClass.js\").default;\nvar PDFObject = require(\"./object\");\nvar util = require(\"../util\");\nmodule.exports = /*#__PURE__*/function () {\n  function PDFXref() {\n    _classCallCheck(this, PDFXref);\n    this.objects = [];\n    this.trailer = null;\n  }\n  _createClass(PDFXref, [{\n    key: \"add\",\n    value: function add(id, data) {\n      this.objects[id] = data;\n    }\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this.objects[id] && this.objects[id].obj;\n    }\n  }, {\n    key: \"getOffset\",\n    value: function getOffset(id) {\n      return this.objects[id] && this.objects[id].offset || null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var xref = \"xref\\n\";\n      var range = {\n        from: 0,\n        refs: [0]\n      };\n      var ranges = [range];\n      for (var i = 1; i < this.objects.length; ++i) {\n        var obj = this.objects[i];\n        if (!obj) {\n          if (range) {\n            range = null;\n          }\n          continue;\n        }\n        if (!range) {\n          range = {\n            from: i,\n            refs: []\n          };\n          ranges.push(range);\n        }\n        range.refs.push(obj.offset);\n      }\n      ranges.forEach(function (range) {\n        xref += range.from + \" \" + range.refs.length + \"\\n\";\n        range.refs.forEach(function (ref, i) {\n          if (range.from === 0 && i === 0) {\n            xref += \"0000000000 65535 f \\n\";\n          } else {\n            xref += \"0000000000\".substr(ref.toString().length) + ref + \" 00000 n \\n\";\n          }\n        });\n      });\n      return xref;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(_, lexer, trial) {\n      var xref = new PDFXref();\n      if (lexer.getString(4) !== \"xref\") {\n        return this.parseXrefObject(_, lexer, trial);\n      }\n      lexer.readString(4); // skip xref\n      lexer.skipSpace(null, trial);\n      lexer.skipEOL(1, trial);\n      var start;\n      while ((start = lexer.readNumber(true)) !== undefined) {\n        lexer.skipSpace(1);\n        var count = lexer.readNumber();\n        lexer.skipSpace(null, true);\n        lexer.skipEOL(1);\n        for (var i = 0, len = 0 + count; i < len; ++i) {\n          var offset = lexer.readNumber();\n          lexer.skipSpace(1);\n          lexer.readNumber(); // generation\n          lexer.skipSpace(1);\n          var key = lexer.readString(1);\n          lexer.skipSpace(null, true);\n          lexer.skipEOL(1);\n          var id = start + i;\n          if (id > 0 && key === \"n\") {\n            xref.add(id, {\n              offset: offset\n            });\n          }\n        }\n      }\n      return xref;\n    }\n\n    // TODO: this implementation needs to be improved\n  }, {\n    key: \"parseXrefObject\",\n    value: function parseXrefObject(_, lexer, trial) {\n      var xref = new PDFXref();\n      var obj;\n      try {\n        obj = PDFObject.parse(xref, lexer, trial);\n      } catch (_) {\n        throw new Error(\"Invalid xref: xref expected but not found\");\n      }\n      var kind = obj.properties.get(\"Type\");\n      if (!kind || kind.name !== \"XRef\") {\n        throw new Error(\"Invalid xref object at \" + lexer.pos);\n      }\n      var stream = util.inflate(obj);\n      xref.trailer = obj.properties;\n      var index = obj.properties.get(\"Index\");\n      var start = index ? index[0] : 0;\n      var w = obj.properties.get(\"W\");\n      var typeSize = w[0] || 1;\n      var offsetSize = w[1] || 2;\n      var genSize = w[2] || 1;\n      var len = stream.length / (typeSize + offsetSize + genSize);\n      var pos = 0;\n      for (var i = 0; i < len; ++i) {\n        var type = readUint(stream, pos, typeSize);\n        pos += typeSize;\n        var offset = readUint(stream, pos, offsetSize);\n        pos += offsetSize;\n        switch (type) {\n          case 0:\n            // free\n            pos += genSize;\n            continue;\n          // skip type 0 entries (free entries)\n          case 1:\n            // normal\n            xref.add(start + i, {\n              offset: offset\n            });\n            pos += genSize;\n            break;\n          case 2:\n            // compressed\n            xref.add(start + i, {\n              compressed: true,\n              id: offset,\n              ix: readUint(stream, pos, genSize)\n            });\n            pos += genSize;\n            break;\n          default:\n            continue;\n        }\n      }\n      return xref;\n    }\n  }]);\n  return PDFXref;\n}();\nfunction readUint(src, pos, size) {\n  var val = 0;\n  for (var i = 0; i < size; ++i) {\n    // for (let i = size - 1; i > 0; --i) {\n    val += src[pos + size - i - 1] << 8 * i;\n  }\n  return val;\n}","map":null,"metadata":{},"sourceType":"script"}