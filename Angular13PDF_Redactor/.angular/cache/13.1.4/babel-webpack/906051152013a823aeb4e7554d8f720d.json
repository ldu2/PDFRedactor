{"ast":null,"code":"/* Copyright 2012 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/* jshint globalstrict: false */\n/* umdutils ignore */\n\n(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define('pdfjs-dist/build/pdf', ['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.pdfjsDistBuildPdf = {});\n  }\n})(this, function (exports) {\n  // Use strict in our context only - users might not want it\n  'use strict';\n\n  var pdfjsVersion = '1.5.188';\n  var pdfjsBuild = '0e2d50f';\n  var pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;\n  var pdfjsLibs = {};\n  (function pdfjsWrapper() {\n    (function (root, factory) {\n      {\n        factory(root.pdfjsSharedUtil = {});\n      }\n    })(this, function (exports) {\n      var globalScope = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this;\n      var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n      var TextRenderingMode = {\n        FILL: 0,\n        STROKE: 1,\n        FILL_STROKE: 2,\n        INVISIBLE: 3,\n        FILL_ADD_TO_PATH: 4,\n        STROKE_ADD_TO_PATH: 5,\n        FILL_STROKE_ADD_TO_PATH: 6,\n        ADD_TO_PATH: 7,\n        FILL_STROKE_MASK: 3,\n        ADD_TO_PATH_FLAG: 4\n      };\n      var ImageKind = {\n        GRAYSCALE_1BPP: 1,\n        RGB_24BPP: 2,\n        RGBA_32BPP: 3\n      };\n      var AnnotationType = {\n        TEXT: 1,\n        LINK: 2,\n        FREETEXT: 3,\n        LINE: 4,\n        SQUARE: 5,\n        CIRCLE: 6,\n        POLYGON: 7,\n        POLYLINE: 8,\n        HIGHLIGHT: 9,\n        UNDERLINE: 10,\n        SQUIGGLY: 11,\n        STRIKEOUT: 12,\n        STAMP: 13,\n        CARET: 14,\n        INK: 15,\n        POPUP: 16,\n        FILEATTACHMENT: 17,\n        SOUND: 18,\n        MOVIE: 19,\n        WIDGET: 20,\n        SCREEN: 21,\n        PRINTERMARK: 22,\n        TRAPNET: 23,\n        WATERMARK: 24,\n        THREED: 25,\n        REDACT: 26\n      };\n      var AnnotationFlag = {\n        INVISIBLE: 0x01,\n        HIDDEN: 0x02,\n        PRINT: 0x04,\n        NOZOOM: 0x08,\n        NOROTATE: 0x10,\n        NOVIEW: 0x20,\n        READONLY: 0x40,\n        LOCKED: 0x80,\n        TOGGLENOVIEW: 0x100,\n        LOCKEDCONTENTS: 0x200\n      };\n      var AnnotationBorderStyleType = {\n        SOLID: 1,\n        DASHED: 2,\n        BEVELED: 3,\n        INSET: 4,\n        UNDERLINE: 5\n      };\n      var StreamType = {\n        UNKNOWN: 0,\n        FLATE: 1,\n        LZW: 2,\n        DCT: 3,\n        JPX: 4,\n        JBIG: 5,\n        A85: 6,\n        AHX: 7,\n        CCF: 8,\n        RL: 9\n      };\n      var FontType = {\n        UNKNOWN: 0,\n        TYPE1: 1,\n        TYPE1C: 2,\n        CIDFONTTYPE0: 3,\n        CIDFONTTYPE0C: 4,\n        TRUETYPE: 5,\n        CIDFONTTYPE2: 6,\n        TYPE3: 7,\n        OPENTYPE: 8,\n        TYPE0: 9,\n        MMTYPE1: 10\n      };\n      var VERBOSITY_LEVELS = {\n        errors: 0,\n        warnings: 1,\n        infos: 5\n      };\n\n      // All the possible operations for an operator list.\n      var OPS = {\n        // Intentionally start from 1 so it is easy to spot bad operators that will be\n        // 0's.\n        dependency: 1,\n        setLineWidth: 2,\n        setLineCap: 3,\n        setLineJoin: 4,\n        setMiterLimit: 5,\n        setDash: 6,\n        setRenderingIntent: 7,\n        setFlatness: 8,\n        setGState: 9,\n        save: 10,\n        restore: 11,\n        transform: 12,\n        moveTo: 13,\n        lineTo: 14,\n        curveTo: 15,\n        curveTo2: 16,\n        curveTo3: 17,\n        closePath: 18,\n        rectangle: 19,\n        stroke: 20,\n        closeStroke: 21,\n        fill: 22,\n        eoFill: 23,\n        fillStroke: 24,\n        eoFillStroke: 25,\n        closeFillStroke: 26,\n        closeEOFillStroke: 27,\n        endPath: 28,\n        clip: 29,\n        eoClip: 30,\n        beginText: 31,\n        endText: 32,\n        setCharSpacing: 33,\n        setWordSpacing: 34,\n        setHScale: 35,\n        setLeading: 36,\n        setFont: 37,\n        setTextRenderingMode: 38,\n        setTextRise: 39,\n        moveText: 40,\n        setLeadingMoveText: 41,\n        setTextMatrix: 42,\n        nextLine: 43,\n        showText: 44,\n        showSpacedText: 45,\n        nextLineShowText: 46,\n        nextLineSetSpacingShowText: 47,\n        setCharWidth: 48,\n        setCharWidthAndBounds: 49,\n        setStrokeColorSpace: 50,\n        setFillColorSpace: 51,\n        setStrokeColor: 52,\n        setStrokeColorN: 53,\n        setFillColor: 54,\n        setFillColorN: 55,\n        setStrokeGray: 56,\n        setFillGray: 57,\n        setStrokeRGBColor: 58,\n        setFillRGBColor: 59,\n        setStrokeCMYKColor: 60,\n        setFillCMYKColor: 61,\n        shadingFill: 62,\n        beginInlineImage: 63,\n        beginImageData: 64,\n        endInlineImage: 65,\n        paintXObject: 66,\n        markPoint: 67,\n        markPointProps: 68,\n        beginMarkedContent: 69,\n        beginMarkedContentProps: 70,\n        endMarkedContent: 71,\n        beginCompat: 72,\n        endCompat: 73,\n        paintFormXObjectBegin: 74,\n        paintFormXObjectEnd: 75,\n        beginGroup: 76,\n        endGroup: 77,\n        beginAnnotations: 78,\n        endAnnotations: 79,\n        beginAnnotation: 80,\n        endAnnotation: 81,\n        paintJpegXObject: 82,\n        paintImageMaskXObject: 83,\n        paintImageMaskXObjectGroup: 84,\n        paintImageXObject: 85,\n        paintInlineImageXObject: 86,\n        paintInlineImageXObjectGroup: 87,\n        paintImageXObjectRepeat: 88,\n        paintImageMaskXObjectRepeat: 89,\n        paintSolidColorImageMask: 90,\n        constructPath: 91\n      };\n      var verbosity = VERBOSITY_LEVELS.warnings;\n      function setVerbosityLevel(level) {\n        verbosity = level;\n      }\n      function getVerbosityLevel() {\n        return verbosity;\n      }\n\n      // A notice for devs. These are good for things that are helpful to devs, such\n      // as warning that Workers were disabled, which is important to devs but not\n      // end users.\n      function info(msg) {\n        if (verbosity >= VERBOSITY_LEVELS.infos) {\n          console.log('Info: ' + msg);\n        }\n      }\n\n      // Non-fatal warnings.\n      function warn(msg) {\n        if (verbosity >= VERBOSITY_LEVELS.warnings) {\n          console.log('Warning: ' + msg);\n        }\n      }\n\n      // Deprecated API function -- display regardless of the PDFJS.verbosity setting.\n      function deprecated(details) {\n        console.log('Deprecated API usage: ' + details);\n      }\n\n      // Fatal errors that should trigger the fallback UI and halt execution by\n      // throwing an exception.\n      function error(msg) {\n        if (verbosity >= VERBOSITY_LEVELS.errors) {\n          console.log('Error: ' + msg);\n          console.log(backtrace());\n        }\n        throw new Error(msg);\n      }\n      function backtrace() {\n        try {\n          throw new Error();\n        } catch (e) {\n          return e.stack ? e.stack.split('\\n').slice(2).join('\\n') : '';\n        }\n      }\n      function assert(cond, msg) {\n        if (!cond) {\n          error(msg);\n        }\n      }\n      var UNSUPPORTED_FEATURES = {\n        unknown: 'unknown',\n        forms: 'forms',\n        javaScript: 'javaScript',\n        smask: 'smask',\n        shadingPattern: 'shadingPattern',\n        font: 'font'\n      };\n\n      // Checks if URLs have the same origin. For non-HTTP based URLs, returns false.\n      function isSameOrigin(baseUrl, otherUrl) {\n        try {\n          var base = new URL(baseUrl);\n          if (!base.origin || base.origin === 'null') {\n            return false; // non-HTTP url\n          }\n        } catch (e) {\n          return false;\n        }\n        var other = new URL(otherUrl, base);\n        return base.origin === other.origin;\n      }\n\n      // Validates if URL is safe and allowed, e.g. to avoid XSS.\n      function isValidUrl(url, allowRelative) {\n        if (!url || typeof url !== 'string') {\n          return false;\n        }\n        // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)\n        // scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n        var protocol = /^[a-z][a-z0-9+\\-.]*(?=:)/i.exec(url);\n        if (!protocol) {\n          return allowRelative;\n        }\n        protocol = protocol[0].toLowerCase();\n        switch (protocol) {\n          case 'http':\n          case 'https':\n          case 'ftp':\n          case 'mailto':\n          case 'tel':\n            return true;\n          default:\n            return false;\n        }\n      }\n      function shadow(obj, prop, value) {\n        Object.defineProperty(obj, prop, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n        return value;\n      }\n      function getLookupTableFactory(initializer) {\n        var lookup;\n        return function () {\n          if (initializer) {\n            lookup = Object.create(null);\n            initializer(lookup);\n            initializer = null;\n          }\n          return lookup;\n        };\n      }\n      var PasswordResponses = {\n        NEED_PASSWORD: 1,\n        INCORRECT_PASSWORD: 2\n      };\n      var PasswordException = function PasswordExceptionClosure() {\n        function PasswordException(msg, code) {\n          this.name = 'PasswordException';\n          this.message = msg;\n          this.code = code;\n        }\n        PasswordException.prototype = new Error();\n        PasswordException.constructor = PasswordException;\n        return PasswordException;\n      }();\n      var UnknownErrorException = function UnknownErrorExceptionClosure() {\n        function UnknownErrorException(msg, details) {\n          this.name = 'UnknownErrorException';\n          this.message = msg;\n          this.details = details;\n        }\n        UnknownErrorException.prototype = new Error();\n        UnknownErrorException.constructor = UnknownErrorException;\n        return UnknownErrorException;\n      }();\n      var InvalidPDFException = function InvalidPDFExceptionClosure() {\n        function InvalidPDFException(msg) {\n          this.name = 'InvalidPDFException';\n          this.message = msg;\n        }\n        InvalidPDFException.prototype = new Error();\n        InvalidPDFException.constructor = InvalidPDFException;\n        return InvalidPDFException;\n      }();\n      var MissingPDFException = function MissingPDFExceptionClosure() {\n        function MissingPDFException(msg) {\n          this.name = 'MissingPDFException';\n          this.message = msg;\n        }\n        MissingPDFException.prototype = new Error();\n        MissingPDFException.constructor = MissingPDFException;\n        return MissingPDFException;\n      }();\n      var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {\n        function UnexpectedResponseException(msg, status) {\n          this.name = 'UnexpectedResponseException';\n          this.message = msg;\n          this.status = status;\n        }\n        UnexpectedResponseException.prototype = new Error();\n        UnexpectedResponseException.constructor = UnexpectedResponseException;\n        return UnexpectedResponseException;\n      }();\n      var NotImplementedException = function NotImplementedExceptionClosure() {\n        function NotImplementedException(msg) {\n          this.message = msg;\n        }\n        NotImplementedException.prototype = new Error();\n        NotImplementedException.prototype.name = 'NotImplementedException';\n        NotImplementedException.constructor = NotImplementedException;\n        return NotImplementedException;\n      }();\n      var MissingDataException = function MissingDataExceptionClosure() {\n        function MissingDataException(begin, end) {\n          this.begin = begin;\n          this.end = end;\n          this.message = 'Missing data [' + begin + ', ' + end + ')';\n        }\n        MissingDataException.prototype = new Error();\n        MissingDataException.prototype.name = 'MissingDataException';\n        MissingDataException.constructor = MissingDataException;\n        return MissingDataException;\n      }();\n      var XRefParseException = function XRefParseExceptionClosure() {\n        function XRefParseException(msg) {\n          this.message = msg;\n        }\n        XRefParseException.prototype = new Error();\n        XRefParseException.prototype.name = 'XRefParseException';\n        XRefParseException.constructor = XRefParseException;\n        return XRefParseException;\n      }();\n      var NullCharactersRegExp = /\\x00/g;\n      function removeNullCharacters(str) {\n        if (typeof str !== 'string') {\n          warn('The argument for removeNullCharacters must be a string.');\n          return str;\n        }\n        return str.replace(NullCharactersRegExp, '');\n      }\n      function bytesToString(bytes) {\n        assert(bytes !== null && typeof bytes === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');\n        var length = bytes.length;\n        var MAX_ARGUMENT_COUNT = 8192;\n        if (length < MAX_ARGUMENT_COUNT) {\n          return String.fromCharCode.apply(null, bytes);\n        }\n        var strBuf = [];\n        for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n          var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n          var chunk = bytes.subarray(i, chunkEnd);\n          strBuf.push(String.fromCharCode.apply(null, chunk));\n        }\n        return strBuf.join('');\n      }\n      function stringToBytes(str) {\n        assert(typeof str === 'string', 'Invalid argument for stringToBytes');\n        var length = str.length;\n        var bytes = new Uint8Array(length);\n        for (var i = 0; i < length; ++i) {\n          bytes[i] = str.charCodeAt(i) & 0xFF;\n        }\n        return bytes;\n      }\n\n      /**\r\n       * Gets length of the array (Array, Uint8Array, or string) in bytes.\r\n       * @param {Array|Uint8Array|string} arr\r\n       * @returns {number}\r\n       */\n      function arrayByteLength(arr) {\n        if (arr.length !== undefined) {\n          return arr.length;\n        }\n        assert(arr.byteLength !== undefined);\n        return arr.byteLength;\n      }\n\n      /**\r\n       * Combines array items (arrays) into single Uint8Array object.\r\n       * @param {Array} arr - the array of the arrays (Array, Uint8Array, or string).\r\n       * @returns {Uint8Array}\r\n       */\n      function arraysToBytes(arr) {\n        // Shortcut: if first and only item is Uint8Array, return it.\n        if (arr.length === 1 && arr[0] instanceof Uint8Array) {\n          return arr[0];\n        }\n        var resultLength = 0;\n        var i,\n          ii = arr.length;\n        var item, itemLength;\n        for (i = 0; i < ii; i++) {\n          item = arr[i];\n          itemLength = arrayByteLength(item);\n          resultLength += itemLength;\n        }\n        var pos = 0;\n        var data = new Uint8Array(resultLength);\n        for (i = 0; i < ii; i++) {\n          item = arr[i];\n          if (!(item instanceof Uint8Array)) {\n            if (typeof item === 'string') {\n              item = stringToBytes(item);\n            } else {\n              item = new Uint8Array(item);\n            }\n          }\n          itemLength = item.byteLength;\n          data.set(item, pos);\n          pos += itemLength;\n        }\n        return data;\n      }\n      function string32(value) {\n        return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n      }\n      function log2(x) {\n        var n = 1,\n          i = 0;\n        while (x > n) {\n          n <<= 1;\n          i++;\n        }\n        return i;\n      }\n      function readInt8(data, start) {\n        return data[start] << 24 >> 24;\n      }\n      function readUint16(data, offset) {\n        return data[offset] << 8 | data[offset + 1];\n      }\n      function readUint32(data, offset) {\n        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\n      }\n\n      // Lazy test the endianness of the platform\n      // NOTE: This will be 'true' for simulated TypedArrays\n      function isLittleEndian() {\n        var buffer8 = new Uint8Array(2);\n        buffer8[0] = 1;\n        var buffer16 = new Uint16Array(buffer8.buffer);\n        return buffer16[0] === 1;\n      }\n\n      // Checks if it's possible to eval JS expressions.\n      function isEvalSupported() {\n        try {\n          /* jshint evil: true */\n          new Function('');\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      var Uint32ArrayView = function Uint32ArrayViewClosure() {\n        function Uint32ArrayView(buffer, length) {\n          this.buffer = buffer;\n          this.byteLength = buffer.length;\n          this.length = length === undefined ? this.byteLength >> 2 : length;\n          ensureUint32ArrayViewProps(this.length);\n        }\n        Uint32ArrayView.prototype = Object.create(null);\n        var uint32ArrayViewSetters = 0;\n        function createUint32ArrayProp(index) {\n          return {\n            get: function get() {\n              var buffer = this.buffer,\n                offset = index << 2;\n              return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16 | buffer[offset + 3] << 24) >>> 0;\n            },\n            set: function set(value) {\n              var buffer = this.buffer,\n                offset = index << 2;\n              buffer[offset] = value & 255;\n              buffer[offset + 1] = value >> 8 & 255;\n              buffer[offset + 2] = value >> 16 & 255;\n              buffer[offset + 3] = value >>> 24 & 255;\n            }\n          };\n        }\n        function ensureUint32ArrayViewProps(length) {\n          while (uint32ArrayViewSetters < length) {\n            Object.defineProperty(Uint32ArrayView.prototype, uint32ArrayViewSetters, createUint32ArrayProp(uint32ArrayViewSetters));\n            uint32ArrayViewSetters++;\n          }\n        }\n        return Uint32ArrayView;\n      }();\n      exports.Uint32ArrayView = Uint32ArrayView;\n      var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n      var Util = function UtilClosure() {\n        function Util() {}\n        var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];\n\n        // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids\n        // creating many intermediate strings.\n        Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {\n          rgbBuf[1] = r;\n          rgbBuf[3] = g;\n          rgbBuf[5] = b;\n          return rgbBuf.join('');\n        };\n\n        // Concatenates two transformation matrices together and returns the result.\n        Util.transform = function Util_transform(m1, m2) {\n          return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n        };\n\n        // For 2d affine transforms\n        Util.applyTransform = function Util_applyTransform(p, m) {\n          var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n          var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n          return [xt, yt];\n        };\n        Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {\n          var d = m[0] * m[3] - m[1] * m[2];\n          var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n          var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n          return [xt, yt];\n        };\n\n        // Applies the transform to the rectangle and finds the minimum axially\n        // aligned bounding box.\n        Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {\n          var p1 = Util.applyTransform(r, m);\n          var p2 = Util.applyTransform(r.slice(2, 4), m);\n          var p3 = Util.applyTransform([r[0], r[3]], m);\n          var p4 = Util.applyTransform([r[2], r[1]], m);\n          return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n        };\n        Util.inverseTransform = function Util_inverseTransform(m) {\n          var d = m[0] * m[3] - m[1] * m[2];\n          return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n        };\n\n        // Apply a generic 3d matrix M on a 3-vector v:\n        //   | a b c |   | X |\n        //   | d e f | x | Y |\n        //   | g h i |   | Z |\n        // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],\n        // with v as [X,Y,Z]\n        Util.apply3dTransform = function Util_apply3dTransform(m, v) {\n          return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n        };\n\n        // This calculation uses Singular Value Decomposition.\n        // The SVD can be represented with formula A = USV. We are interested in the\n        // matrix S here because it represents the scale values.\n        Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {\n          var transpose = [m[0], m[2], m[1], m[3]];\n\n          // Multiply matrix m with its transpose.\n          var a = m[0] * transpose[0] + m[1] * transpose[2];\n          var b = m[0] * transpose[1] + m[1] * transpose[3];\n          var c = m[2] * transpose[0] + m[3] * transpose[2];\n          var d = m[2] * transpose[1] + m[3] * transpose[3];\n\n          // Solve the second degree polynomial to get roots.\n          var first = (a + d) / 2;\n          var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n          var sx = first + second || 1;\n          var sy = first - second || 1;\n\n          // Scale values are the square roots of the eigenvalues.\n          return [Math.sqrt(sx), Math.sqrt(sy)];\n        };\n\n        // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)\n        // For coordinate systems whose origin lies in the bottom-left, this\n        // means normalization to (BL,TR) ordering. For systems with origin in the\n        // top-left, this means (TL,BR) ordering.\n        Util.normalizeRect = function Util_normalizeRect(rect) {\n          var r = rect.slice(0); // clone rect\n          if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n          }\n          if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n          }\n          return r;\n        };\n\n        // Returns a rectangle [x1, y1, x2, y2] corresponding to the\n        // intersection of rect1 and rect2. If no intersection, returns 'false'\n        // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]\n        Util.intersect = function Util_intersect(rect1, rect2) {\n          function compare(a, b) {\n            return a - b;\n          }\n\n          // Order points along the axes\n          var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),\n            orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),\n            result = [];\n          rect1 = Util.normalizeRect(rect1);\n          rect2 = Util.normalizeRect(rect2);\n\n          // X: first and second points belong to different rectangles?\n          if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n            // Intersection must be between second and third points\n            result[0] = orderedX[1];\n            result[2] = orderedX[2];\n          } else {\n            return false;\n          }\n\n          // Y: first and second points belong to different rectangles?\n          if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n            // Intersection must be between second and third points\n            result[1] = orderedY[1];\n            result[3] = orderedY[2];\n          } else {\n            return false;\n          }\n          return result;\n        };\n        Util.sign = function Util_sign(num) {\n          return num < 0 ? -1 : 1;\n        };\n        var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];\n        /**\r\n         * Converts positive integers to (upper case) Roman numerals.\r\n         * @param {integer} number - The number that should be converted.\r\n         * @param {boolean} lowerCase - Indicates if the result should be converted\r\n         *   to lower case letters. The default is false.\r\n         * @return {string} The resulting Roman number.\r\n         */\n        Util.toRoman = function Util_toRoman(number, lowerCase) {\n          assert(isInt(number) && number > 0, 'The number should be a positive integer.');\n          var pos,\n            romanBuf = [];\n          // Thousands\n          while (number >= 1000) {\n            number -= 1000;\n            romanBuf.push('M');\n          }\n          // Hundreds\n          pos = number / 100 | 0;\n          number %= 100;\n          romanBuf.push(ROMAN_NUMBER_MAP[pos]);\n          // Tens\n          pos = number / 10 | 0;\n          number %= 10;\n          romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);\n          // Ones\n          romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);\n          var romanStr = romanBuf.join('');\n          return lowerCase ? romanStr.toLowerCase() : romanStr;\n        };\n        Util.appendToArray = function Util_appendToArray(arr1, arr2) {\n          Array.prototype.push.apply(arr1, arr2);\n        };\n        Util.prependToArray = function Util_prependToArray(arr1, arr2) {\n          Array.prototype.unshift.apply(arr1, arr2);\n        };\n        Util.extendObj = function extendObj(obj1, obj2) {\n          for (var key in obj2) {\n            obj1[key] = obj2[key];\n          }\n        };\n        Util.getInheritableProperty = function Util_getInheritableProperty(dict, name) {\n          while (dict && !dict.has(name)) {\n            dict = dict.get('Parent');\n          }\n          if (!dict) {\n            return null;\n          }\n          return dict.get(name);\n        };\n        Util.inherit = function Util_inherit(sub, base, prototype) {\n          sub.prototype = Object.create(base.prototype);\n          sub.prototype.constructor = sub;\n          for (var prop in prototype) {\n            sub.prototype[prop] = prototype[prop];\n          }\n        };\n        Util.loadScript = function Util_loadScript(src, callback) {\n          var script = document.createElement('script');\n          var loaded = false;\n          script.setAttribute('src', src);\n          if (callback) {\n            script.onload = function () {\n              if (!loaded) {\n                callback();\n              }\n              loaded = true;\n            };\n          }\n          document.getElementsByTagName('head')[0].appendChild(script);\n        };\n        return Util;\n      }();\n\n      /**\r\n       * PDF page viewport created based on scale, rotation and offset.\r\n       * @class\r\n       * @alias PageViewport\r\n       */\n      var PageViewport = function PageViewportClosure() {\n        /**\r\n         * @constructor\r\n         * @private\r\n         * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.\r\n         * @param scale {number} scale of the viewport.\r\n         * @param rotation {number} rotations of the viewport in degrees.\r\n         * @param offsetX {number} offset X\r\n         * @param offsetY {number} offset Y\r\n         * @param dontFlip {boolean} if true, axis Y will not be flipped.\r\n         */\n        function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {\n          this.viewBox = viewBox;\n          this.scale = scale;\n          this.rotation = rotation;\n          this.offsetX = offsetX;\n          this.offsetY = offsetY;\n\n          // creating transform to convert pdf coordinate system to the normal\n          // canvas like coordinates taking in account scale and rotation\n          var centerX = (viewBox[2] + viewBox[0]) / 2;\n          var centerY = (viewBox[3] + viewBox[1]) / 2;\n          var rotateA, rotateB, rotateC, rotateD;\n          rotation = rotation % 360;\n          rotation = rotation < 0 ? rotation + 360 : rotation;\n          switch (rotation) {\n            case 180:\n              rotateA = -1;\n              rotateB = 0;\n              rotateC = 0;\n              rotateD = 1;\n              break;\n            case 90:\n              rotateA = 0;\n              rotateB = 1;\n              rotateC = 1;\n              rotateD = 0;\n              break;\n            case 270:\n              rotateA = 0;\n              rotateB = -1;\n              rotateC = -1;\n              rotateD = 0;\n              break;\n            //case 0:\n            default:\n              rotateA = 1;\n              rotateB = 0;\n              rotateC = 0;\n              rotateD = -1;\n              break;\n          }\n          if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n          }\n          var offsetCanvasX, offsetCanvasY;\n          var width, height;\n          if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n            height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n          } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n            height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n          }\n          // creating transform for the following operations:\n          // translate(-centerX, -centerY), rotate and flip vertically,\n          // scale, and translate(offsetCanvasX, offsetCanvasY)\n          this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n          this.width = width;\n          this.height = height;\n          this.fontScale = scale;\n        }\n        PageViewport.prototype = /** @lends PageViewport.prototype */{\n          /**\r\n           * Clones viewport with additional properties.\r\n           * @param args {Object} (optional) If specified, may contain the 'scale' or\r\n           * 'rotation' properties to override the corresponding properties in\r\n           * the cloned viewport.\r\n           * @returns {PageViewport} Cloned viewport.\r\n           */\n          clone: function PageViewPort_clone(args) {\n            args = args || {};\n            var scale = 'scale' in args ? args.scale : this.scale;\n            var rotation = 'rotation' in args ? args.rotation : this.rotation;\n            return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);\n          },\n          /**\r\n           * Converts PDF point to the viewport coordinates. For examples, useful for\r\n           * converting PDF location into canvas pixel coordinates.\r\n           * @param x {number} X coordinate.\r\n           * @param y {number} Y coordinate.\r\n           * @returns {Object} Object that contains 'x' and 'y' properties of the\r\n           * point in the viewport coordinate space.\r\n           * @see {@link convertToPdfPoint}\r\n           * @see {@link convertToViewportRectangle}\r\n           */\n          convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {\n            return Util.applyTransform([x, y], this.transform);\n          },\n          /**\r\n           * Converts PDF rectangle to the viewport coordinates.\r\n           * @param rect {Array} xMin, yMin, xMax and yMax coordinates.\r\n           * @returns {Array} Contains corresponding coordinates of the rectangle\r\n           * in the viewport coordinate space.\r\n           * @see {@link convertToViewportPoint}\r\n           */\n          convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {\n            var tl = Util.applyTransform([rect[0], rect[1]], this.transform);\n            var br = Util.applyTransform([rect[2], rect[3]], this.transform);\n            return [tl[0], tl[1], br[0], br[1]];\n          },\n          /**\r\n           * Converts viewport coordinates to the PDF location. For examples, useful\r\n           * for converting canvas pixel location into PDF one.\r\n           * @param x {number} X coordinate.\r\n           * @param y {number} Y coordinate.\r\n           * @returns {Object} Object that contains 'x' and 'y' properties of the\r\n           * point in the PDF coordinate space.\r\n           * @see {@link convertToViewportPoint}\r\n           */\n          convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {\n            return Util.applyInverseTransform([x, y], this.transform);\n          }\n        };\n        return PageViewport;\n      }();\n      var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\n      function stringToPDFString(str) {\n        var i,\n          n = str.length,\n          strBuf = [];\n        if (str[0] === '\\xFE' && str[1] === '\\xFF') {\n          // UTF16BE BOM\n          for (i = 2; i < n; i += 2) {\n            strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n          }\n        } else {\n          for (i = 0; i < n; ++i) {\n            var code = PDFStringTranslateTable[str.charCodeAt(i)];\n            strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n          }\n        }\n        return strBuf.join('');\n      }\n      function stringToUTF8String(str) {\n        return decodeURIComponent(escape(str));\n      }\n      function utf8StringToString(str) {\n        return unescape(encodeURIComponent(str));\n      }\n      function isEmptyObj(obj) {\n        for (var key in obj) {\n          return false;\n        }\n        return true;\n      }\n      function isBool(v) {\n        return typeof v === 'boolean';\n      }\n      function isInt(v) {\n        return typeof v === 'number' && (v | 0) === v;\n      }\n      function isNum(v) {\n        return typeof v === 'number';\n      }\n      function isString(v) {\n        return typeof v === 'string';\n      }\n      function isArray(v) {\n        return v instanceof Array;\n      }\n      function isArrayBuffer(v) {\n        return typeof v === 'object' && v !== null && v.byteLength !== undefined;\n      }\n\n      /**\r\n       * Promise Capability object.\r\n       *\r\n       * @typedef {Object} PromiseCapability\r\n       * @property {Promise} promise - A promise object.\r\n       * @property {function} resolve - Fullfills the promise.\r\n       * @property {function} reject - Rejects the promise.\r\n       */\n\n      /**\r\n       * Creates a promise capability object.\r\n       * @alias createPromiseCapability\r\n       *\r\n       * @return {PromiseCapability} A capability object contains:\r\n       * - a Promise, resolve and reject methods.\r\n       */\n      function createPromiseCapability() {\n        var capability = {};\n        capability.promise = new Promise(function (resolve, reject) {\n          capability.resolve = resolve;\n          capability.reject = reject;\n        });\n        return capability;\n      }\n\n      /**\r\n       * Polyfill for Promises:\r\n       * The following promise implementation tries to generally implement the\r\n       * Promise/A+ spec. Some notable differences from other promise libaries are:\r\n       * - There currently isn't a seperate deferred and promise object.\r\n       * - Unhandled rejections eventually show an error if they aren't handled.\r\n       *\r\n       * Based off of the work in:\r\n       * https://bugzilla.mozilla.org/show_bug.cgi?id=810490\r\n       */\n      (function PromiseClosure() {\n        if (globalScope.Promise) {\n          // Promises existing in the DOM/Worker, checking presence of all/resolve\n          if (typeof globalScope.Promise.all !== 'function') {\n            globalScope.Promise.all = function (iterable) {\n              var count = 0,\n                results = [],\n                resolve,\n                reject;\n              var promise = new globalScope.Promise(function (resolve_, reject_) {\n                resolve = resolve_;\n                reject = reject_;\n              });\n              iterable.forEach(function (p, i) {\n                count++;\n                p.then(function (result) {\n                  results[i] = result;\n                  count--;\n                  if (count === 0) {\n                    resolve(results);\n                  }\n                }, reject);\n              });\n              if (count === 0) {\n                resolve(results);\n              }\n              return promise;\n            };\n          }\n          if (typeof globalScope.Promise.resolve !== 'function') {\n            globalScope.Promise.resolve = function (value) {\n              return new globalScope.Promise(function (resolve) {\n                resolve(value);\n              });\n            };\n          }\n          if (typeof globalScope.Promise.reject !== 'function') {\n            globalScope.Promise.reject = function (reason) {\n              return new globalScope.Promise(function (resolve, reject) {\n                reject(reason);\n              });\n            };\n          }\n          if (typeof globalScope.Promise.prototype.catch !== 'function') {\n            globalScope.Promise.prototype.catch = function (onReject) {\n              return globalScope.Promise.prototype.then(undefined, onReject);\n            };\n          }\n          return;\n        }\n        var STATUS_PENDING = 0;\n        var STATUS_RESOLVED = 1;\n        var STATUS_REJECTED = 2;\n\n        // In an attempt to avoid silent exceptions, unhandled rejections are\n        // tracked and if they aren't handled in a certain amount of time an\n        // error is logged.\n        var REJECTION_TIMEOUT = 500;\n        var HandlerManager = {\n          handlers: [],\n          running: false,\n          unhandledRejections: [],\n          pendingRejectionCheck: false,\n          scheduleHandlers: function scheduleHandlers(promise) {\n            if (promise._status === STATUS_PENDING) {\n              return;\n            }\n            this.handlers = this.handlers.concat(promise._handlers);\n            promise._handlers = [];\n            if (this.running) {\n              return;\n            }\n            this.running = true;\n            setTimeout(this.runHandlers.bind(this), 0);\n          },\n          runHandlers: function runHandlers() {\n            var RUN_TIMEOUT = 1; // ms\n            var timeoutAt = Date.now() + RUN_TIMEOUT;\n            while (this.handlers.length > 0) {\n              var handler = this.handlers.shift();\n              var nextStatus = handler.thisPromise._status;\n              var nextValue = handler.thisPromise._value;\n              try {\n                if (nextStatus === STATUS_RESOLVED) {\n                  if (typeof handler.onResolve === 'function') {\n                    nextValue = handler.onResolve(nextValue);\n                  }\n                } else if (typeof handler.onReject === 'function') {\n                  nextValue = handler.onReject(nextValue);\n                  nextStatus = STATUS_RESOLVED;\n                  if (handler.thisPromise._unhandledRejection) {\n                    this.removeUnhandeledRejection(handler.thisPromise);\n                  }\n                }\n              } catch (ex) {\n                nextStatus = STATUS_REJECTED;\n                nextValue = ex;\n              }\n              handler.nextPromise._updateStatus(nextStatus, nextValue);\n              if (Date.now() >= timeoutAt) {\n                break;\n              }\n            }\n            if (this.handlers.length > 0) {\n              setTimeout(this.runHandlers.bind(this), 0);\n              return;\n            }\n            this.running = false;\n          },\n          addUnhandledRejection: function addUnhandledRejection(promise) {\n            this.unhandledRejections.push({\n              promise: promise,\n              time: Date.now()\n            });\n            this.scheduleRejectionCheck();\n          },\n          removeUnhandeledRejection: function removeUnhandeledRejection(promise) {\n            promise._unhandledRejection = false;\n            for (var i = 0; i < this.unhandledRejections.length; i++) {\n              if (this.unhandledRejections[i].promise === promise) {\n                this.unhandledRejections.splice(i);\n                i--;\n              }\n            }\n          },\n          scheduleRejectionCheck: function scheduleRejectionCheck() {\n            if (this.pendingRejectionCheck) {\n              return;\n            }\n            this.pendingRejectionCheck = true;\n            setTimeout(function rejectionCheck() {\n              this.pendingRejectionCheck = false;\n              var now = Date.now();\n              for (var i = 0; i < this.unhandledRejections.length; i++) {\n                if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {\n                  var unhandled = this.unhandledRejections[i].promise._value;\n                  var msg = 'Unhandled rejection: ' + unhandled;\n                  if (unhandled.stack) {\n                    msg += '\\n' + unhandled.stack;\n                  }\n                  warn(msg);\n                  this.unhandledRejections.splice(i);\n                  i--;\n                }\n              }\n              if (this.unhandledRejections.length) {\n                this.scheduleRejectionCheck();\n              }\n            }.bind(this), REJECTION_TIMEOUT);\n          }\n        };\n        function Promise(resolver) {\n          this._status = STATUS_PENDING;\n          this._handlers = [];\n          try {\n            resolver.call(this, this._resolve.bind(this), this._reject.bind(this));\n          } catch (e) {\n            this._reject(e);\n          }\n        }\n        /**\r\n         * Builds a promise that is resolved when all the passed in promises are\r\n         * resolved.\r\n         * @param {array} array of data and/or promises to wait for.\r\n         * @return {Promise} New dependant promise.\r\n         */\n        Promise.all = function Promise_all(promises) {\n          var resolveAll, rejectAll;\n          var deferred = new Promise(function (resolve, reject) {\n            resolveAll = resolve;\n            rejectAll = reject;\n          });\n          var unresolved = promises.length;\n          var results = [];\n          if (unresolved === 0) {\n            resolveAll(results);\n            return deferred;\n          }\n          function reject(reason) {\n            if (deferred._status === STATUS_REJECTED) {\n              return;\n            }\n            results = [];\n            rejectAll(reason);\n          }\n          for (var i = 0, ii = promises.length; i < ii; ++i) {\n            var promise = promises[i];\n            var resolve = function (i) {\n              return function (value) {\n                if (deferred._status === STATUS_REJECTED) {\n                  return;\n                }\n                results[i] = value;\n                unresolved--;\n                if (unresolved === 0) {\n                  resolveAll(results);\n                }\n              };\n            }(i);\n            if (Promise.isPromise(promise)) {\n              promise.then(resolve, reject);\n            } else {\n              resolve(promise);\n            }\n          }\n          return deferred;\n        };\n\n        /**\r\n         * Checks if the value is likely a promise (has a 'then' function).\r\n         * @return {boolean} true if value is thenable\r\n         */\n        Promise.isPromise = function Promise_isPromise(value) {\n          return value && typeof value.then === 'function';\n        };\n\n        /**\r\n         * Creates resolved promise\r\n         * @param value resolve value\r\n         * @returns {Promise}\r\n         */\n        Promise.resolve = function Promise_resolve(value) {\n          return new Promise(function (resolve) {\n            resolve(value);\n          });\n        };\n\n        /**\r\n         * Creates rejected promise\r\n         * @param reason rejection value\r\n         * @returns {Promise}\r\n         */\n        Promise.reject = function Promise_reject(reason) {\n          return new Promise(function (resolve, reject) {\n            reject(reason);\n          });\n        };\n        Promise.prototype = {\n          _status: null,\n          _value: null,\n          _handlers: null,\n          _unhandledRejection: null,\n          _updateStatus: function Promise__updateStatus(status, value) {\n            if (this._status === STATUS_RESOLVED || this._status === STATUS_REJECTED) {\n              return;\n            }\n            if (status === STATUS_RESOLVED && Promise.isPromise(value)) {\n              value.then(this._updateStatus.bind(this, STATUS_RESOLVED), this._updateStatus.bind(this, STATUS_REJECTED));\n              return;\n            }\n            this._status = status;\n            this._value = value;\n            if (status === STATUS_REJECTED && this._handlers.length === 0) {\n              this._unhandledRejection = true;\n              HandlerManager.addUnhandledRejection(this);\n            }\n            HandlerManager.scheduleHandlers(this);\n          },\n          _resolve: function Promise_resolve(value) {\n            this._updateStatus(STATUS_RESOLVED, value);\n          },\n          _reject: function Promise_reject(reason) {\n            this._updateStatus(STATUS_REJECTED, reason);\n          },\n          then: function Promise_then(onResolve, onReject) {\n            var nextPromise = new Promise(function (resolve, reject) {\n              this.resolve = resolve;\n              this.reject = reject;\n            });\n            this._handlers.push({\n              thisPromise: this,\n              onResolve: onResolve,\n              onReject: onReject,\n              nextPromise: nextPromise\n            });\n            HandlerManager.scheduleHandlers(this);\n            return nextPromise;\n          },\n          catch: function Promise_catch(onReject) {\n            return this.then(undefined, onReject);\n          }\n        };\n        globalScope.Promise = Promise;\n      })();\n      var StatTimer = function StatTimerClosure() {\n        function rpad(str, pad, length) {\n          while (str.length < length) {\n            str += pad;\n          }\n          return str;\n        }\n        function StatTimer() {\n          this.started = Object.create(null);\n          this.times = [];\n          this.enabled = true;\n        }\n        StatTimer.prototype = {\n          time: function StatTimer_time(name) {\n            if (!this.enabled) {\n              return;\n            }\n            if (name in this.started) {\n              warn('Timer is already running for ' + name);\n            }\n            this.started[name] = Date.now();\n          },\n          timeEnd: function StatTimer_timeEnd(name) {\n            if (!this.enabled) {\n              return;\n            }\n            if (!(name in this.started)) {\n              warn('Timer has not been started for ' + name);\n            }\n            this.times.push({\n              'name': name,\n              'start': this.started[name],\n              'end': Date.now()\n            });\n            // Remove timer from started so it can be called again.\n            delete this.started[name];\n          },\n          toString: function StatTimer_toString() {\n            var i, ii;\n            var times = this.times;\n            var out = '';\n            // Find the longest name for padding purposes.\n            var longest = 0;\n            for (i = 0, ii = times.length; i < ii; ++i) {\n              var name = times[i]['name'];\n              if (name.length > longest) {\n                longest = name.length;\n              }\n            }\n            for (i = 0, ii = times.length; i < ii; ++i) {\n              var span = times[i];\n              var duration = span.end - span.start;\n              out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\\n';\n            }\n            return out;\n          }\n        };\n        return StatTimer;\n      }();\n      var createBlob = function createBlob(data, contentType) {\n        if (typeof Blob !== 'undefined') {\n          return new Blob([data], {\n            type: contentType\n          });\n        }\n        // Blob builder is deprecated in FF14 and removed in FF18.\n        var bb = new MozBlobBuilder();\n        bb.append(data);\n        return bb.getBlob(contentType);\n      };\n      var createObjectURL = function createObjectURLClosure() {\n        // Blob/createObjectURL is not available, falling back to data schema.\n        var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        return function createObjectURL(data, contentType, forceDataSchema) {\n          if (!forceDataSchema && typeof URL !== 'undefined' && URL.createObjectURL) {\n            var blob = createBlob(data, contentType);\n            return URL.createObjectURL(blob);\n          }\n          var buffer = 'data:' + contentType + ';base64,';\n          for (var i = 0, ii = data.length; i < ii; i += 3) {\n            var b1 = data[i] & 0xFF;\n            var b2 = data[i + 1] & 0xFF;\n            var b3 = data[i + 2] & 0xFF;\n            var d1 = b1 >> 2,\n              d2 = (b1 & 3) << 4 | b2 >> 4;\n            var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;\n            var d4 = i + 2 < ii ? b3 & 0x3F : 64;\n            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n          }\n          return buffer;\n        };\n      }();\n      function MessageHandler(sourceName, targetName, comObj) {\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackIndex = 1;\n        this.postMessageTransfers = true;\n        var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);\n        var ah = this.actionHandler = Object.create(null);\n        this._onComObjOnMessage = function messageHandlerComObjOnMessage(event) {\n          var data = event.data;\n          if (data.targetName !== this.sourceName) {\n            return;\n          }\n          if (data.isReply) {\n            var callbackId = data.callbackId;\n            if (data.callbackId in callbacksCapabilities) {\n              var callback = callbacksCapabilities[callbackId];\n              delete callbacksCapabilities[callbackId];\n              if ('error' in data) {\n                callback.reject(data.error);\n              } else {\n                callback.resolve(data.data);\n              }\n            } else {\n              error('Cannot resolve callback ' + callbackId);\n            }\n          } else if (data.action in ah) {\n            var action = ah[data.action];\n            if (data.callbackId) {\n              var sourceName = this.sourceName;\n              var targetName = data.sourceName;\n              Promise.resolve().then(function () {\n                return action[0].call(action[1], data.data);\n              }).then(function (result) {\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  isReply: true,\n                  callbackId: data.callbackId,\n                  data: result\n                });\n              }, function (reason) {\n                if (reason instanceof Error) {\n                  // Serialize error to avoid \"DataCloneError\"\n                  reason = reason + '';\n                }\n                comObj.postMessage({\n                  sourceName: sourceName,\n                  targetName: targetName,\n                  isReply: true,\n                  callbackId: data.callbackId,\n                  error: reason\n                });\n              });\n            } else {\n              action[0].call(action[1], data.data);\n            }\n          } else {\n            error('Unknown action from worker: ' + data.action);\n          }\n        }.bind(this);\n        comObj.addEventListener('message', this._onComObjOnMessage);\n      }\n      MessageHandler.prototype = {\n        on: function messageHandlerOn(actionName, handler, scope) {\n          var ah = this.actionHandler;\n          if (ah[actionName]) {\n            error('There is already an actionName called \"' + actionName + '\"');\n          }\n          ah[actionName] = [handler, scope];\n        },\n        /**\r\n         * Sends a message to the comObj to invoke the action with the supplied data.\r\n         * @param {String} actionName Action to call.\r\n         * @param {JSON} data JSON data to send.\r\n         * @param {Array} [transfers] Optional list of transfers/ArrayBuffers\r\n         */\n        send: function messageHandlerSend(actionName, data, transfers) {\n          var message = {\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data: data\n          };\n          this.postMessage(message, transfers);\n        },\n        /**\r\n         * Sends a message to the comObj to invoke the action with the supplied data.\r\n         * Expects that other side will callback with the response.\r\n         * @param {String} actionName Action to call.\r\n         * @param {JSON} data JSON data to send.\r\n         * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.\r\n         * @returns {Promise} Promise to be resolved with response data.\r\n         */\n        sendWithPromise: function messageHandlerSendWithPromise(actionName, data, transfers) {\n          var callbackId = this.callbackIndex++;\n          var message = {\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data: data,\n            callbackId: callbackId\n          };\n          var capability = createPromiseCapability();\n          this.callbacksCapabilities[callbackId] = capability;\n          try {\n            this.postMessage(message, transfers);\n          } catch (e) {\n            capability.reject(e);\n          }\n          return capability.promise;\n        },\n        /**\r\n         * Sends raw message to the comObj.\r\n         * @private\r\n         * @param message {Object} Raw message.\r\n         * @param transfers List of transfers/ArrayBuffers, or undefined.\r\n         */\n        postMessage: function postMessage(message, transfers) {\n          if (transfers && this.postMessageTransfers) {\n            this.comObj.postMessage(message, transfers);\n          } else {\n            this.comObj.postMessage(message);\n          }\n        },\n        destroy: function destroy() {\n          this.comObj.removeEventListener('message', this._onComObjOnMessage);\n        }\n      };\n      function loadJpegStream(id, imageUrl, objs) {\n        var img = new Image();\n        img.onload = function loadJpegStream_onloadClosure() {\n          objs.resolve(id, img);\n        };\n        img.onerror = function loadJpegStream_onerrorClosure() {\n          objs.resolve(id, null);\n          warn('Error during JPEG image loading');\n        };\n        img.src = imageUrl;\n      }\n\n      // Polyfill from https://github.com/Polymer/URL\n      /* Any copyright is dedicated to the Public Domain.\r\n       * http://creativecommons.org/publicdomain/zero/1.0/ */\n      (function checkURLConstructor(scope) {\n        /* jshint ignore:start */\n\n        // feature detect for URL constructor\n        var hasWorkingUrl = false;\n        try {\n          if (typeof URL === 'function' && typeof URL.prototype === 'object' && 'origin' in URL.prototype) {\n            var u = new URL('b', 'http://a');\n            u.pathname = 'c%20d';\n            hasWorkingUrl = u.href === 'http://a/c%20d';\n          }\n        } catch (e) {}\n        if (hasWorkingUrl) return;\n        var relative = Object.create(null);\n        relative['ftp'] = 21;\n        relative['file'] = 0;\n        relative['gopher'] = 70;\n        relative['http'] = 80;\n        relative['https'] = 443;\n        relative['ws'] = 80;\n        relative['wss'] = 443;\n        var relativePathDotMapping = Object.create(null);\n        relativePathDotMapping['%2e'] = '.';\n        relativePathDotMapping['.%2e'] = '..';\n        relativePathDotMapping['%2e.'] = '..';\n        relativePathDotMapping['%2e%2e'] = '..';\n        function isRelativeScheme(scheme) {\n          return relative[scheme] !== undefined;\n        }\n        function invalid() {\n          clear.call(this);\n          this._isInvalid = true;\n        }\n        function IDNAToASCII(h) {\n          if ('' == h) {\n            invalid.call(this);\n          }\n          // XXX\n          return h.toLowerCase();\n        }\n        function percentEscape(c) {\n          var unicode = c.charCodeAt(0);\n          if (unicode > 0x20 && unicode < 0x7F &&\n          // \" # < > ? `\n          [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) == -1) {\n            return c;\n          }\n          return encodeURIComponent(c);\n        }\n        function percentEscapeQuery(c) {\n          // XXX This actually needs to encode c using encoding and then\n          // convert the bytes one-by-one.\n\n          var unicode = c.charCodeAt(0);\n          if (unicode > 0x20 && unicode < 0x7F &&\n          // \" # < > ` (do not escape '?')\n          [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) == -1) {\n            return c;\n          }\n          return encodeURIComponent(c);\n        }\n        var EOF = undefined,\n          ALPHA = /[a-zA-Z]/,\n          ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n        function parse(input, stateOverride, base) {\n          function err(message) {\n            errors.push(message);\n          }\n          var state = stateOverride || 'scheme start',\n            cursor = 0,\n            buffer = '',\n            seenAt = false,\n            seenBracket = false,\n            errors = [];\n          loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n            var c = input[cursor];\n            switch (state) {\n              case 'scheme start':\n                if (c && ALPHA.test(c)) {\n                  buffer += c.toLowerCase(); // ASCII-safe\n                  state = 'scheme';\n                } else if (!stateOverride) {\n                  buffer = '';\n                  state = 'no scheme';\n                  continue;\n                } else {\n                  err('Invalid scheme.');\n                  break loop;\n                }\n                break;\n              case 'scheme':\n                if (c && ALPHANUMERIC.test(c)) {\n                  buffer += c.toLowerCase(); // ASCII-safe\n                } else if (':' == c) {\n                  this._scheme = buffer;\n                  buffer = '';\n                  if (stateOverride) {\n                    break loop;\n                  }\n                  if (isRelativeScheme(this._scheme)) {\n                    this._isRelative = true;\n                  }\n                  if ('file' == this._scheme) {\n                    state = 'relative';\n                  } else if (this._isRelative && base && base._scheme == this._scheme) {\n                    state = 'relative or authority';\n                  } else if (this._isRelative) {\n                    state = 'authority first slash';\n                  } else {\n                    state = 'scheme data';\n                  }\n                } else if (!stateOverride) {\n                  buffer = '';\n                  cursor = 0;\n                  state = 'no scheme';\n                  continue;\n                } else if (EOF == c) {\n                  break loop;\n                } else {\n                  err('Code point not allowed in scheme: ' + c);\n                  break loop;\n                }\n                break;\n              case 'scheme data':\n                if ('?' == c) {\n                  this._query = '?';\n                  state = 'query';\n                } else if ('#' == c) {\n                  this._fragment = '#';\n                  state = 'fragment';\n                } else {\n                  // XXX error handling\n                  if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n                    this._schemeData += percentEscape(c);\n                  }\n                }\n                break;\n              case 'no scheme':\n                if (!base || !isRelativeScheme(base._scheme)) {\n                  err('Missing scheme.');\n                  invalid.call(this);\n                } else {\n                  state = 'relative';\n                  continue;\n                }\n                break;\n              case 'relative or authority':\n                if ('/' == c && '/' == input[cursor + 1]) {\n                  state = 'authority ignore slashes';\n                } else {\n                  err('Expected /, got: ' + c);\n                  state = 'relative';\n                  continue;\n                }\n                break;\n              case 'relative':\n                this._isRelative = true;\n                if ('file' != this._scheme) this._scheme = base._scheme;\n                if (EOF == c) {\n                  this._host = base._host;\n                  this._port = base._port;\n                  this._path = base._path.slice();\n                  this._query = base._query;\n                  this._username = base._username;\n                  this._password = base._password;\n                  break loop;\n                } else if ('/' == c || '\\\\' == c) {\n                  if ('\\\\' == c) err('\\\\ is an invalid code point.');\n                  state = 'relative slash';\n                } else if ('?' == c) {\n                  this._host = base._host;\n                  this._port = base._port;\n                  this._path = base._path.slice();\n                  this._query = '?';\n                  this._username = base._username;\n                  this._password = base._password;\n                  state = 'query';\n                } else if ('#' == c) {\n                  this._host = base._host;\n                  this._port = base._port;\n                  this._path = base._path.slice();\n                  this._query = base._query;\n                  this._fragment = '#';\n                  this._username = base._username;\n                  this._password = base._password;\n                  state = 'fragment';\n                } else {\n                  var nextC = input[cursor + 1];\n                  var nextNextC = input[cursor + 2];\n                  if ('file' != this._scheme || !ALPHA.test(c) || nextC != ':' && nextC != '|' || EOF != nextNextC && '/' != nextNextC && '\\\\' != nextNextC && '?' != nextNextC && '#' != nextNextC) {\n                    this._host = base._host;\n                    this._port = base._port;\n                    this._username = base._username;\n                    this._password = base._password;\n                    this._path = base._path.slice();\n                    this._path.pop();\n                  }\n                  state = 'relative path';\n                  continue;\n                }\n                break;\n              case 'relative slash':\n                if ('/' == c || '\\\\' == c) {\n                  if ('\\\\' == c) {\n                    err('\\\\ is an invalid code point.');\n                  }\n                  if ('file' == this._scheme) {\n                    state = 'file host';\n                  } else {\n                    state = 'authority ignore slashes';\n                  }\n                } else {\n                  if ('file' != this._scheme) {\n                    this._host = base._host;\n                    this._port = base._port;\n                    this._username = base._username;\n                    this._password = base._password;\n                  }\n                  state = 'relative path';\n                  continue;\n                }\n                break;\n              case 'authority first slash':\n                if ('/' == c) {\n                  state = 'authority second slash';\n                } else {\n                  err(\"Expected '/', got: \" + c);\n                  state = 'authority ignore slashes';\n                  continue;\n                }\n                break;\n              case 'authority second slash':\n                state = 'authority ignore slashes';\n                if ('/' != c) {\n                  err(\"Expected '/', got: \" + c);\n                  continue;\n                }\n                break;\n              case 'authority ignore slashes':\n                if ('/' != c && '\\\\' != c) {\n                  state = 'authority';\n                  continue;\n                } else {\n                  err('Expected authority, got: ' + c);\n                }\n                break;\n              case 'authority':\n                if ('@' == c) {\n                  if (seenAt) {\n                    err('@ already seen.');\n                    buffer += '%40';\n                  }\n                  seenAt = true;\n                  for (var i = 0; i < buffer.length; i++) {\n                    var cp = buffer[i];\n                    if ('\\t' == cp || '\\n' == cp || '\\r' == cp) {\n                      err('Invalid whitespace in authority.');\n                      continue;\n                    }\n                    // XXX check URL code points\n                    if (':' == cp && null === this._password) {\n                      this._password = '';\n                      continue;\n                    }\n                    var tempC = percentEscape(cp);\n                    null !== this._password ? this._password += tempC : this._username += tempC;\n                  }\n                  buffer = '';\n                } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n                  cursor -= buffer.length;\n                  buffer = '';\n                  state = 'host';\n                  continue;\n                } else {\n                  buffer += c;\n                }\n                break;\n              case 'file host':\n                if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n                  if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ':' || buffer[1] == '|')) {\n                    state = 'relative path';\n                  } else if (buffer.length == 0) {\n                    state = 'relative path start';\n                  } else {\n                    this._host = IDNAToASCII.call(this, buffer);\n                    buffer = '';\n                    state = 'relative path start';\n                  }\n                  continue;\n                } else if ('\\t' == c || '\\n' == c || '\\r' == c) {\n                  err('Invalid whitespace in file host.');\n                } else {\n                  buffer += c;\n                }\n                break;\n              case 'host':\n              case 'hostname':\n                if (':' == c && !seenBracket) {\n                  // XXX host parsing\n                  this._host = IDNAToASCII.call(this, buffer);\n                  buffer = '';\n                  state = 'port';\n                  if ('hostname' == stateOverride) {\n                    break loop;\n                  }\n                } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c) {\n                  this._host = IDNAToASCII.call(this, buffer);\n                  buffer = '';\n                  state = 'relative path start';\n                  if (stateOverride) {\n                    break loop;\n                  }\n                  continue;\n                } else if ('\\t' != c && '\\n' != c && '\\r' != c) {\n                  if ('[' == c) {\n                    seenBracket = true;\n                  } else if (']' == c) {\n                    seenBracket = false;\n                  }\n                  buffer += c;\n                } else {\n                  err('Invalid code point in host/hostname: ' + c);\n                }\n                break;\n              case 'port':\n                if (/[0-9]/.test(c)) {\n                  buffer += c;\n                } else if (EOF == c || '/' == c || '\\\\' == c || '?' == c || '#' == c || stateOverride) {\n                  if ('' != buffer) {\n                    var temp = parseInt(buffer, 10);\n                    if (temp != relative[this._scheme]) {\n                      this._port = temp + '';\n                    }\n                    buffer = '';\n                  }\n                  if (stateOverride) {\n                    break loop;\n                  }\n                  state = 'relative path start';\n                  continue;\n                } else if ('\\t' == c || '\\n' == c || '\\r' == c) {\n                  err('Invalid code point in port: ' + c);\n                } else {\n                  invalid.call(this);\n                }\n                break;\n              case 'relative path start':\n                if ('\\\\' == c) err(\"'\\\\' not allowed in path.\");\n                state = 'relative path';\n                if ('/' != c && '\\\\' != c) {\n                  continue;\n                }\n                break;\n              case 'relative path':\n                if (EOF == c || '/' == c || '\\\\' == c || !stateOverride && ('?' == c || '#' == c)) {\n                  if ('\\\\' == c) {\n                    err('\\\\ not allowed in relative path.');\n                  }\n                  var tmp;\n                  if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n                    buffer = tmp;\n                  }\n                  if ('..' == buffer) {\n                    this._path.pop();\n                    if ('/' != c && '\\\\' != c) {\n                      this._path.push('');\n                    }\n                  } else if ('.' == buffer && '/' != c && '\\\\' != c) {\n                    this._path.push('');\n                  } else if ('.' != buffer) {\n                    if ('file' == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == '|') {\n                      buffer = buffer[0] + ':';\n                    }\n                    this._path.push(buffer);\n                  }\n                  buffer = '';\n                  if ('?' == c) {\n                    this._query = '?';\n                    state = 'query';\n                  } else if ('#' == c) {\n                    this._fragment = '#';\n                    state = 'fragment';\n                  }\n                } else if ('\\t' != c && '\\n' != c && '\\r' != c) {\n                  buffer += percentEscape(c);\n                }\n                break;\n              case 'query':\n                if (!stateOverride && '#' == c) {\n                  this._fragment = '#';\n                  state = 'fragment';\n                } else if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n                  this._query += percentEscapeQuery(c);\n                }\n                break;\n              case 'fragment':\n                if (EOF != c && '\\t' != c && '\\n' != c && '\\r' != c) {\n                  this._fragment += c;\n                }\n                break;\n            }\n            cursor++;\n          }\n        }\n        function clear() {\n          this._scheme = '';\n          this._schemeData = '';\n          this._username = '';\n          this._password = null;\n          this._host = '';\n          this._port = '';\n          this._path = [];\n          this._query = '';\n          this._fragment = '';\n          this._isInvalid = false;\n          this._isRelative = false;\n        }\n\n        // Does not process domain names or IP addresses.\n        // Does not handle encoding for the query parameter.\n        function jURL(url, base /* , encoding */) {\n          if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n          this._url = url;\n          clear.call(this);\n          var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, '');\n          // encoding = encoding || 'utf-8'\n\n          parse.call(this, input, null, base);\n        }\n        jURL.prototype = {\n          toString: function toString() {\n            return this.href;\n          },\n          get href() {\n            if (this._isInvalid) return this._url;\n            var authority = '';\n            if ('' != this._username || null != this._password) {\n              authority = this._username + (null != this._password ? ':' + this._password : '') + '@';\n            }\n            return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;\n          },\n          set href(href) {\n            clear.call(this);\n            parse.call(this, href);\n          },\n          get protocol() {\n            return this._scheme + ':';\n          },\n          set protocol(protocol) {\n            if (this._isInvalid) return;\n            parse.call(this, protocol + ':', 'scheme start');\n          },\n          get host() {\n            return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;\n          },\n          set host(host) {\n            if (this._isInvalid || !this._isRelative) return;\n            parse.call(this, host, 'host');\n          },\n          get hostname() {\n            return this._host;\n          },\n          set hostname(hostname) {\n            if (this._isInvalid || !this._isRelative) return;\n            parse.call(this, hostname, 'hostname');\n          },\n          get port() {\n            return this._port;\n          },\n          set port(port) {\n            if (this._isInvalid || !this._isRelative) return;\n            parse.call(this, port, 'port');\n          },\n          get pathname() {\n            return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;\n          },\n          set pathname(pathname) {\n            if (this._isInvalid || !this._isRelative) return;\n            this._path = [];\n            parse.call(this, pathname, 'relative path start');\n          },\n          get search() {\n            return this._isInvalid || !this._query || '?' == this._query ? '' : this._query;\n          },\n          set search(search) {\n            if (this._isInvalid || !this._isRelative) return;\n            this._query = '?';\n            if ('?' == search[0]) search = search.slice(1);\n            parse.call(this, search, 'query');\n          },\n          get hash() {\n            return this._isInvalid || !this._fragment || '#' == this._fragment ? '' : this._fragment;\n          },\n          set hash(hash) {\n            if (this._isInvalid) return;\n            this._fragment = '#';\n            if ('#' == hash[0]) hash = hash.slice(1);\n            parse.call(this, hash, 'fragment');\n          },\n          get origin() {\n            var host;\n            if (this._isInvalid || !this._scheme) {\n              return '';\n            }\n            // javascript: Gecko returns String(\"\"), WebKit/Blink String(\"null\")\n            // Gecko throws error for \"data://\"\n            // data: Gecko returns \"\", Blink returns \"data://\", WebKit returns \"null\"\n            // Gecko returns String(\"\") for file: mailto:\n            // WebKit/Blink returns String(\"SCHEME://\") for file: mailto:\n            switch (this._scheme) {\n              case 'data':\n              case 'file':\n              case 'javascript':\n              case 'mailto':\n                return 'null';\n            }\n            host = this.host;\n            if (!host) {\n              return '';\n            }\n            return this._scheme + '://' + host;\n          }\n        };\n\n        // Copy over the static methods\n        var OriginalURL = scope.URL;\n        if (OriginalURL) {\n          jURL.createObjectURL = function (blob) {\n            // IE extension allows a second optional options argument.\n            // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx\n            return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n          };\n          jURL.revokeObjectURL = function (url) {\n            OriginalURL.revokeObjectURL(url);\n          };\n        }\n        scope.URL = jURL;\n        /* jshint ignore:end */\n      })(globalScope);\n      exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n      exports.IDENTITY_MATRIX = IDENTITY_MATRIX;\n      exports.OPS = OPS;\n      exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;\n      exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\n      exports.AnnotationBorderStyleType = AnnotationBorderStyleType;\n      exports.AnnotationFlag = AnnotationFlag;\n      exports.AnnotationType = AnnotationType;\n      exports.FontType = FontType;\n      exports.ImageKind = ImageKind;\n      exports.InvalidPDFException = InvalidPDFException;\n      exports.MessageHandler = MessageHandler;\n      exports.MissingDataException = MissingDataException;\n      exports.MissingPDFException = MissingPDFException;\n      exports.NotImplementedException = NotImplementedException;\n      exports.PageViewport = PageViewport;\n      exports.PasswordException = PasswordException;\n      exports.PasswordResponses = PasswordResponses;\n      exports.StatTimer = StatTimer;\n      exports.StreamType = StreamType;\n      exports.TextRenderingMode = TextRenderingMode;\n      exports.UnexpectedResponseException = UnexpectedResponseException;\n      exports.UnknownErrorException = UnknownErrorException;\n      exports.Util = Util;\n      exports.XRefParseException = XRefParseException;\n      exports.arrayByteLength = arrayByteLength;\n      exports.arraysToBytes = arraysToBytes;\n      exports.assert = assert;\n      exports.bytesToString = bytesToString;\n      exports.createBlob = createBlob;\n      exports.createPromiseCapability = createPromiseCapability;\n      exports.createObjectURL = createObjectURL;\n      exports.deprecated = deprecated;\n      exports.error = error;\n      exports.getLookupTableFactory = getLookupTableFactory;\n      exports.getVerbosityLevel = getVerbosityLevel;\n      exports.globalScope = globalScope;\n      exports.info = info;\n      exports.isArray = isArray;\n      exports.isArrayBuffer = isArrayBuffer;\n      exports.isBool = isBool;\n      exports.isEmptyObj = isEmptyObj;\n      exports.isInt = isInt;\n      exports.isNum = isNum;\n      exports.isString = isString;\n      exports.isSameOrigin = isSameOrigin;\n      exports.isValidUrl = isValidUrl;\n      exports.isLittleEndian = isLittleEndian;\n      exports.isEvalSupported = isEvalSupported;\n      exports.loadJpegStream = loadJpegStream;\n      exports.log2 = log2;\n      exports.readInt8 = readInt8;\n      exports.readUint16 = readUint16;\n      exports.readUint32 = readUint32;\n      exports.removeNullCharacters = removeNullCharacters;\n      exports.setVerbosityLevel = setVerbosityLevel;\n      exports.shadow = shadow;\n      exports.string32 = string32;\n      exports.stringToBytes = stringToBytes;\n      exports.stringToPDFString = stringToPDFString;\n      exports.stringToUTF8String = stringToUTF8String;\n      exports.utf8StringToString = utf8StringToString;\n      exports.warn = warn;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayDOMUtils = {}, root.pdfjsSharedUtil);\n      }\n    })(this, function (exports, sharedUtil) {\n      var removeNullCharacters = sharedUtil.removeNullCharacters;\n      var warn = sharedUtil.warn;\n\n      /**\r\n       * Optimised CSS custom property getter/setter.\r\n       * @class\r\n       */\n      var CustomStyle = function CustomStyleClosure() {\n        // As noted on: http://www.zachstronaut.com/posts/2009/02/17/\n        //              animate-css-transforms-firefox-webkit.html\n        // in some versions of IE9 it is critical that ms appear in this list\n        // before Moz\n        var prefixes = ['ms', 'Moz', 'Webkit', 'O'];\n        var _cache = Object.create(null);\n        function CustomStyle() {}\n        CustomStyle.getProp = function get(propName, element) {\n          // check cache only when no element is given\n          if (arguments.length === 1 && typeof _cache[propName] === 'string') {\n            return _cache[propName];\n          }\n          element = element || document.documentElement;\n          var style = element.style,\n            prefixed,\n            uPropName;\n\n          // test standard property first\n          if (typeof style[propName] === 'string') {\n            return _cache[propName] = propName;\n          }\n\n          // capitalize\n          uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);\n\n          // test vendor specific properties\n          for (var i = 0, l = prefixes.length; i < l; i++) {\n            prefixed = prefixes[i] + uPropName;\n            if (typeof style[prefixed] === 'string') {\n              return _cache[propName] = prefixed;\n            }\n          }\n\n          //if all fails then set to undefined\n          return _cache[propName] = 'undefined';\n        };\n        CustomStyle.setProp = function set(propName, element, str) {\n          var prop = this.getProp(propName);\n          if (prop !== 'undefined') {\n            element.style[prop] = str;\n          }\n        };\n        return CustomStyle;\n      }();\n      function hasCanvasTypedArrays() {\n        var canvas = document.createElement('canvas');\n        canvas.width = canvas.height = 1;\n        var ctx = canvas.getContext('2d');\n        var imageData = ctx.createImageData(1, 1);\n        return typeof imageData.data.buffer !== 'undefined';\n      }\n      var LinkTarget = {\n        NONE: 0,\n        // Default value.\n        SELF: 1,\n        BLANK: 2,\n        PARENT: 3,\n        TOP: 4\n      };\n      var LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];\n\n      /**\r\n       * @typedef ExternalLinkParameters\r\n       * @typedef {Object} ExternalLinkParameters\r\n       * @property {string} url - An absolute URL.\r\n       * @property {LinkTarget} target - The link target.\r\n       * @property {string} rel - The link relationship.\r\n       */\n\n      /**\r\n       * Adds various attributes (href, title, target, rel) to hyperlinks.\r\n       * @param {HTMLLinkElement} link - The link element.\r\n       * @param {ExternalLinkParameters} params\r\n       */\n      function addLinkAttributes(link, params) {\n        var url = params && params.url;\n        link.href = link.title = url ? removeNullCharacters(url) : '';\n        if (url) {\n          var target = params.target;\n          if (typeof target === 'undefined') {\n            target = getDefaultSetting('externalLinkTarget');\n          }\n          link.target = LinkTargetStringMap[target];\n          var rel = params.rel;\n          if (typeof rel === 'undefined') {\n            rel = getDefaultSetting('externalLinkRel');\n          }\n          link.rel = rel;\n        }\n      }\n\n      // Gets the file name from a given URL.\n      function getFilenameFromUrl(url) {\n        var anchor = url.indexOf('#');\n        var query = url.indexOf('?');\n        var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n        return url.substring(url.lastIndexOf('/', end) + 1, end);\n      }\n      function getDefaultSetting(id) {\n        // The list of the settings and their default is maintained for backward\n        // compatibility and shall not be extended or modified. See also global.js.\n        var globalSettings = sharedUtil.globalScope.PDFJS;\n        switch (id) {\n          case 'pdfBug':\n            return globalSettings ? globalSettings.pdfBug : false;\n          case 'disableAutoFetch':\n            return globalSettings ? globalSettings.disableAutoFetch : false;\n          case 'disableStream':\n            return globalSettings ? globalSettings.disableStream : false;\n          case 'disableRange':\n            return globalSettings ? globalSettings.disableRange : false;\n          case 'disableFontFace':\n            return globalSettings ? globalSettings.disableFontFace : false;\n          case 'disableCreateObjectURL':\n            return globalSettings ? globalSettings.disableCreateObjectURL : false;\n          case 'disableWebGL':\n            return globalSettings ? globalSettings.disableWebGL : true;\n          case 'cMapUrl':\n            return globalSettings ? globalSettings.cMapUrl : null;\n          case 'cMapPacked':\n            return globalSettings ? globalSettings.cMapPacked : false;\n          case 'postMessageTransfers':\n            return globalSettings ? globalSettings.postMessageTransfers : true;\n          case 'workerSrc':\n            return globalSettings ? globalSettings.workerSrc : null;\n          case 'disableWorker':\n            return globalSettings ? globalSettings.disableWorker : false;\n          case 'maxImageSize':\n            return globalSettings ? globalSettings.maxImageSize : -1;\n          case 'imageResourcesPath':\n            return globalSettings ? globalSettings.imageResourcesPath : '';\n          case 'isEvalSupported':\n            return globalSettings ? globalSettings.isEvalSupported : true;\n          case 'externalLinkTarget':\n            if (!globalSettings) {\n              return LinkTarget.NONE;\n            }\n            switch (globalSettings.externalLinkTarget) {\n              case LinkTarget.NONE:\n              case LinkTarget.SELF:\n              case LinkTarget.BLANK:\n              case LinkTarget.PARENT:\n              case LinkTarget.TOP:\n                return globalSettings.externalLinkTarget;\n            }\n            warn('PDFJS.externalLinkTarget is invalid: ' + globalSettings.externalLinkTarget);\n            // Reset the external link target, to suppress further warnings.\n            globalSettings.externalLinkTarget = LinkTarget.NONE;\n            return LinkTarget.NONE;\n          case 'externalLinkRel':\n            return globalSettings ? globalSettings.externalLinkRel : 'noreferrer';\n          case 'enableStats':\n            return !!(globalSettings && globalSettings.enableStats);\n          default:\n            throw new Error('Unknown default setting: ' + id);\n        }\n      }\n      function isExternalLinkTargetSet() {\n        var externalLinkTarget = getDefaultSetting('externalLinkTarget');\n        switch (externalLinkTarget) {\n          case LinkTarget.NONE:\n            return false;\n          case LinkTarget.SELF:\n          case LinkTarget.BLANK:\n          case LinkTarget.PARENT:\n          case LinkTarget.TOP:\n            return true;\n        }\n      }\n      exports.CustomStyle = CustomStyle;\n      exports.addLinkAttributes = addLinkAttributes;\n      exports.isExternalLinkTargetSet = isExternalLinkTargetSet;\n      exports.getFilenameFromUrl = getFilenameFromUrl;\n      exports.LinkTarget = LinkTarget;\n      exports.hasCanvasTypedArrays = hasCanvasTypedArrays;\n      exports.getDefaultSetting = getDefaultSetting;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayFontLoader = {}, root.pdfjsSharedUtil);\n      }\n    })(this, function (exports, sharedUtil) {\n      var assert = sharedUtil.assert;\n      var bytesToString = sharedUtil.bytesToString;\n      var string32 = sharedUtil.string32;\n      var shadow = sharedUtil.shadow;\n      var warn = sharedUtil.warn;\n      function FontLoader(docId) {\n        this.docId = docId;\n        this.styleElement = null;\n        this.nativeFontFaces = [];\n        this.loadTestFontId = 0;\n        this.loadingContext = {\n          requests: [],\n          nextRequestId: 0\n        };\n      }\n      FontLoader.prototype = {\n        insertRule: function fontLoaderInsertRule(rule) {\n          var styleElement = this.styleElement;\n          if (!styleElement) {\n            styleElement = this.styleElement = document.createElement('style');\n            styleElement.id = 'PDFJS_FONT_STYLE_TAG_' + this.docId;\n            document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);\n          }\n          var styleSheet = styleElement.sheet;\n          styleSheet.insertRule(rule, styleSheet.cssRules.length);\n        },\n        clear: function fontLoaderClear() {\n          var styleElement = this.styleElement;\n          if (styleElement) {\n            styleElement.parentNode.removeChild(styleElement);\n            styleElement = this.styleElement = null;\n          }\n          this.nativeFontFaces.forEach(function (nativeFontFace) {\n            document.fonts.delete(nativeFontFace);\n          });\n          this.nativeFontFaces.length = 0;\n        },\n        get loadTestFont() {\n          // This is a CFF font with 1 glyph for '.' that fills its entire width and\n          // height.\n          return shadow(this, 'loadTestFont', atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' + 'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' + 'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' + 'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' + 'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' + 'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' + 'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' + 'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' + 'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' + 'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' + 'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' + 'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' + 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' + 'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' + 'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' + 'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' + 'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' + 'ABAAAAAAAAAAAD6AAAAAAAAA=='));\n        },\n        addNativeFontFace: function fontLoader_addNativeFontFace(nativeFontFace) {\n          this.nativeFontFaces.push(nativeFontFace);\n          document.fonts.add(nativeFontFace);\n        },\n        bind: function fontLoaderBind(fonts, callback) {\n          var rules = [];\n          var fontsToLoad = [];\n          var fontLoadPromises = [];\n          var getNativeFontPromise = function getNativeFontPromise(nativeFontFace) {\n            // Return a promise that is always fulfilled, even when the font fails to\n            // load.\n            return nativeFontFace.loaded.catch(function (e) {\n              warn('Failed to load font \"' + nativeFontFace.family + '\": ' + e);\n            });\n          };\n          for (var i = 0, ii = fonts.length; i < ii; i++) {\n            var font = fonts[i];\n\n            // Add the font to the DOM only once or skip if the font\n            // is already loaded.\n            if (font.attached || font.loading === false) {\n              continue;\n            }\n            font.attached = true;\n            if (FontLoader.isFontLoadingAPISupported) {\n              var nativeFontFace = font.createNativeFontFace();\n              if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                fontLoadPromises.push(getNativeFontPromise(nativeFontFace));\n              }\n            } else {\n              var rule = font.createFontFaceRule();\n              if (rule) {\n                this.insertRule(rule);\n                rules.push(rule);\n                fontsToLoad.push(font);\n              }\n            }\n          }\n          var request = this.queueLoadingCallback(callback);\n          if (FontLoader.isFontLoadingAPISupported) {\n            Promise.all(fontLoadPromises).then(function () {\n              request.complete();\n            });\n          } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {\n            this.prepareFontLoadEvent(rules, fontsToLoad, request);\n          } else {\n            request.complete();\n          }\n        },\n        queueLoadingCallback: function FontLoader_queueLoadingCallback(callback) {\n          function LoadLoader_completeRequest() {\n            assert(!request.end, 'completeRequest() cannot be called twice');\n            request.end = Date.now();\n\n            // sending all completed requests in order how they were queued\n            while (context.requests.length > 0 && context.requests[0].end) {\n              var otherRequest = context.requests.shift();\n              setTimeout(otherRequest.callback, 0);\n            }\n          }\n          var context = this.loadingContext;\n          var requestId = 'pdfjs-font-loading-' + context.nextRequestId++;\n          var request = {\n            id: requestId,\n            complete: LoadLoader_completeRequest,\n            callback: callback,\n            started: Date.now()\n          };\n          context.requests.push(request);\n          return request;\n        },\n        prepareFontLoadEvent: function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {\n          /** Hack begin */\n          // There's currently no event when a font has finished downloading so the\n          // following code is a dirty hack to 'guess' when a font is\n          // ready. It's assumed fonts are loaded in order, so add a known test\n          // font after the desired fonts and then test for the loading of that\n          // test font.\n\n          function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n          }\n          function spliceString(s, offset, remove, insert) {\n            var chunk1 = s.substr(0, offset);\n            var chunk2 = s.substr(offset + remove);\n            return chunk1 + insert + chunk2;\n          }\n          var i, ii;\n          var canvas = document.createElement('canvas');\n          canvas.width = 1;\n          canvas.height = 1;\n          var ctx = canvas.getContext('2d');\n          var called = 0;\n          function isFontReady(name, callback) {\n            called++;\n            // With setTimeout clamping this gives the font ~100ms to load.\n            if (called > 30) {\n              warn('Load test font never loaded.');\n              callback();\n              return;\n            }\n            ctx.font = '30px ' + name;\n            ctx.fillText('.', 0, 20);\n            var imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n              callback();\n              return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n          }\n          var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;\n          // Chromium seems to cache fonts based on a hash of the actual font data,\n          // so the font must be modified for each load test else it will appear to\n          // be loaded already.\n          // TODO: This could maybe be made faster by avoiding the btoa of the full\n          // font by splitting it in chunks before hand and padding the font id.\n          var data = this.loadTestFont;\n          var COMMENT_OFFSET = 976; // has to be on 4 byte boundary (for checksum)\n          data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n          // CFF checksum is important for IE, adjusting it\n          var CFF_CHECKSUM_OFFSET = 16;\n          var XXXX_VALUE = 0x58585858; // the \"comment\" filled with 'X'\n          var checksum = int32(data, CFF_CHECKSUM_OFFSET);\n          for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n          }\n          if (i < loadTestFontId.length) {\n            // align to 4 bytes boundary\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + 'XXX', i) | 0;\n          }\n          data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n          var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';\n          var rule = '@font-face { font-family:\"' + loadTestFontId + '\";src:' + url + '}';\n          this.insertRule(rule);\n          var names = [];\n          for (i = 0, ii = fonts.length; i < ii; i++) {\n            names.push(fonts[i].loadedName);\n          }\n          names.push(loadTestFontId);\n          var div = document.createElement('div');\n          div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');\n          for (i = 0, ii = names.length; i < ii; ++i) {\n            var span = document.createElement('span');\n            span.textContent = 'Hi';\n            span.style.fontFamily = names[i];\n            div.appendChild(span);\n          }\n          document.body.appendChild(div);\n          isFontReady(loadTestFontId, function () {\n            document.body.removeChild(div);\n            request.complete();\n          });\n          /** Hack end */\n        }\n      };\n      FontLoader.isFontLoadingAPISupported = typeof document !== 'undefined' && !!document.fonts;\n      Object.defineProperty(FontLoader, 'isSyncFontLoadingSupported', {\n        get: function get() {\n          if (typeof navigator === 'undefined') {\n            // node.js - we can pretend sync font loading is supported.\n            return shadow(FontLoader, 'isSyncFontLoadingSupported', true);\n          }\n          var supported = false;\n\n          // User agent string sniffing is bad, but there is no reliable way to tell\n          // if font is fully loaded and ready to be used with canvas.\n          var m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n          if (m && m[1] >= 14) {\n            supported = true;\n          }\n          // TODO other browsers\n          return shadow(FontLoader, 'isSyncFontLoadingSupported', supported);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      var IsEvalSupportedCached = {\n        get value() {\n          return shadow(this, 'value', sharedUtil.isEvalSupported());\n        }\n      };\n      var FontFaceObject = function FontFaceObjectClosure() {\n        function FontFaceObject(translatedData, options) {\n          this.compiledGlyphs = Object.create(null);\n          // importing translated data\n          for (var i in translatedData) {\n            this[i] = translatedData[i];\n          }\n          this.options = options;\n        }\n        FontFaceObject.prototype = {\n          createNativeFontFace: function FontFaceObject_createNativeFontFace() {\n            if (!this.data) {\n              return null;\n            }\n            if (this.options.disableFontFace) {\n              this.disableFontFace = true;\n              return null;\n            }\n            var nativeFontFace = new FontFace(this.loadedName, this.data, {});\n            if (this.options.fontRegistry) {\n              this.options.fontRegistry.registerFont(this);\n            }\n            return nativeFontFace;\n          },\n          createFontFaceRule: function FontFaceObject_createFontFaceRule() {\n            if (!this.data) {\n              return null;\n            }\n            if (this.options.disableFontFace) {\n              this.disableFontFace = true;\n              return null;\n            }\n            var data = bytesToString(new Uint8Array(this.data));\n            var fontName = this.loadedName;\n\n            // Add the font-face rule to the document\n            var url = 'url(data:' + this.mimetype + ';base64,' + btoa(data) + ');';\n            var rule = '@font-face { font-family:\"' + fontName + '\";src:' + url + '}';\n            if (this.options.fontRegistry) {\n              this.options.fontRegistry.registerFont(this, url);\n            }\n            return rule;\n          },\n          getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {\n            if (!(character in this.compiledGlyphs)) {\n              var cmds = objs.get(this.loadedName + '_path_' + character);\n              var current, i, len;\n\n              // If we can, compile cmds into JS for MAXIMUM SPEED\n              if (this.options.isEvalSupported && IsEvalSupportedCached.value) {\n                var args,\n                  js = '';\n                for (i = 0, len = cmds.length; i < len; i++) {\n                  current = cmds[i];\n                  if (current.args !== undefined) {\n                    args = current.args.join(',');\n                  } else {\n                    args = '';\n                  }\n                  js += 'c.' + current.cmd + '(' + args + ');\\n';\n                }\n                /* jshint -W054 */\n                this.compiledGlyphs[character] = new Function('c', 'size', js);\n              } else {\n                // But fall back on using Function.prototype.apply() if we're\n                // blocked from using eval() for whatever reason (like CSP policies)\n                this.compiledGlyphs[character] = function (c, size) {\n                  for (i = 0, len = cmds.length; i < len; i++) {\n                    current = cmds[i];\n                    if (current.cmd === 'scale') {\n                      current.args = [size, -size];\n                    }\n                    c[current.cmd].apply(c, current.args);\n                  }\n                };\n              }\n            }\n            return this.compiledGlyphs[character];\n          }\n        };\n        return FontFaceObject;\n      }();\n      exports.FontFaceObject = FontFaceObject;\n      exports.FontLoader = FontLoader;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayMetadata = {}, root.pdfjsSharedUtil);\n      }\n    })(this, function (exports, sharedUtil) {\n      var error = sharedUtil.error;\n      function fixMetadata(meta) {\n        return meta.replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n          var bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n            return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n          });\n          var chars = '';\n          for (var i = 0; i < bytes.length; i += 2) {\n            var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n            chars += code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38 && false ? String.fromCharCode(code) : '&#x' + (0x10000 + code).toString(16).substring(1) + ';';\n          }\n          return '>' + chars;\n        });\n      }\n      function Metadata(meta) {\n        if (typeof meta === 'string') {\n          // Ghostscript produces invalid metadata\n          meta = fixMetadata(meta);\n          var parser = new DOMParser();\n          meta = parser.parseFromString(meta, 'application/xml');\n        } else if (!(meta instanceof Document)) {\n          error('Metadata: Invalid metadata object');\n        }\n        this.metaDocument = meta;\n        this.metadata = Object.create(null);\n        this.parse();\n      }\n      Metadata.prototype = {\n        parse: function Metadata_parse() {\n          var doc = this.metaDocument;\n          var rdf = doc.documentElement;\n          if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {\n            // Wrapped in <xmpmeta>\n            rdf = rdf.firstChild;\n            while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {\n              rdf = rdf.nextSibling;\n            }\n          }\n          var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;\n          if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {\n            return;\n          }\n          var children = rdf.childNodes,\n            desc,\n            entry,\n            name,\n            i,\n            ii,\n            length,\n            iLength;\n          for (i = 0, length = children.length; i < length; i++) {\n            desc = children[i];\n            if (desc.nodeName.toLowerCase() !== 'rdf:description') {\n              continue;\n            }\n            for (ii = 0, iLength = desc.childNodes.length; ii < iLength; ii++) {\n              if (desc.childNodes[ii].nodeName.toLowerCase() !== '#text') {\n                entry = desc.childNodes[ii];\n                name = entry.nodeName.toLowerCase();\n                this.metadata[name] = entry.textContent.trim();\n              }\n            }\n          }\n        },\n        get: function Metadata_get(name) {\n          return this.metadata[name] || null;\n        },\n        has: function Metadata_has(name) {\n          return typeof this.metadata[name] !== 'undefined';\n        }\n      };\n      exports.Metadata = Metadata;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplaySVG = {}, root.pdfjsSharedUtil);\n      }\n    })(this, function (exports, sharedUtil) {\n      var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;\n      var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;\n      var ImageKind = sharedUtil.ImageKind;\n      var OPS = sharedUtil.OPS;\n      var Util = sharedUtil.Util;\n      var isNum = sharedUtil.isNum;\n      var isArray = sharedUtil.isArray;\n      var warn = sharedUtil.warn;\n      var createObjectURL = sharedUtil.createObjectURL;\n      var SVG_DEFAULTS = {\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n        fillColor: '#000000'\n      };\n      var convertImgDataToPng = function convertImgDataToPngClosure() {\n        var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n        var CHUNK_WRAPPER_SIZE = 12;\n        var crcTable = new Int32Array(256);\n        for (var i = 0; i < 256; i++) {\n          var c = i;\n          for (var h = 0; h < 8; h++) {\n            if (c & 1) {\n              c = 0xedB88320 ^ c >> 1 & 0x7fffffff;\n            } else {\n              c = c >> 1 & 0x7fffffff;\n            }\n          }\n          crcTable[i] = c;\n        }\n        function crc32(data, start, end) {\n          var crc = -1;\n          for (var i = start; i < end; i++) {\n            var a = (crc ^ data[i]) & 0xff;\n            var b = crcTable[a];\n            crc = crc >>> 8 ^ b;\n          }\n          return crc ^ -1;\n        }\n        function writePngChunk(type, body, data, offset) {\n          var p = offset;\n          var len = body.length;\n          data[p] = len >> 24 & 0xff;\n          data[p + 1] = len >> 16 & 0xff;\n          data[p + 2] = len >> 8 & 0xff;\n          data[p + 3] = len & 0xff;\n          p += 4;\n          data[p] = type.charCodeAt(0) & 0xff;\n          data[p + 1] = type.charCodeAt(1) & 0xff;\n          data[p + 2] = type.charCodeAt(2) & 0xff;\n          data[p + 3] = type.charCodeAt(3) & 0xff;\n          p += 4;\n          data.set(body, p);\n          p += body.length;\n          var crc = crc32(data, offset + 4, p);\n          data[p] = crc >> 24 & 0xff;\n          data[p + 1] = crc >> 16 & 0xff;\n          data[p + 2] = crc >> 8 & 0xff;\n          data[p + 3] = crc & 0xff;\n        }\n        function adler32(data, start, end) {\n          var a = 1;\n          var b = 0;\n          for (var i = start; i < end; ++i) {\n            a = (a + (data[i] & 0xff)) % 65521;\n            b = (b + a) % 65521;\n          }\n          return b << 16 | a;\n        }\n        function encode(imgData, kind, forceDataSchema) {\n          var width = imgData.width;\n          var height = imgData.height;\n          var bitDepth, colorType, lineSize;\n          var bytes = imgData.data;\n          switch (kind) {\n            case ImageKind.GRAYSCALE_1BPP:\n              colorType = 0;\n              bitDepth = 1;\n              lineSize = width + 7 >> 3;\n              break;\n            case ImageKind.RGB_24BPP:\n              colorType = 2;\n              bitDepth = 8;\n              lineSize = width * 3;\n              break;\n            case ImageKind.RGBA_32BPP:\n              colorType = 6;\n              bitDepth = 8;\n              lineSize = width * 4;\n              break;\n            default:\n              throw new Error('invalid format');\n          }\n\n          // prefix every row with predictor 0\n          var literals = new Uint8Array((1 + lineSize) * height);\n          var offsetLiterals = 0,\n            offsetBytes = 0;\n          var y, i;\n          for (y = 0; y < height; ++y) {\n            literals[offsetLiterals++] = 0; // no prediction\n            literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n            offsetBytes += lineSize;\n            offsetLiterals += lineSize;\n          }\n          if (kind === ImageKind.GRAYSCALE_1BPP) {\n            // inverting for B/W\n            offsetLiterals = 0;\n            for (y = 0; y < height; y++) {\n              offsetLiterals++; // skipping predictor\n              for (i = 0; i < lineSize; i++) {\n                literals[offsetLiterals++] ^= 0xFF;\n              }\n            }\n          }\n          var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth,\n          // bit depth\n          colorType,\n          // color type\n          0x00,\n          // compression method\n          0x00,\n          // filter method\n          0x00 // interlace method\n          ]);\n          var len = literals.length;\n          var maxBlockLength = 0xFFFF;\n          var deflateBlocks = Math.ceil(len / maxBlockLength);\n          var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n          var pi = 0;\n          idat[pi++] = 0x78; // compression method and flags\n          idat[pi++] = 0x9c; // flags\n\n          var pos = 0;\n          while (len > maxBlockLength) {\n            // writing non-final DEFLATE blocks type 0 and length of 65535\n            idat[pi++] = 0x00;\n            idat[pi++] = 0xff;\n            idat[pi++] = 0xff;\n            idat[pi++] = 0x00;\n            idat[pi++] = 0x00;\n            idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n            pi += maxBlockLength;\n            pos += maxBlockLength;\n            len -= maxBlockLength;\n          }\n\n          // writing non-final DEFLATE blocks type 0\n          idat[pi++] = 0x01;\n          idat[pi++] = len & 0xff;\n          idat[pi++] = len >> 8 & 0xff;\n          idat[pi++] = ~len & 0xffff & 0xff;\n          idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n          idat.set(literals.subarray(pos), pi);\n          pi += literals.length - pos;\n          var adler = adler32(literals, 0, literals.length); // checksum\n          idat[pi++] = adler >> 24 & 0xff;\n          idat[pi++] = adler >> 16 & 0xff;\n          idat[pi++] = adler >> 8 & 0xff;\n          idat[pi++] = adler & 0xff;\n\n          // PNG will consists: header, IHDR+data, IDAT+data, and IEND.\n          var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n          var data = new Uint8Array(pngLength);\n          var offset = 0;\n          data.set(PNG_HEADER, offset);\n          offset += PNG_HEADER.length;\n          writePngChunk('IHDR', ihdr, data, offset);\n          offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n          writePngChunk('IDATA', idat, data, offset);\n          offset += CHUNK_WRAPPER_SIZE + idat.length;\n          writePngChunk('IEND', new Uint8Array(0), data, offset);\n          return createObjectURL(data, 'image/png', forceDataSchema);\n        }\n        return function convertImgDataToPng(imgData, forceDataSchema) {\n          var kind = imgData.kind === undefined ? ImageKind.GRAYSCALE_1BPP : imgData.kind;\n          return encode(imgData, kind, forceDataSchema);\n        };\n      }();\n      var SVGExtraState = function SVGExtraStateClosure() {\n        function SVGExtraState() {\n          this.fontSizeScale = 1;\n          this.fontWeight = SVG_DEFAULTS.fontWeight;\n          this.fontSize = 0;\n          this.textMatrix = IDENTITY_MATRIX;\n          this.fontMatrix = FONT_IDENTITY_MATRIX;\n          this.leading = 0;\n\n          // Current point (in user coordinates)\n          this.x = 0;\n          this.y = 0;\n\n          // Start of text line (in text coordinates)\n          this.lineX = 0;\n          this.lineY = 0;\n\n          // Character and word spacing\n          this.charSpacing = 0;\n          this.wordSpacing = 0;\n          this.textHScale = 1;\n          this.textRise = 0;\n\n          // Default foreground and background colors\n          this.fillColor = SVG_DEFAULTS.fillColor;\n          this.strokeColor = '#000000';\n          this.fillAlpha = 1;\n          this.strokeAlpha = 1;\n          this.lineWidth = 1;\n          this.lineJoin = '';\n          this.lineCap = '';\n          this.miterLimit = 0;\n          this.dashArray = [];\n          this.dashPhase = 0;\n          this.dependencies = [];\n\n          // Clipping\n          this.clipId = '';\n          this.pendingClip = false;\n          this.maskId = '';\n        }\n        SVGExtraState.prototype = {\n          clone: function SVGExtraState_clone() {\n            return Object.create(this);\n          },\n          setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {\n            this.x = x;\n            this.y = y;\n          }\n        };\n        return SVGExtraState;\n      }();\n      var SVGGraphics = function SVGGraphicsClosure() {\n        function createScratchSVG(width, height) {\n          var NS = 'http://www.w3.org/2000/svg';\n          var svg = document.createElementNS(NS, 'svg:svg');\n          svg.setAttributeNS(null, 'version', '1.1');\n          svg.setAttributeNS(null, 'width', width + 'px');\n          svg.setAttributeNS(null, 'height', height + 'px');\n          svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);\n          return svg;\n        }\n        function opListToTree(opList) {\n          var opTree = [];\n          var tmp = [];\n          var opListLen = opList.length;\n          for (var x = 0; x < opListLen; x++) {\n            if (opList[x].fn === 'save') {\n              opTree.push({\n                'fnId': 92,\n                'fn': 'group',\n                'items': []\n              });\n              tmp.push(opTree);\n              opTree = opTree[opTree.length - 1].items;\n              continue;\n            }\n            if (opList[x].fn === 'restore') {\n              opTree = tmp.pop();\n            } else {\n              opTree.push(opList[x]);\n            }\n          }\n          return opTree;\n        }\n\n        /**\r\n         * Formats float number.\r\n         * @param value {number} number to format.\r\n         * @returns {string}\r\n         */\n        function pf(value) {\n          if (value === (value | 0)) {\n            // integer number\n            return value.toString();\n          }\n          var s = value.toFixed(10);\n          var i = s.length - 1;\n          if (s[i] !== '0') {\n            return s;\n          }\n          // removing trailing zeros\n          do {\n            i--;\n          } while (s[i] === '0');\n          return s.substr(0, s[i] === '.' ? i : i + 1);\n        }\n\n        /**\r\n         * Formats transform matrix. The standard rotation, scale and translate\r\n         * matrices are replaced by their shorter forms, and for identity matrix\r\n         * returns empty string to save the memory.\r\n         * @param m {Array} matrix to format.\r\n         * @returns {string}\r\n         */\n        function pm(m) {\n          if (m[4] === 0 && m[5] === 0) {\n            if (m[1] === 0 && m[2] === 0) {\n              if (m[0] === 1 && m[3] === 1) {\n                return '';\n              }\n              return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';\n            }\n            if (m[0] === m[3] && m[1] === -m[2]) {\n              var a = Math.acos(m[0]) * 180 / Math.PI;\n              return 'rotate(' + pf(a) + ')';\n            }\n          } else {\n            if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n              return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';\n            }\n          }\n          return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' + pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';\n        }\n        function SVGGraphics(commonObjs, objs, forceDataSchema) {\n          this.current = new SVGExtraState();\n          this.transformMatrix = IDENTITY_MATRIX; // Graphics state matrix\n          this.transformStack = [];\n          this.extraStack = [];\n          this.commonObjs = commonObjs;\n          this.objs = objs;\n          this.pendingEOFill = false;\n          this.embedFonts = false;\n          this.embeddedFonts = Object.create(null);\n          this.cssStyle = null;\n          this.forceDataSchema = !!forceDataSchema;\n        }\n        var NS = 'http://www.w3.org/2000/svg';\n        var XML_NS = 'http://www.w3.org/XML/1998/namespace';\n        var XLINK_NS = 'http://www.w3.org/1999/xlink';\n        var LINE_CAP_STYLES = ['butt', 'round', 'square'];\n        var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\n        var clipCount = 0;\n        var maskCount = 0;\n        SVGGraphics.prototype = {\n          save: function SVGGraphics_save() {\n            this.transformStack.push(this.transformMatrix);\n            var old = this.current;\n            this.extraStack.push(old);\n            this.current = old.clone();\n          },\n          restore: function SVGGraphics_restore() {\n            this.transformMatrix = this.transformStack.pop();\n            this.current = this.extraStack.pop();\n            this.tgrp = document.createElementNS(NS, 'svg:g');\n            this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n            this.pgrp.appendChild(this.tgrp);\n          },\n          group: function SVGGraphics_group(items) {\n            this.save();\n            this.executeOpTree(items);\n            this.restore();\n          },\n          loadDependencies: function SVGGraphics_loadDependencies(operatorList) {\n            var fnArray = operatorList.fnArray;\n            var fnArrayLen = fnArray.length;\n            var argsArray = operatorList.argsArray;\n            var self = this;\n            for (var i = 0; i < fnArrayLen; i++) {\n              if (OPS.dependency === fnArray[i]) {\n                var deps = argsArray[i];\n                for (var n = 0, nn = deps.length; n < nn; n++) {\n                  var obj = deps[n];\n                  var common = obj.substring(0, 2) === 'g_';\n                  var promise;\n                  if (common) {\n                    promise = new Promise(function (resolve) {\n                      self.commonObjs.get(obj, resolve);\n                    });\n                  } else {\n                    promise = new Promise(function (resolve) {\n                      self.objs.get(obj, resolve);\n                    });\n                  }\n                  this.current.dependencies.push(promise);\n                }\n              }\n            }\n            return Promise.all(this.current.dependencies);\n          },\n          transform: function SVGGraphics_transform(a, b, c, d, e, f) {\n            var transformMatrix = [a, b, c, d, e, f];\n            this.transformMatrix = Util.transform(this.transformMatrix, transformMatrix);\n            this.tgrp = document.createElementNS(NS, 'svg:g');\n            this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n          },\n          getSVG: function SVGGraphics_getSVG(operatorList, viewport) {\n            this.svg = createScratchSVG(viewport.width, viewport.height);\n            this.viewport = viewport;\n            return this.loadDependencies(operatorList).then(function () {\n              this.transformMatrix = IDENTITY_MATRIX;\n              this.pgrp = document.createElementNS(NS, 'svg:g'); // Parent group\n              this.pgrp.setAttributeNS(null, 'transform', pm(viewport.transform));\n              this.tgrp = document.createElementNS(NS, 'svg:g'); // Transform group\n              this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n              this.defs = document.createElementNS(NS, 'svg:defs');\n              this.pgrp.appendChild(this.defs);\n              this.pgrp.appendChild(this.tgrp);\n              this.svg.appendChild(this.pgrp);\n              var opTree = this.convertOpList(operatorList);\n              this.executeOpTree(opTree);\n              return this.svg;\n            }.bind(this));\n          },\n          convertOpList: function SVGGraphics_convertOpList(operatorList) {\n            var argsArray = operatorList.argsArray;\n            var fnArray = operatorList.fnArray;\n            var fnArrayLen = fnArray.length;\n            var REVOPS = [];\n            var opList = [];\n            for (var op in OPS) {\n              REVOPS[OPS[op]] = op;\n            }\n            for (var x = 0; x < fnArrayLen; x++) {\n              var fnId = fnArray[x];\n              opList.push({\n                'fnId': fnId,\n                'fn': REVOPS[fnId],\n                'args': argsArray[x]\n              });\n            }\n            return opListToTree(opList);\n          },\n          executeOpTree: function SVGGraphics_executeOpTree(opTree) {\n            var opTreeLen = opTree.length;\n            for (var x = 0; x < opTreeLen; x++) {\n              var fn = opTree[x].fn;\n              var fnId = opTree[x].fnId;\n              var args = opTree[x].args;\n              switch (fnId | 0) {\n                case OPS.beginText:\n                  this.beginText();\n                  break;\n                case OPS.setLeading:\n                  this.setLeading(args);\n                  break;\n                case OPS.setLeadingMoveText:\n                  this.setLeadingMoveText(args[0], args[1]);\n                  break;\n                case OPS.setFont:\n                  this.setFont(args);\n                  break;\n                case OPS.showText:\n                  this.showText(args[0]);\n                  break;\n                case OPS.showSpacedText:\n                  this.showText(args[0]);\n                  break;\n                case OPS.endText:\n                  this.endText();\n                  break;\n                case OPS.moveText:\n                  this.moveText(args[0], args[1]);\n                  break;\n                case OPS.setCharSpacing:\n                  this.setCharSpacing(args[0]);\n                  break;\n                case OPS.setWordSpacing:\n                  this.setWordSpacing(args[0]);\n                  break;\n                case OPS.setHScale:\n                  this.setHScale(args[0]);\n                  break;\n                case OPS.setTextMatrix:\n                  this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                  break;\n                case OPS.setLineWidth:\n                  this.setLineWidth(args[0]);\n                  break;\n                case OPS.setLineJoin:\n                  this.setLineJoin(args[0]);\n                  break;\n                case OPS.setLineCap:\n                  this.setLineCap(args[0]);\n                  break;\n                case OPS.setMiterLimit:\n                  this.setMiterLimit(args[0]);\n                  break;\n                case OPS.setFillRGBColor:\n                  this.setFillRGBColor(args[0], args[1], args[2]);\n                  break;\n                case OPS.setStrokeRGBColor:\n                  this.setStrokeRGBColor(args[0], args[1], args[2]);\n                  break;\n                case OPS.setDash:\n                  this.setDash(args[0], args[1]);\n                  break;\n                case OPS.setGState:\n                  this.setGState(args[0]);\n                  break;\n                case OPS.fill:\n                  this.fill();\n                  break;\n                case OPS.eoFill:\n                  this.eoFill();\n                  break;\n                case OPS.stroke:\n                  this.stroke();\n                  break;\n                case OPS.fillStroke:\n                  this.fillStroke();\n                  break;\n                case OPS.eoFillStroke:\n                  this.eoFillStroke();\n                  break;\n                case OPS.clip:\n                  this.clip('nonzero');\n                  break;\n                case OPS.eoClip:\n                  this.clip('evenodd');\n                  break;\n                case OPS.paintSolidColorImageMask:\n                  this.paintSolidColorImageMask();\n                  break;\n                case OPS.paintJpegXObject:\n                  this.paintJpegXObject(args[0], args[1], args[2]);\n                  break;\n                case OPS.paintImageXObject:\n                  this.paintImageXObject(args[0]);\n                  break;\n                case OPS.paintInlineImageXObject:\n                  this.paintInlineImageXObject(args[0]);\n                  break;\n                case OPS.paintImageMaskXObject:\n                  this.paintImageMaskXObject(args[0]);\n                  break;\n                case OPS.paintFormXObjectBegin:\n                  this.paintFormXObjectBegin(args[0], args[1]);\n                  break;\n                case OPS.paintFormXObjectEnd:\n                  this.paintFormXObjectEnd();\n                  break;\n                case OPS.closePath:\n                  this.closePath();\n                  break;\n                case OPS.closeStroke:\n                  this.closeStroke();\n                  break;\n                case OPS.closeFillStroke:\n                  this.closeFillStroke();\n                  break;\n                case OPS.nextLine:\n                  this.nextLine();\n                  break;\n                case OPS.transform:\n                  this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                  break;\n                case OPS.constructPath:\n                  this.constructPath(args[0], args[1]);\n                  break;\n                case OPS.endPath:\n                  this.endPath();\n                  break;\n                case 92:\n                  this.group(opTree[x].items);\n                  break;\n                default:\n                  warn('Unimplemented method ' + fn);\n                  break;\n              }\n            }\n          },\n          setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {\n            this.current.wordSpacing = wordSpacing;\n          },\n          setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {\n            this.current.charSpacing = charSpacing;\n          },\n          nextLine: function SVGGraphics_nextLine() {\n            this.moveText(0, this.current.leading);\n          },\n          setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {\n            var current = this.current;\n            this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];\n            this.current.x = this.current.lineX = 0;\n            this.current.y = this.current.lineY = 0;\n            current.xcoords = [];\n            current.tspan = document.createElementNS(NS, 'svg:tspan');\n            current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n            current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\n            current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n            current.txtElement = document.createElementNS(NS, 'svg:text');\n            current.txtElement.appendChild(current.tspan);\n          },\n          beginText: function SVGGraphics_beginText() {\n            this.current.x = this.current.lineX = 0;\n            this.current.y = this.current.lineY = 0;\n            this.current.textMatrix = IDENTITY_MATRIX;\n            this.current.lineMatrix = IDENTITY_MATRIX;\n            this.current.tspan = document.createElementNS(NS, 'svg:tspan');\n            this.current.txtElement = document.createElementNS(NS, 'svg:text');\n            this.current.txtgrp = document.createElementNS(NS, 'svg:g');\n            this.current.xcoords = [];\n          },\n          moveText: function SVGGraphics_moveText(x, y) {\n            var current = this.current;\n            this.current.x = this.current.lineX += x;\n            this.current.y = this.current.lineY += y;\n            current.xcoords = [];\n            current.tspan = document.createElementNS(NS, 'svg:tspan');\n            current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n            current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\n            current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n          },\n          showText: function SVGGraphics_showText(glyphs) {\n            var current = this.current;\n            var font = current.font;\n            var fontSize = current.fontSize;\n            if (fontSize === 0) {\n              return;\n            }\n            var charSpacing = current.charSpacing;\n            var wordSpacing = current.wordSpacing;\n            var fontDirection = current.fontDirection;\n            var textHScale = current.textHScale * fontDirection;\n            var glyphsLength = glyphs.length;\n            var vertical = font.vertical;\n            var widthAdvanceScale = fontSize * current.fontMatrix[0];\n            var x = 0,\n              i;\n            for (i = 0; i < glyphsLength; ++i) {\n              var glyph = glyphs[i];\n              if (glyph === null) {\n                // word break\n                x += fontDirection * wordSpacing;\n                continue;\n              } else if (isNum(glyph)) {\n                x += -glyph * fontSize * 0.001;\n                continue;\n              }\n              current.xcoords.push(current.x + x * textHScale);\n              var width = glyph.width;\n              var character = glyph.fontChar;\n              var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;\n              x += charWidth;\n              current.tspan.textContent += character;\n            }\n            if (vertical) {\n              current.y -= x * textHScale;\n            } else {\n              current.x += x * textHScale;\n            }\n            current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));\n            current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n            current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n            current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\n            if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n              current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);\n            }\n            if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n              current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);\n            }\n            if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n              current.tspan.setAttributeNS(null, 'fill', current.fillColor);\n            }\n            current.txtElement.setAttributeNS(null, 'transform', pm(current.textMatrix) + ' scale(1, -1)');\n            current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');\n            current.txtElement.appendChild(current.tspan);\n            current.txtgrp.appendChild(current.txtElement);\n            this.tgrp.appendChild(current.txtElement);\n          },\n          setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {\n            this.setLeading(-y);\n            this.moveText(x, y);\n          },\n          addFontStyle: function SVGGraphics_addFontStyle(fontObj) {\n            if (!this.cssStyle) {\n              this.cssStyle = document.createElementNS(NS, 'svg:style');\n              this.cssStyle.setAttributeNS(null, 'type', 'text/css');\n              this.defs.appendChild(this.cssStyle);\n            }\n            var url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n            this.cssStyle.textContent += '@font-face { font-family: \"' + fontObj.loadedName + '\";' + ' src: url(' + url + '); }\\n';\n          },\n          setFont: function SVGGraphics_setFont(details) {\n            var current = this.current;\n            var fontObj = this.commonObjs.get(details[0]);\n            var size = details[1];\n            this.current.font = fontObj;\n            if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {\n              this.addFontStyle(fontObj);\n              this.embeddedFonts[fontObj.loadedName] = fontObj;\n            }\n            current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : FONT_IDENTITY_MATRIX;\n            var bold = fontObj.black ? fontObj.bold ? 'bolder' : 'bold' : fontObj.bold ? 'bold' : 'normal';\n            var italic = fontObj.italic ? 'italic' : 'normal';\n            if (size < 0) {\n              size = -size;\n              current.fontDirection = -1;\n            } else {\n              current.fontDirection = 1;\n            }\n            current.fontSize = size;\n            current.fontFamily = fontObj.loadedName;\n            current.fontWeight = bold;\n            current.fontStyle = italic;\n            current.tspan = document.createElementNS(NS, 'svg:tspan');\n            current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n            current.xcoords = [];\n          },\n          endText: function SVGGraphics_endText() {\n            if (this.current.pendingClip) {\n              this.cgrp.appendChild(this.tgrp);\n              this.pgrp.appendChild(this.cgrp);\n            } else {\n              this.pgrp.appendChild(this.tgrp);\n            }\n            this.tgrp = document.createElementNS(NS, 'svg:g');\n            this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n          },\n          // Path properties\n          setLineWidth: function SVGGraphics_setLineWidth(width) {\n            this.current.lineWidth = width;\n          },\n          setLineCap: function SVGGraphics_setLineCap(style) {\n            this.current.lineCap = LINE_CAP_STYLES[style];\n          },\n          setLineJoin: function SVGGraphics_setLineJoin(style) {\n            this.current.lineJoin = LINE_JOIN_STYLES[style];\n          },\n          setMiterLimit: function SVGGraphics_setMiterLimit(limit) {\n            this.current.miterLimit = limit;\n          },\n          setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {\n            var color = Util.makeCssRgb(r, g, b);\n            this.current.strokeColor = color;\n          },\n          setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {\n            var color = Util.makeCssRgb(r, g, b);\n            this.current.fillColor = color;\n            this.current.tspan = document.createElementNS(NS, 'svg:tspan');\n            this.current.xcoords = [];\n          },\n          setDash: function SVGGraphics_setDash(dashArray, dashPhase) {\n            this.current.dashArray = dashArray;\n            this.current.dashPhase = dashPhase;\n          },\n          constructPath: function SVGGraphics_constructPath(ops, args) {\n            var current = this.current;\n            var x = current.x,\n              y = current.y;\n            current.path = document.createElementNS(NS, 'svg:path');\n            var d = [];\n            var opLength = ops.length;\n            for (var i = 0, j = 0; i < opLength; i++) {\n              switch (ops[i] | 0) {\n                case OPS.rectangle:\n                  x = args[j++];\n                  y = args[j++];\n                  var width = args[j++];\n                  var height = args[j++];\n                  var xw = x + width;\n                  var yh = y + height;\n                  d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');\n                  break;\n                case OPS.moveTo:\n                  x = args[j++];\n                  y = args[j++];\n                  d.push('M', pf(x), pf(y));\n                  break;\n                case OPS.lineTo:\n                  x = args[j++];\n                  y = args[j++];\n                  d.push('L', pf(x), pf(y));\n                  break;\n                case OPS.curveTo:\n                  x = args[j + 4];\n                  y = args[j + 5];\n                  d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                  j += 6;\n                  break;\n                case OPS.curveTo2:\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                  j += 4;\n                  break;\n                case OPS.curveTo3:\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                  j += 4;\n                  break;\n                case OPS.closePath:\n                  d.push('Z');\n                  break;\n              }\n            }\n            current.path.setAttributeNS(null, 'd', d.join(' '));\n            current.path.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));\n            current.path.setAttributeNS(null, 'stroke-linecap', current.lineCap);\n            current.path.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);\n            current.path.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');\n            current.path.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));\n            current.path.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');\n            current.path.setAttributeNS(null, 'fill', 'none');\n            this.tgrp.appendChild(current.path);\n            if (current.pendingClip) {\n              this.cgrp.appendChild(this.tgrp);\n              this.pgrp.appendChild(this.cgrp);\n            } else {\n              this.pgrp.appendChild(this.tgrp);\n            }\n            // Saving a reference in current.element so that it can be addressed\n            // in 'fill' and 'stroke'\n            current.element = current.path;\n            current.setCurrentPoint(x, y);\n          },\n          endPath: function SVGGraphics_endPath() {\n            var current = this.current;\n            if (current.pendingClip) {\n              this.cgrp.appendChild(this.tgrp);\n              this.pgrp.appendChild(this.cgrp);\n            } else {\n              this.pgrp.appendChild(this.tgrp);\n            }\n            this.tgrp = document.createElementNS(NS, 'svg:g');\n            this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n          },\n          clip: function SVGGraphics_clip(type) {\n            var current = this.current;\n            // Add current path to clipping path\n            current.clipId = 'clippath' + clipCount;\n            clipCount++;\n            this.clippath = document.createElementNS(NS, 'svg:clipPath');\n            this.clippath.setAttributeNS(null, 'id', current.clipId);\n            var clipElement = current.element.cloneNode();\n            if (type === 'evenodd') {\n              clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');\n            } else {\n              clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');\n            }\n            this.clippath.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n            this.clippath.appendChild(clipElement);\n            this.defs.appendChild(this.clippath);\n\n            // Create a new group with that attribute\n            current.pendingClip = true;\n            this.cgrp = document.createElementNS(NS, 'svg:g');\n            this.cgrp.setAttributeNS(null, 'clip-path', 'url(#' + current.clipId + ')');\n            this.pgrp.appendChild(this.cgrp);\n          },\n          closePath: function SVGGraphics_closePath() {\n            var current = this.current;\n            var d = current.path.getAttributeNS(null, 'd');\n            d += 'Z';\n            current.path.setAttributeNS(null, 'd', d);\n          },\n          setLeading: function SVGGraphics_setLeading(leading) {\n            this.current.leading = -leading;\n          },\n          setTextRise: function SVGGraphics_setTextRise(textRise) {\n            this.current.textRise = textRise;\n          },\n          setHScale: function SVGGraphics_setHScale(scale) {\n            this.current.textHScale = scale / 100;\n          },\n          setGState: function SVGGraphics_setGState(states) {\n            for (var i = 0, ii = states.length; i < ii; i++) {\n              var state = states[i];\n              var key = state[0];\n              var value = state[1];\n              switch (key) {\n                case 'LW':\n                  this.setLineWidth(value);\n                  break;\n                case 'LC':\n                  this.setLineCap(value);\n                  break;\n                case 'LJ':\n                  this.setLineJoin(value);\n                  break;\n                case 'ML':\n                  this.setMiterLimit(value);\n                  break;\n                case 'D':\n                  this.setDash(value[0], value[1]);\n                  break;\n                case 'RI':\n                  break;\n                case 'FL':\n                  break;\n                case 'Font':\n                  this.setFont(value);\n                  break;\n                case 'CA':\n                  break;\n                case 'ca':\n                  break;\n                case 'BM':\n                  break;\n                case 'SMask':\n                  break;\n              }\n            }\n          },\n          fill: function SVGGraphics_fill() {\n            var current = this.current;\n            current.element.setAttributeNS(null, 'fill', current.fillColor);\n          },\n          stroke: function SVGGraphics_stroke() {\n            var current = this.current;\n            current.element.setAttributeNS(null, 'stroke', current.strokeColor);\n            current.element.setAttributeNS(null, 'fill', 'none');\n          },\n          eoFill: function SVGGraphics_eoFill() {\n            var current = this.current;\n            current.element.setAttributeNS(null, 'fill', current.fillColor);\n            current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\n          },\n          fillStroke: function SVGGraphics_fillStroke() {\n            // Order is important since stroke wants fill to be none.\n            // First stroke, then if fill needed, it will be overwritten.\n            this.stroke();\n            this.fill();\n          },\n          eoFillStroke: function SVGGraphics_eoFillStroke() {\n            this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\n            this.fillStroke();\n          },\n          closeStroke: function SVGGraphics_closeStroke() {\n            this.closePath();\n            this.stroke();\n          },\n          closeFillStroke: function SVGGraphics_closeFillStroke() {\n            this.closePath();\n            this.fillStroke();\n          },\n          paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {\n            var current = this.current;\n            var rect = document.createElementNS(NS, 'svg:rect');\n            rect.setAttributeNS(null, 'x', '0');\n            rect.setAttributeNS(null, 'y', '0');\n            rect.setAttributeNS(null, 'width', '1px');\n            rect.setAttributeNS(null, 'height', '1px');\n            rect.setAttributeNS(null, 'fill', current.fillColor);\n            this.tgrp.appendChild(rect);\n          },\n          paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {\n            var current = this.current;\n            var imgObj = this.objs.get(objId);\n            var imgEl = document.createElementNS(NS, 'svg:image');\n            imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);\n            imgEl.setAttributeNS(null, 'width', imgObj.width + 'px');\n            imgEl.setAttributeNS(null, 'height', imgObj.height + 'px');\n            imgEl.setAttributeNS(null, 'x', '0');\n            imgEl.setAttributeNS(null, 'y', pf(-h));\n            imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');\n            this.tgrp.appendChild(imgEl);\n            if (current.pendingClip) {\n              this.cgrp.appendChild(this.tgrp);\n              this.pgrp.appendChild(this.cgrp);\n            } else {\n              this.pgrp.appendChild(this.tgrp);\n            }\n          },\n          paintImageXObject: function SVGGraphics_paintImageXObject(objId) {\n            var imgData = this.objs.get(objId);\n            if (!imgData) {\n              warn('Dependent image isn\\'t ready yet');\n              return;\n            }\n            this.paintInlineImageXObject(imgData);\n          },\n          paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {\n            var current = this.current;\n            var width = imgData.width;\n            var height = imgData.height;\n            var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema);\n            var cliprect = document.createElementNS(NS, 'svg:rect');\n            cliprect.setAttributeNS(null, 'x', '0');\n            cliprect.setAttributeNS(null, 'y', '0');\n            cliprect.setAttributeNS(null, 'width', pf(width));\n            cliprect.setAttributeNS(null, 'height', pf(height));\n            current.element = cliprect;\n            this.clip('nonzero');\n            var imgEl = document.createElementNS(NS, 'svg:image');\n            imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);\n            imgEl.setAttributeNS(null, 'x', '0');\n            imgEl.setAttributeNS(null, 'y', pf(-height));\n            imgEl.setAttributeNS(null, 'width', pf(width) + 'px');\n            imgEl.setAttributeNS(null, 'height', pf(height) + 'px');\n            imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' + pf(-1 / height) + ')');\n            if (mask) {\n              mask.appendChild(imgEl);\n            } else {\n              this.tgrp.appendChild(imgEl);\n            }\n            if (current.pendingClip) {\n              this.cgrp.appendChild(this.tgrp);\n              this.pgrp.appendChild(this.cgrp);\n            } else {\n              this.pgrp.appendChild(this.tgrp);\n            }\n          },\n          paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {\n            var current = this.current;\n            var width = imgData.width;\n            var height = imgData.height;\n            var fillColor = current.fillColor;\n            current.maskId = 'mask' + maskCount++;\n            var mask = document.createElementNS(NS, 'svg:mask');\n            mask.setAttributeNS(null, 'id', current.maskId);\n            var rect = document.createElementNS(NS, 'svg:rect');\n            rect.setAttributeNS(null, 'x', '0');\n            rect.setAttributeNS(null, 'y', '0');\n            rect.setAttributeNS(null, 'width', pf(width));\n            rect.setAttributeNS(null, 'height', pf(height));\n            rect.setAttributeNS(null, 'fill', fillColor);\n            rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');\n            this.defs.appendChild(mask);\n            this.tgrp.appendChild(rect);\n            this.paintInlineImageXObject(imgData, mask);\n          },\n          paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {\n            this.save();\n            if (isArray(matrix) && matrix.length === 6) {\n              this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n            }\n            if (isArray(bbox) && bbox.length === 4) {\n              var width = bbox[2] - bbox[0];\n              var height = bbox[3] - bbox[1];\n              var cliprect = document.createElementNS(NS, 'svg:rect');\n              cliprect.setAttributeNS(null, 'x', bbox[0]);\n              cliprect.setAttributeNS(null, 'y', bbox[1]);\n              cliprect.setAttributeNS(null, 'width', pf(width));\n              cliprect.setAttributeNS(null, 'height', pf(height));\n              this.current.element = cliprect;\n              this.clip('nonzero');\n              this.endPath();\n            }\n          },\n          paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {\n            this.restore();\n          }\n        };\n        return SVGGraphics;\n      }();\n      exports.SVGGraphics = SVGGraphics;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayAnnotationLayer = {}, root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils);\n      }\n    })(this, function (exports, sharedUtil, displayDOMUtils) {\n      var AnnotationBorderStyleType = sharedUtil.AnnotationBorderStyleType;\n      var AnnotationType = sharedUtil.AnnotationType;\n      var Util = sharedUtil.Util;\n      var addLinkAttributes = displayDOMUtils.addLinkAttributes;\n      var LinkTarget = displayDOMUtils.LinkTarget;\n      var getFilenameFromUrl = displayDOMUtils.getFilenameFromUrl;\n      var warn = sharedUtil.warn;\n      var CustomStyle = displayDOMUtils.CustomStyle;\n      var getDefaultSetting = displayDOMUtils.getDefaultSetting;\n\n      /**\r\n       * @typedef {Object} AnnotationElementParameters\r\n       * @property {Object} data\r\n       * @property {HTMLDivElement} layer\r\n       * @property {PDFPage} page\r\n       * @property {PageViewport} viewport\r\n       * @property {IPDFLinkService} linkService\r\n       * @property {DownloadManager} downloadManager\r\n       */\n\n      /**\r\n       * @class\r\n       * @alias AnnotationElementFactory\r\n       */\n      function AnnotationElementFactory() {}\n      AnnotationElementFactory.prototype = /** @lends AnnotationElementFactory.prototype */{\n        /**\r\n         * @param {AnnotationElementParameters} parameters\r\n         * @returns {AnnotationElement}\r\n         */\n        create: function AnnotationElementFactory_create(parameters) {\n          var subtype = parameters.data.annotationType;\n          switch (subtype) {\n            case AnnotationType.LINK:\n              return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n              return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n              return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n              return new PopupAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n              return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n              return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n              return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n              return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n              return new FileAttachmentAnnotationElement(parameters);\n            default:\n              return new AnnotationElement(parameters);\n          }\n        }\n      };\n\n      /**\r\n       * @class\r\n       * @alias AnnotationElement\r\n       */\n      var AnnotationElement = function AnnotationElementClosure() {\n        function AnnotationElement(parameters, isRenderable) {\n          this.isRenderable = isRenderable || false;\n          this.data = parameters.data;\n          this.layer = parameters.layer;\n          this.page = parameters.page;\n          this.viewport = parameters.viewport;\n          this.linkService = parameters.linkService;\n          this.downloadManager = parameters.downloadManager;\n          this.imageResourcesPath = parameters.imageResourcesPath;\n          if (isRenderable) {\n            this.container = this._createContainer();\n          }\n        }\n        AnnotationElement.prototype = /** @lends AnnotationElement.prototype */{\n          /**\r\n           * Create an empty container for the annotation's HTML element.\r\n           *\r\n           * @private\r\n           * @memberof AnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          _createContainer: function AnnotationElement_createContainer() {\n            var data = this.data,\n              page = this.page,\n              viewport = this.viewport;\n            var container = document.createElement('section');\n            var width = data.rect[2] - data.rect[0];\n            var height = data.rect[3] - data.rect[1];\n            container.setAttribute('data-annotation-id', data.id);\n\n            // Do *not* modify `data.rect`, since that will corrupt the annotation\n            // position on subsequent calls to `_createContainer` (see issue 6804).\n            var rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n            CustomStyle.setProp('transform', container, 'matrix(' + viewport.transform.join(',') + ')');\n            CustomStyle.setProp('transformOrigin', container, -rect[0] + 'px ' + -rect[1] + 'px');\n            if (data.borderStyle.width > 0) {\n              container.style.borderWidth = data.borderStyle.width + 'px';\n              if (data.borderStyle.style !== AnnotationBorderStyleType.UNDERLINE) {\n                // Underline styles only have a bottom border, so we do not need\n                // to adjust for all borders. This yields a similar result as\n                // Adobe Acrobat/Reader.\n                width = width - 2 * data.borderStyle.width;\n                height = height - 2 * data.borderStyle.width;\n              }\n              var horizontalRadius = data.borderStyle.horizontalCornerRadius;\n              var verticalRadius = data.borderStyle.verticalCornerRadius;\n              if (horizontalRadius > 0 || verticalRadius > 0) {\n                var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';\n                CustomStyle.setProp('borderRadius', container, radius);\n              }\n              switch (data.borderStyle.style) {\n                case AnnotationBorderStyleType.SOLID:\n                  container.style.borderStyle = 'solid';\n                  break;\n                case AnnotationBorderStyleType.DASHED:\n                  container.style.borderStyle = 'dashed';\n                  break;\n                case AnnotationBorderStyleType.BEVELED:\n                  warn('Unimplemented border style: beveled');\n                  break;\n                case AnnotationBorderStyleType.INSET:\n                  warn('Unimplemented border style: inset');\n                  break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                  container.style.borderBottomStyle = 'solid';\n                  break;\n                default:\n                  break;\n              }\n              if (data.color) {\n                container.style.borderColor = Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n              } else {\n                // Transparent (invisible) border, so do not draw it at all.\n                container.style.borderWidth = 0;\n              }\n            }\n            container.style.left = rect[0] + 'px';\n            container.style.top = rect[1] + 'px';\n            container.style.width = width + 'px';\n            container.style.height = height + 'px';\n            return container;\n          },\n          /**\r\n           * Create a popup for the annotation's HTML element. This is used for\r\n           * annotations that do not have a Popup entry in the dictionary, but\r\n           * are of a type that works with popups (such as Highlight annotations).\r\n           *\r\n           * @private\r\n           * @param {HTMLSectionElement} container\r\n           * @param {HTMLDivElement|HTMLImageElement|null} trigger\r\n           * @param {Object} data\r\n           * @memberof AnnotationElement\r\n           */\n          _createPopup: function AnnotationElement_createPopup(container, trigger, data) {\n            // If no trigger element is specified, create it.\n            if (!trigger) {\n              trigger = document.createElement('div');\n              trigger.style.height = container.style.height;\n              trigger.style.width = container.style.width;\n              container.appendChild(trigger);\n            }\n            var popupElement = new PopupElement({\n              container: container,\n              trigger: trigger,\n              color: data.color,\n              title: data.title,\n              contents: data.contents,\n              hideWrapper: true\n            });\n            var popup = popupElement.render();\n\n            // Position the popup next to the annotation's container.\n            popup.style.left = container.style.width;\n            container.appendChild(popup);\n          },\n          /**\r\n           * Render the annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof AnnotationElement\r\n           */\n          render: function AnnotationElement_render() {\n            throw new Error('Abstract method AnnotationElement.render called');\n          }\n        };\n        return AnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias LinkAnnotationElement\r\n       */\n      var LinkAnnotationElement = function LinkAnnotationElementClosure() {\n        function LinkAnnotationElement(parameters) {\n          AnnotationElement.call(this, parameters, true);\n        }\n        Util.inherit(LinkAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the link annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof LinkAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function LinkAnnotationElement_render() {\n            this.container.className = 'linkAnnotation';\n            var link = document.createElement('a');\n            addLinkAttributes(link, {\n              url: this.data.url,\n              target: this.data.newWindow ? LinkTarget.BLANK : undefined\n            });\n            if (!this.data.url) {\n              if (this.data.action) {\n                this._bindNamedAction(link, this.data.action);\n              } else {\n                this._bindLink(link, this.data.dest || null);\n              }\n            }\n            this.container.appendChild(link);\n            return this.container;\n          },\n          /**\r\n           * Bind internal links to the link element.\r\n           *\r\n           * @private\r\n           * @param {Object} link\r\n           * @param {Object} destination\r\n           * @memberof LinkAnnotationElement\r\n           */\n          _bindLink: function LinkAnnotationElement_bindLink(link, destination) {\n            var self = this;\n            link.href = this.linkService.getDestinationHash(destination);\n            link.onclick = function () {\n              if (destination) {\n                self.linkService.navigateTo(destination);\n              }\n              return false;\n            };\n            if (destination) {\n              link.className = 'internalLink';\n            }\n          },\n          /**\r\n           * Bind named actions to the link element.\r\n           *\r\n           * @private\r\n           * @param {Object} link\r\n           * @param {Object} action\r\n           * @memberof LinkAnnotationElement\r\n           */\n          _bindNamedAction: function LinkAnnotationElement_bindNamedAction(link, action) {\n            var self = this;\n            link.href = this.linkService.getAnchorUrl('');\n            link.onclick = function () {\n              self.linkService.executeNamedAction(action);\n              return false;\n            };\n            link.className = 'internalLink';\n          }\n        });\n        return LinkAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias TextAnnotationElement\r\n       */\n      var TextAnnotationElement = function TextAnnotationElementClosure() {\n        function TextAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(TextAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the text annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof TextAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function TextAnnotationElement_render() {\n            this.container.className = 'textAnnotation';\n            var image = document.createElement('img');\n            image.style.height = this.container.style.height;\n            image.style.width = this.container.style.width;\n            image.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg';\n            image.alt = '[{{type}} Annotation]';\n            image.dataset.l10nId = 'text_annotation_type';\n            image.dataset.l10nArgs = JSON.stringify({\n              type: this.data.name\n            });\n            if (!this.data.hasPopup) {\n              this._createPopup(this.container, image, this.data);\n            }\n            this.container.appendChild(image);\n            return this.container;\n          }\n        });\n        return TextAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias WidgetAnnotationElement\r\n       */\n      var WidgetAnnotationElement = function WidgetAnnotationElementClosure() {\n        function WidgetAnnotationElement(parameters) {\n          var isRenderable = !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(WidgetAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the widget annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof WidgetAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function WidgetAnnotationElement_render() {\n            var content = document.createElement('div');\n            content.textContent = this.data.fieldValue;\n            var textAlignment = this.data.textAlignment;\n            content.style.textAlign = ['left', 'center', 'right'][textAlignment];\n            content.style.verticalAlign = 'middle';\n            content.style.display = 'table-cell';\n            var font = this.data.fontRefName ? this.page.commonObjs.getData(this.data.fontRefName) : null;\n            this._setTextStyle(content, font);\n            this.container.appendChild(content);\n            return this.container;\n          },\n          /**\r\n           * Apply text styles to the text in the element.\r\n           *\r\n           * @private\r\n           * @param {HTMLDivElement} element\r\n           * @param {Object} font\r\n           * @memberof WidgetAnnotationElement\r\n           */\n          _setTextStyle: function WidgetAnnotationElement_setTextStyle(element, font) {\n            // TODO: This duplicates some of the logic in CanvasGraphics.setFont().\n            var style = element.style;\n            style.fontSize = this.data.fontSize + 'px';\n            style.direction = this.data.fontDirection < 0 ? 'rtl' : 'ltr';\n            if (!font) {\n              return;\n            }\n            style.fontWeight = font.black ? font.bold ? '900' : 'bold' : font.bold ? 'bold' : 'normal';\n            style.fontStyle = font.italic ? 'italic' : 'normal';\n\n            // Use a reasonable default font if the font doesn't specify a fallback.\n            var fontFamily = font.loadedName ? '\"' + font.loadedName + '\", ' : '';\n            var fallbackName = font.fallbackName || 'Helvetica, sans-serif';\n            style.fontFamily = fontFamily + fallbackName;\n          }\n        });\n        return WidgetAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias PopupAnnotationElement\r\n       */\n      var PopupAnnotationElement = function PopupAnnotationElementClosure() {\n        function PopupAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(PopupAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the popup annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof PopupAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function PopupAnnotationElement_render() {\n            this.container.className = 'popupAnnotation';\n            var selector = '[data-annotation-id=\"' + this.data.parentId + '\"]';\n            var parentElement = this.layer.querySelector(selector);\n            if (!parentElement) {\n              return this.container;\n            }\n            var popup = new PopupElement({\n              container: this.container,\n              trigger: parentElement,\n              color: this.data.color,\n              title: this.data.title,\n              contents: this.data.contents\n            });\n\n            // Position the popup next to the parent annotation's container.\n            // PDF viewers ignore a popup annotation's rectangle.\n            var parentLeft = parseFloat(parentElement.style.left);\n            var parentWidth = parseFloat(parentElement.style.width);\n            CustomStyle.setProp('transformOrigin', this.container, -(parentLeft + parentWidth) + 'px -' + parentElement.style.top);\n            this.container.style.left = parentLeft + parentWidth + 'px';\n            this.container.appendChild(popup.render());\n            return this.container;\n          }\n        });\n        return PopupAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias PopupElement\r\n       */\n      var PopupElement = function PopupElementClosure() {\n        var BACKGROUND_ENLIGHT = 0.7;\n        function PopupElement(parameters) {\n          this.container = parameters.container;\n          this.trigger = parameters.trigger;\n          this.color = parameters.color;\n          this.title = parameters.title;\n          this.contents = parameters.contents;\n          this.hideWrapper = parameters.hideWrapper || false;\n          this.pinned = false;\n        }\n        PopupElement.prototype = /** @lends PopupElement.prototype */{\n          /**\r\n           * Render the popup's HTML element.\r\n           *\r\n           * @public\r\n           * @memberof PopupElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function PopupElement_render() {\n            var wrapper = document.createElement('div');\n            wrapper.className = 'popupWrapper';\n\n            // For Popup annotations we hide the entire section because it contains\n            // only the popup. However, for Text annotations without a separate Popup\n            // annotation, we cannot hide the entire container as the image would\n            // disappear too. In that special case, hiding the wrapper suffices.\n            this.hideElement = this.hideWrapper ? wrapper : this.container;\n            this.hideElement.setAttribute('hidden', true);\n            var popup = document.createElement('div');\n            popup.className = 'popup';\n            var color = this.color;\n            if (color) {\n              // Enlighten the color.\n              var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n              var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n              var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n              popup.style.backgroundColor = Util.makeCssRgb(r | 0, g | 0, b | 0);\n            }\n            var contents = this._formatContents(this.contents);\n            var title = document.createElement('h1');\n            title.textContent = this.title;\n\n            // Attach the event listeners to the trigger element.\n            this.trigger.addEventListener('click', this._toggle.bind(this));\n            this.trigger.addEventListener('mouseover', this._show.bind(this, false));\n            this.trigger.addEventListener('mouseout', this._hide.bind(this, false));\n            popup.addEventListener('click', this._hide.bind(this, true));\n            popup.appendChild(title);\n            popup.appendChild(contents);\n            wrapper.appendChild(popup);\n            return wrapper;\n          },\n          /**\r\n           * Format the contents of the popup by adding newlines where necessary.\r\n           *\r\n           * @private\r\n           * @param {string} contents\r\n           * @memberof PopupElement\r\n           * @returns {HTMLParagraphElement}\r\n           */\n          _formatContents: function PopupElement_formatContents(contents) {\n            var p = document.createElement('p');\n            var lines = contents.split(/(?:\\r\\n?|\\n)/);\n            for (var i = 0, ii = lines.length; i < ii; ++i) {\n              var line = lines[i];\n              p.appendChild(document.createTextNode(line));\n              if (i < ii - 1) {\n                p.appendChild(document.createElement('br'));\n              }\n            }\n            return p;\n          },\n          /**\r\n           * Toggle the visibility of the popup.\r\n           *\r\n           * @private\r\n           * @memberof PopupElement\r\n           */\n          _toggle: function PopupElement_toggle() {\n            if (this.pinned) {\n              this._hide(true);\n            } else {\n              this._show(true);\n            }\n          },\n          /**\r\n           * Show the popup.\r\n           *\r\n           * @private\r\n           * @param {boolean} pin\r\n           * @memberof PopupElement\r\n           */\n          _show: function PopupElement_show(pin) {\n            if (pin) {\n              this.pinned = true;\n            }\n            if (this.hideElement.hasAttribute('hidden')) {\n              this.hideElement.removeAttribute('hidden');\n              this.container.style.zIndex += 1;\n            }\n          },\n          /**\r\n           * Hide the popup.\r\n           *\r\n           * @private\r\n           * @param {boolean} unpin\r\n           * @memberof PopupElement\r\n           */\n          _hide: function PopupElement_hide(unpin) {\n            if (unpin) {\n              this.pinned = false;\n            }\n            if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {\n              this.hideElement.setAttribute('hidden', true);\n              this.container.style.zIndex -= 1;\n            }\n          }\n        };\n        return PopupElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias HighlightAnnotationElement\r\n       */\n      var HighlightAnnotationElement = function HighlightAnnotationElementClosure() {\n        function HighlightAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(HighlightAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the highlight annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof HighlightAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function HighlightAnnotationElement_render() {\n            this.container.className = 'highlightAnnotation';\n            if (!this.data.hasPopup) {\n              this._createPopup(this.container, null, this.data);\n            }\n            return this.container;\n          }\n        });\n        return HighlightAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias UnderlineAnnotationElement\r\n       */\n      var UnderlineAnnotationElement = function UnderlineAnnotationElementClosure() {\n        function UnderlineAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(UnderlineAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the underline annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof UnderlineAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function UnderlineAnnotationElement_render() {\n            this.container.className = 'underlineAnnotation';\n            if (!this.data.hasPopup) {\n              this._createPopup(this.container, null, this.data);\n            }\n            return this.container;\n          }\n        });\n        return UnderlineAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias SquigglyAnnotationElement\r\n       */\n      var SquigglyAnnotationElement = function SquigglyAnnotationElementClosure() {\n        function SquigglyAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(SquigglyAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the squiggly annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof SquigglyAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function SquigglyAnnotationElement_render() {\n            this.container.className = 'squigglyAnnotation';\n            if (!this.data.hasPopup) {\n              this._createPopup(this.container, null, this.data);\n            }\n            return this.container;\n          }\n        });\n        return SquigglyAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias StrikeOutAnnotationElement\r\n       */\n      var StrikeOutAnnotationElement = function StrikeOutAnnotationElementClosure() {\n        function StrikeOutAnnotationElement(parameters) {\n          var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n          AnnotationElement.call(this, parameters, isRenderable);\n        }\n        Util.inherit(StrikeOutAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the strikeout annotation's HTML element in the empty container.\r\n           *\r\n           * @public\r\n           * @memberof StrikeOutAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function StrikeOutAnnotationElement_render() {\n            this.container.className = 'strikeoutAnnotation';\n            if (!this.data.hasPopup) {\n              this._createPopup(this.container, null, this.data);\n            }\n            return this.container;\n          }\n        });\n        return StrikeOutAnnotationElement;\n      }();\n\n      /**\r\n       * @class\r\n       * @alias FileAttachmentAnnotationElement\r\n       */\n      var FileAttachmentAnnotationElement = function FileAttachmentAnnotationElementClosure() {\n        function FileAttachmentAnnotationElement(parameters) {\n          AnnotationElement.call(this, parameters, true);\n          this.filename = getFilenameFromUrl(parameters.data.file.filename);\n          this.content = parameters.data.file.content;\n        }\n        Util.inherit(FileAttachmentAnnotationElement, AnnotationElement, {\n          /**\r\n           * Render the file attachment annotation's HTML element in the empty\r\n           * container.\r\n           *\r\n           * @public\r\n           * @memberof FileAttachmentAnnotationElement\r\n           * @returns {HTMLSectionElement}\r\n           */\n          render: function FileAttachmentAnnotationElement_render() {\n            this.container.className = 'fileAttachmentAnnotation';\n            var trigger = document.createElement('div');\n            trigger.style.height = this.container.style.height;\n            trigger.style.width = this.container.style.width;\n            trigger.addEventListener('dblclick', this._download.bind(this));\n            if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\n              this._createPopup(this.container, trigger, this.data);\n            }\n            this.container.appendChild(trigger);\n            return this.container;\n          },\n          /**\r\n           * Download the file attachment associated with this annotation.\r\n           *\r\n           * @private\r\n           * @memberof FileAttachmentAnnotationElement\r\n           */\n          _download: function FileAttachmentAnnotationElement_download() {\n            if (!this.downloadManager) {\n              warn('Download cannot be started due to unavailable download manager');\n              return;\n            }\n            this.downloadManager.downloadData(this.content, this.filename, '');\n          }\n        });\n        return FileAttachmentAnnotationElement;\n      }();\n\n      /**\r\n       * @typedef {Object} AnnotationLayerParameters\r\n       * @property {PageViewport} viewport\r\n       * @property {HTMLDivElement} div\r\n       * @property {Array} annotations\r\n       * @property {PDFPage} page\r\n       * @property {IPDFLinkService} linkService\r\n       * @property {string} imageResourcesPath\r\n       */\n\n      /**\r\n       * @class\r\n       * @alias AnnotationLayer\r\n       */\n      var AnnotationLayer = function AnnotationLayerClosure() {\n        return {\n          /**\r\n           * Render a new annotation layer with all annotation elements.\r\n           *\r\n           * @public\r\n           * @param {AnnotationLayerParameters} parameters\r\n           * @memberof AnnotationLayer\r\n           */\n          render: function AnnotationLayer_render(parameters) {\n            var annotationElementFactory = new AnnotationElementFactory();\n            for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {\n              var data = parameters.annotations[i];\n              if (!data) {\n                continue;\n              }\n              var properties = {\n                data: data,\n                layer: parameters.div,\n                page: parameters.page,\n                viewport: parameters.viewport,\n                linkService: parameters.linkService,\n                downloadManager: parameters.downloadManager,\n                imageResourcesPath: parameters.imageResourcesPath || getDefaultSetting('imageResourcesPath')\n              };\n              var element = annotationElementFactory.create(properties);\n              if (element.isRenderable) {\n                parameters.div.appendChild(element.render());\n              }\n            }\n          },\n          /**\r\n           * Update the annotation elements on existing annotation layer.\r\n           *\r\n           * @public\r\n           * @param {AnnotationLayerParameters} parameters\r\n           * @memberof AnnotationLayer\r\n           */\n          update: function AnnotationLayer_update(parameters) {\n            for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {\n              var data = parameters.annotations[i];\n              var element = parameters.div.querySelector('[data-annotation-id=\"' + data.id + '\"]');\n              if (element) {\n                CustomStyle.setProp('transform', element, 'matrix(' + parameters.viewport.transform.join(',') + ')');\n              }\n            }\n            parameters.div.removeAttribute('hidden');\n          }\n        };\n      }();\n      exports.AnnotationLayer = AnnotationLayer;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayTextLayer = {}, root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils);\n      }\n    })(this, function (exports, sharedUtil, displayDOMUtils) {\n      var Util = sharedUtil.Util;\n      var createPromiseCapability = sharedUtil.createPromiseCapability;\n      var CustomStyle = displayDOMUtils.CustomStyle;\n      var getDefaultSetting = displayDOMUtils.getDefaultSetting;\n      var PageViewport = sharedUtil.PageViewport;\n\n      /**\r\n       * Text layer render parameters.\r\n       *\r\n       * @typedef {Object} TextLayerRenderParameters\r\n       * @property {TextContent} textContent - Text content to render (the object is\r\n       *   returned by the page's getTextContent() method).\r\n       * @property {HTMLElement} container - HTML element that will contain text runs.\r\n       * @property {PageViewport} viewport - The target viewport to properly\r\n       *   layout the text runs.\r\n       * @property {Array} textDivs - (optional) HTML elements that are correspond\r\n       *   the text items of the textContent input. This is output and shall be\r\n       *   initially be set to empty array.\r\n       * @property {number} timeout - (optional) Delay in milliseconds before\r\n       *   rendering of the text  runs occurs.\r\n       */\n      var renderTextLayer = function renderTextLayerClosure() {\n        var MAX_TEXT_DIVS_TO_RENDER = 100000;\n        var NonWhitespaceRegexp = /\\S/;\n        function isAllWhitespace(str) {\n          return !NonWhitespaceRegexp.test(str);\n        }\n        function appendText(textDivs, viewport, geom, styles) {\n          var style = styles[geom.fontName];\n          var textDiv = document.createElement('div');\n          textDivs.push(textDiv);\n          if (isAllWhitespace(geom.str)) {\n            textDiv.dataset.isWhitespace = true;\n            return;\n          }\n          var tx = Util.transform(viewport.transform, geom.transform);\n          var angle = Math.atan2(tx[1], tx[0]);\n          if (style.vertical) {\n            angle += Math.PI / 2;\n          }\n          var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\n          var fontAscent = fontHeight;\n          if (style.ascent) {\n            fontAscent = style.ascent * fontAscent;\n          } else if (style.descent) {\n            fontAscent = (1 + style.descent) * fontAscent;\n          }\n          var left;\n          var top;\n          if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n          } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n          }\n          textDiv.style.left = left + 'px';\n          textDiv.style.top = top + 'px';\n          textDiv.style.fontSize = fontHeight + 'px';\n          textDiv.style.fontFamily = style.fontFamily;\n          textDiv.textContent = geom.str;\n          // |fontName| is only used by the Font Inspector. This test will succeed\n          // when e.g. the Font Inspector is off but the Stepper is on, but it's\n          // not worth the effort to do a more accurate test.\n          if (getDefaultSetting('pdfBug')) {\n            textDiv.dataset.fontName = geom.fontName;\n          }\n          // Storing into dataset will convert number into string.\n          if (angle !== 0) {\n            textDiv.dataset.angle = angle * (180 / Math.PI);\n          }\n          // We don't bother scaling single-char text divs, because it has very\n          // little effect on text highlighting. This makes scrolling on docs with\n          // lots of such divs a lot faster.\n          if (geom.str.length > 1) {\n            if (style.vertical) {\n              textDiv.dataset.canvasWidth = geom.height * viewport.scale;\n            } else {\n              textDiv.dataset.canvasWidth = geom.width * viewport.scale;\n            }\n          }\n        }\n        function render(task) {\n          if (task._canceled) {\n            return;\n          }\n          var textLayerFrag = task._container;\n          var textDivs = task._textDivs;\n          var capability = task._capability;\n          var textDivsLength = textDivs.length;\n\n          // No point in rendering many divs as it would make the browser\n          // unusable even after the divs are rendered.\n          if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n            capability.resolve();\n            return;\n          }\n          var canvas = document.createElement('canvas');\n          canvas.mozOpaque = true;\n          var ctx = canvas.getContext('2d', {\n            alpha: false\n          });\n          var lastFontSize;\n          var lastFontFamily;\n          for (var i = 0; i < textDivsLength; i++) {\n            var textDiv = textDivs[i];\n            if (textDiv.dataset.isWhitespace !== undefined) {\n              continue;\n            }\n            var fontSize = textDiv.style.fontSize;\n            var fontFamily = textDiv.style.fontFamily;\n\n            // Only build font string and set to context if different from last.\n            if (fontSize !== lastFontSize || fontFamily !== lastFontFamily) {\n              ctx.font = fontSize + ' ' + fontFamily;\n              lastFontSize = fontSize;\n              lastFontFamily = fontFamily;\n            }\n            var width = ctx.measureText(textDiv.textContent).width;\n            if (width > 0) {\n              textLayerFrag.appendChild(textDiv);\n              var transform;\n              if (textDiv.dataset.canvasWidth !== undefined) {\n                // Dataset values come of type string.\n                var textScale = textDiv.dataset.canvasWidth / width;\n                transform = 'scaleX(' + textScale + ')';\n              } else {\n                transform = '';\n              }\n              var rotation = textDiv.dataset.angle;\n              if (rotation) {\n                transform = 'rotate(' + rotation + 'deg) ' + transform;\n              }\n              if (transform) {\n                CustomStyle.setProp('transform', textDiv, transform);\n              }\n            }\n          }\n          capability.resolve();\n        }\n\n        /**\r\n         * Text layer rendering task.\r\n         *\r\n         * @param {TextContent} textContent\r\n         * @param {HTMLElement} container\r\n         * @param {PageViewport} viewport\r\n         * @param {Array} textDivs\r\n         * @private\r\n         */\n        function TextLayerRenderTask(textContent, container, viewport, textDivs) {\n          this._textContent = textContent;\n          this._container = container;\n          this._viewport = viewport;\n          textDivs = textDivs || [];\n          this._textDivs = textDivs;\n          this._canceled = false;\n          this._capability = createPromiseCapability();\n          this._renderTimer = null;\n        }\n        TextLayerRenderTask.prototype = {\n          get promise() {\n            return this._capability.promise;\n          },\n          cancel: function TextLayer_cancel() {\n            this._canceled = true;\n            if (this._renderTimer !== null) {\n              clearTimeout(this._renderTimer);\n              this._renderTimer = null;\n            }\n            this._capability.reject('canceled');\n          },\n          _render: function TextLayer_render(timeout) {\n            var textItems = this._textContent.items;\n            var styles = this._textContent.styles;\n            var textDivs = this._textDivs;\n            var viewport = this._viewport;\n            for (var i = 0, len = textItems.length; i < len; i++) {\n              appendText(textDivs, viewport, textItems[i], styles);\n            }\n            if (!timeout) {\n              // Render right away\n              render(this);\n            } else {\n              // Schedule\n              var self = this;\n              this._renderTimer = setTimeout(function () {\n                render(self);\n                self._renderTimer = null;\n              }, timeout);\n            }\n          }\n        };\n\n        /**\r\n         * Starts rendering of the text layer.\r\n         *\r\n         * @param {TextLayerRenderParameters} renderParameters\r\n         * @returns {TextLayerRenderTask}\r\n         */\n        function renderTextLayer(renderParameters) {\n          var task = new TextLayerRenderTask(renderParameters.textContent, renderParameters.container, renderParameters.viewport, renderParameters.textDivs);\n          task._render(renderParameters.timeout);\n          return task;\n        }\n        return renderTextLayer;\n      }();\n      exports.renderTextLayer = renderTextLayer;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayWebGL = {}, root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils);\n      }\n    })(this, function (exports, sharedUtil, displayDOMUtils) {\n      var shadow = sharedUtil.shadow;\n      var getDefaultSetting = displayDOMUtils.getDefaultSetting;\n      var WebGLUtils = function WebGLUtilsClosure() {\n        function loadShader(gl, code, shaderType) {\n          var shader = gl.createShader(shaderType);\n          gl.shaderSource(shader, code);\n          gl.compileShader(shader);\n          var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n          if (!compiled) {\n            var errorMsg = gl.getShaderInfoLog(shader);\n            throw new Error('Error during shader compilation: ' + errorMsg);\n          }\n          return shader;\n        }\n        function createVertexShader(gl, code) {\n          return loadShader(gl, code, gl.VERTEX_SHADER);\n        }\n        function createFragmentShader(gl, code) {\n          return loadShader(gl, code, gl.FRAGMENT_SHADER);\n        }\n        function createProgram(gl, shaders) {\n          var program = gl.createProgram();\n          for (var i = 0, ii = shaders.length; i < ii; ++i) {\n            gl.attachShader(program, shaders[i]);\n          }\n          gl.linkProgram(program);\n          var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n          if (!linked) {\n            var errorMsg = gl.getProgramInfoLog(program);\n            throw new Error('Error during program linking: ' + errorMsg);\n          }\n          return program;\n        }\n        function createTexture(gl, image, textureId) {\n          gl.activeTexture(textureId);\n          var texture = gl.createTexture();\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n\n          // Set the parameters so we can render any size image.\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n          // Upload the image into the texture.\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n          return texture;\n        }\n        var currentGL, currentCanvas;\n        function generateGL() {\n          if (currentGL) {\n            return;\n          }\n          currentCanvas = document.createElement('canvas');\n          currentGL = currentCanvas.getContext('webgl', {\n            premultipliedalpha: false\n          });\n        }\n        var smaskVertexShaderCode = '\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec2 a_texCoord;                                    \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_texCoord = a_texCoord;                                    \\\r\n  }                                                             ';\n        var smaskFragmentShaderCode = '\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  uniform vec4 u_backdrop;                                      \\\r\n  uniform int u_subtype;                                        \\\r\n  uniform sampler2D u_image;                                    \\\r\n  uniform sampler2D u_mask;                                     \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\r\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\r\n    if (u_backdrop.a > 0.0) {                                   \\\r\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\r\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\r\n    }                                                           \\\r\n    float lum;                                                  \\\r\n    if (u_subtype == 0) {                                       \\\r\n      lum = maskColor.a;                                        \\\r\n    } else {                                                    \\\r\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\r\n            maskColor.b * 0.11;                                 \\\r\n    }                                                           \\\r\n    imageColor.a *= lum;                                        \\\r\n    imageColor.rgb *= imageColor.a;                             \\\r\n    gl_FragColor = imageColor;                                  \\\r\n  }                                                             ';\n        var smaskCache = null;\n        function initSmaskGL() {\n          var canvas, gl;\n          generateGL();\n          canvas = currentCanvas;\n          currentCanvas = null;\n          gl = currentGL;\n          currentGL = null;\n\n          // setup a GLSL program\n          var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n          var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n          var program = createProgram(gl, [vertexShader, fragmentShader]);\n          gl.useProgram(program);\n          var cache = {};\n          cache.gl = gl;\n          cache.canvas = canvas;\n          cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n          cache.positionLocation = gl.getAttribLocation(program, 'a_position');\n          cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');\n          cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');\n          var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');\n          var texLayerLocation = gl.getUniformLocation(program, 'u_image');\n          var texMaskLocation = gl.getUniformLocation(program, 'u_mask');\n\n          // provide texture coordinates for the rectangle.\n          var texCoordBuffer = gl.createBuffer();\n          gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(texCoordLocation);\n          gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n          gl.uniform1i(texLayerLocation, 0);\n          gl.uniform1i(texMaskLocation, 1);\n          smaskCache = cache;\n        }\n        function composeSMask(layer, mask, properties) {\n          var width = layer.width,\n            height = layer.height;\n          if (!smaskCache) {\n            initSmaskGL();\n          }\n          var cache = smaskCache,\n            canvas = cache.canvas,\n            gl = cache.gl;\n          canvas.width = width;\n          canvas.height = height;\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.uniform2f(cache.resolutionLocation, width, height);\n          if (properties.backdrop) {\n            gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\n          } else {\n            gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n          }\n          gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);\n\n          // Create a textures\n          var texture = createTexture(gl, layer, gl.TEXTURE0);\n          var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n\n          // Create a buffer and put a single clipspace rectangle in\n          // it (2 triangles)\n          var buffer = gl.createBuffer();\n          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(cache.positionLocation);\n          gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n          // draw\n          gl.clearColor(0, 0, 0, 0);\n          gl.enable(gl.BLEND);\n          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n          gl.drawArrays(gl.TRIANGLES, 0, 6);\n          gl.flush();\n          gl.deleteTexture(texture);\n          gl.deleteTexture(maskTexture);\n          gl.deleteBuffer(buffer);\n          return canvas;\n        }\n        var figuresVertexShaderCode = '\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec3 a_color;                                       \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n  uniform vec2 u_scale;                                         \\\r\n  uniform vec2 u_offset;                                        \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 position = (a_position + u_offset) * u_scale;          \\\r\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\r\n  }                                                             ';\n        var figuresFragmentShaderCode = '\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    gl_FragColor = v_color;                                     \\\r\n  }                                                             ';\n        var figuresCache = null;\n        function initFiguresGL() {\n          var canvas, gl;\n          generateGL();\n          canvas = currentCanvas;\n          currentCanvas = null;\n          gl = currentGL;\n          currentGL = null;\n\n          // setup a GLSL program\n          var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n          var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n          var program = createProgram(gl, [vertexShader, fragmentShader]);\n          gl.useProgram(program);\n          var cache = {};\n          cache.gl = gl;\n          cache.canvas = canvas;\n          cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n          cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');\n          cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');\n          cache.positionLocation = gl.getAttribLocation(program, 'a_position');\n          cache.colorLocation = gl.getAttribLocation(program, 'a_color');\n          figuresCache = cache;\n        }\n        function drawFigures(width, height, backgroundColor, figures, context) {\n          if (!figuresCache) {\n            initFiguresGL();\n          }\n          var cache = figuresCache,\n            canvas = cache.canvas,\n            gl = cache.gl;\n          canvas.width = width;\n          canvas.height = height;\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.uniform2f(cache.resolutionLocation, width, height);\n\n          // count triangle points\n          var count = 0;\n          var i, ii, rows;\n          for (i = 0, ii = figures.length; i < ii; i++) {\n            switch (figures[i].type) {\n              case 'lattice':\n                rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\n                count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n                break;\n              case 'triangles':\n                count += figures[i].coords.length;\n                break;\n            }\n          }\n          // transfer data\n          var coords = new Float32Array(count * 2);\n          var colors = new Uint8Array(count * 3);\n          var coordsMap = context.coords,\n            colorsMap = context.colors;\n          var pIndex = 0,\n            cIndex = 0;\n          for (i = 0, ii = figures.length; i < ii; i++) {\n            var figure = figures[i],\n              ps = figure.coords,\n              cs = figure.colors;\n            switch (figure.type) {\n              case 'lattice':\n                var cols = figure.verticesPerRow;\n                rows = ps.length / cols | 0;\n                for (var row = 1; row < rows; row++) {\n                  var offset = row * cols + 1;\n                  for (var col = 1; col < cols; col++, offset++) {\n                    coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n                    coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n                    coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n                    coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n                    coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n                    coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n                    colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n                    colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n                    colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n                    colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n                    colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n                    colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n                    colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n                    colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n                    colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n                    coords[pIndex + 6] = coords[pIndex + 2];\n                    coords[pIndex + 7] = coords[pIndex + 3];\n                    coords[pIndex + 8] = coords[pIndex + 4];\n                    coords[pIndex + 9] = coords[pIndex + 5];\n                    coords[pIndex + 10] = coordsMap[ps[offset]];\n                    coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n                    colors[cIndex + 9] = colors[cIndex + 3];\n                    colors[cIndex + 10] = colors[cIndex + 4];\n                    colors[cIndex + 11] = colors[cIndex + 5];\n                    colors[cIndex + 12] = colors[cIndex + 6];\n                    colors[cIndex + 13] = colors[cIndex + 7];\n                    colors[cIndex + 14] = colors[cIndex + 8];\n                    colors[cIndex + 15] = colorsMap[cs[offset]];\n                    colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n                    colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n                    pIndex += 12;\n                    cIndex += 18;\n                  }\n                }\n                break;\n              case 'triangles':\n                for (var j = 0, jj = ps.length; j < jj; j++) {\n                  coords[pIndex] = coordsMap[ps[j]];\n                  coords[pIndex + 1] = coordsMap[ps[j] + 1];\n                  colors[cIndex] = colorsMap[cs[j]];\n                  colors[cIndex + 1] = colorsMap[cs[j] + 1];\n                  colors[cIndex + 2] = colorsMap[cs[j] + 2];\n                  pIndex += 2;\n                  cIndex += 3;\n                }\n                break;\n            }\n          }\n\n          // draw\n          if (backgroundColor) {\n            gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\n          } else {\n            gl.clearColor(0, 0, 0, 0);\n          }\n          gl.clear(gl.COLOR_BUFFER_BIT);\n          var coordsBuffer = gl.createBuffer();\n          gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n          gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(cache.positionLocation);\n          gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n          var colorsBuffer = gl.createBuffer();\n          gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n          gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(cache.colorLocation);\n          gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\n          gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n          gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n          gl.drawArrays(gl.TRIANGLES, 0, count);\n          gl.flush();\n          gl.deleteBuffer(coordsBuffer);\n          gl.deleteBuffer(colorsBuffer);\n          return canvas;\n        }\n        function cleanup() {\n          if (smaskCache && smaskCache.canvas) {\n            smaskCache.canvas.width = 0;\n            smaskCache.canvas.height = 0;\n          }\n          if (figuresCache && figuresCache.canvas) {\n            figuresCache.canvas.width = 0;\n            figuresCache.canvas.height = 0;\n          }\n          smaskCache = null;\n          figuresCache = null;\n        }\n        return {\n          get isEnabled() {\n            if (getDefaultSetting('disableWebGL')) {\n              return false;\n            }\n            var enabled = false;\n            try {\n              generateGL();\n              enabled = !!currentGL;\n            } catch (e) {}\n            return shadow(this, 'isEnabled', enabled);\n          },\n          composeSMask: composeSMask,\n          drawFigures: drawFigures,\n          clear: cleanup\n        };\n      }();\n      exports.WebGLUtils = WebGLUtils;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayPatternHelper = {}, root.pdfjsSharedUtil, root.pdfjsDisplayWebGL);\n      }\n    })(this, function (exports, sharedUtil, displayWebGL) {\n      var Util = sharedUtil.Util;\n      var info = sharedUtil.info;\n      var isArray = sharedUtil.isArray;\n      var error = sharedUtil.error;\n      var WebGLUtils = displayWebGL.WebGLUtils;\n      var ShadingIRs = {};\n      ShadingIRs.RadialAxial = {\n        fromIR: function RadialAxial_fromIR(raw) {\n          var type = raw[1];\n          var colorStops = raw[2];\n          var p0 = raw[3];\n          var p1 = raw[4];\n          var r0 = raw[5];\n          var r1 = raw[6];\n          return {\n            type: 'Pattern',\n            getPattern: function RadialAxial_getPattern(ctx) {\n              var grad;\n              if (type === 'axial') {\n                grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n              } else if (type === 'radial') {\n                grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n              }\n              for (var i = 0, ii = colorStops.length; i < ii; ++i) {\n                var c = colorStops[i];\n                grad.addColorStop(c[0], c[1]);\n              }\n              return grad;\n            }\n          };\n        }\n      };\n      var createMeshCanvas = function createMeshCanvasClosure() {\n        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n          // Very basic Gouraud-shaded triangle rasterization algorithm.\n          var coords = context.coords,\n            colors = context.colors;\n          var bytes = data.data,\n            rowSize = data.width * 4;\n          var tmp;\n          if (coords[p1 + 1] > coords[p2 + 1]) {\n            tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n            tmp = c1;\n            c1 = c2;\n            c2 = tmp;\n          }\n          if (coords[p2 + 1] > coords[p3 + 1]) {\n            tmp = p2;\n            p2 = p3;\n            p3 = tmp;\n            tmp = c2;\n            c2 = c3;\n            c3 = tmp;\n          }\n          if (coords[p1 + 1] > coords[p2 + 1]) {\n            tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n            tmp = c1;\n            c1 = c2;\n            c2 = tmp;\n          }\n          var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n          var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n          var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n          var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n          var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n          var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n          if (y1 >= y3) {\n            return;\n          }\n          var c1r = colors[c1],\n            c1g = colors[c1 + 1],\n            c1b = colors[c1 + 2];\n          var c2r = colors[c2],\n            c2g = colors[c2 + 1],\n            c2b = colors[c2 + 2];\n          var c3r = colors[c3],\n            c3g = colors[c3 + 1],\n            c3b = colors[c3 + 2];\n          var minY = Math.round(y1),\n            maxY = Math.round(y3);\n          var xa, car, cag, cab;\n          var xb, cbr, cbg, cbb;\n          var k;\n          for (var y = minY; y <= maxY; y++) {\n            if (y < y2) {\n              k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);\n              xa = x1 - (x1 - x2) * k;\n              car = c1r - (c1r - c2r) * k;\n              cag = c1g - (c1g - c2g) * k;\n              cab = c1b - (c1b - c2b) * k;\n            } else {\n              k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);\n              xa = x2 - (x2 - x3) * k;\n              car = c2r - (c2r - c3r) * k;\n              cag = c2g - (c2g - c3g) * k;\n              cab = c2b - (c2b - c3b) * k;\n            }\n            k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);\n            xb = x1 - (x1 - x3) * k;\n            cbr = c1r - (c1r - c3r) * k;\n            cbg = c1g - (c1g - c3g) * k;\n            cbb = c1b - (c1b - c3b) * k;\n            var x1_ = Math.round(Math.min(xa, xb));\n            var x2_ = Math.round(Math.max(xa, xb));\n            var j = rowSize * y + x1_ * 4;\n            for (var x = x1_; x <= x2_; x++) {\n              k = (xa - x) / (xa - xb);\n              k = k < 0 ? 0 : k > 1 ? 1 : k;\n              bytes[j++] = car - (car - cbr) * k | 0;\n              bytes[j++] = cag - (cag - cbg) * k | 0;\n              bytes[j++] = cab - (cab - cbb) * k | 0;\n              bytes[j++] = 255;\n            }\n          }\n        }\n        function drawFigure(data, figure, context) {\n          var ps = figure.coords;\n          var cs = figure.colors;\n          var i, ii;\n          switch (figure.type) {\n            case 'lattice':\n              var verticesPerRow = figure.verticesPerRow;\n              var rows = Math.floor(ps.length / verticesPerRow) - 1;\n              var cols = verticesPerRow - 1;\n              for (i = 0; i < rows; i++) {\n                var q = i * verticesPerRow;\n                for (var j = 0; j < cols; j++, q++) {\n                  drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                  drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n              }\n              break;\n            case 'triangles':\n              for (i = 0, ii = ps.length; i < ii; i += 3) {\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n              }\n              break;\n            default:\n              error('illigal figure');\n              break;\n          }\n        }\n        function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases) {\n          // we will increase scale on some weird factor to let antialiasing take\n          // care of \"rough\" edges\n          var EXPECTED_SCALE = 1.1;\n          // MAX_PATTERN_SIZE is used to avoid OOM situation.\n          var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough\n          // We need to keep transparent border around our pattern for fill():\n          // createPattern with 'no-repeat' will bleed edges accross entire area.\n          var BORDER_SIZE = 2;\n          var offsetX = Math.floor(bounds[0]);\n          var offsetY = Math.floor(bounds[1]);\n          var boundsWidth = Math.ceil(bounds[2]) - offsetX;\n          var boundsHeight = Math.ceil(bounds[3]) - offsetY;\n          var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n          var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n          var scaleX = boundsWidth / width;\n          var scaleY = boundsHeight / height;\n          var context = {\n            coords: coords,\n            colors: colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n          };\n          var paddedWidth = width + BORDER_SIZE * 2;\n          var paddedHeight = height + BORDER_SIZE * 2;\n          var canvas, tmpCanvas, i, ii;\n          if (WebGLUtils.isEnabled) {\n            canvas = WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\n\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=972126\n            tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);\n            tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\n            canvas = tmpCanvas.canvas;\n          } else {\n            tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);\n            var tmpCtx = tmpCanvas.context;\n            var data = tmpCtx.createImageData(width, height);\n            if (backgroundColor) {\n              var bytes = data.data;\n              for (i = 0, ii = bytes.length; i < ii; i += 4) {\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n              }\n            }\n            for (i = 0; i < figures.length; i++) {\n              drawFigure(data, figures[i], context);\n            }\n            tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n            canvas = tmpCanvas.canvas;\n          }\n          return {\n            canvas: canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX: scaleX,\n            scaleY: scaleY\n          };\n        }\n        return createMeshCanvas;\n      }();\n      ShadingIRs.Mesh = {\n        fromIR: function Mesh_fromIR(raw) {\n          //var type = raw[1];\n          var coords = raw[2];\n          var colors = raw[3];\n          var figures = raw[4];\n          var bounds = raw[5];\n          var matrix = raw[6];\n          //var bbox = raw[7];\n          var background = raw[8];\n          return {\n            type: 'Pattern',\n            getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n              var scale;\n              if (shadingFill) {\n                scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n              } else {\n                // Obtain scale from matrix and current transformation matrix.\n                scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n                if (matrix) {\n                  var matrixScale = Util.singularValueDecompose2dScale(matrix);\n                  scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n                }\n              }\n\n              // Rasterizing on the main thread since sending/queue large canvases\n              // might cause OOM.\n              var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases);\n              if (!shadingFill) {\n                ctx.setTransform.apply(ctx, owner.baseTransform);\n                if (matrix) {\n                  ctx.transform.apply(ctx, matrix);\n                }\n              }\n              ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n              ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n              return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');\n            }\n          };\n        }\n      };\n      ShadingIRs.Dummy = {\n        fromIR: function Dummy_fromIR() {\n          return {\n            type: 'Pattern',\n            getPattern: function Dummy_fromIR_getPattern() {\n              return 'hotpink';\n            }\n          };\n        }\n      };\n      function getShadingPatternFromIR(raw) {\n        var shadingIR = ShadingIRs[raw[0]];\n        if (!shadingIR) {\n          error('Unknown IR type: ' + raw[0]);\n        }\n        return shadingIR.fromIR(raw);\n      }\n      var TilingPattern = function TilingPatternClosure() {\n        var PaintType = {\n          COLORED: 1,\n          UNCOLORED: 2\n        };\n        var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough\n\n        function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n          this.operatorList = IR[2];\n          this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n          this.bbox = IR[4];\n          this.xstep = IR[5];\n          this.ystep = IR[6];\n          this.paintType = IR[7];\n          this.tilingType = IR[8];\n          this.color = color;\n          this.canvasGraphicsFactory = canvasGraphicsFactory;\n          this.baseTransform = baseTransform;\n          this.type = 'Pattern';\n          this.ctx = ctx;\n        }\n        TilingPattern.prototype = {\n          createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n            var operatorList = this.operatorList;\n            var bbox = this.bbox;\n            var xstep = this.xstep;\n            var ystep = this.ystep;\n            var paintType = this.paintType;\n            var tilingType = this.tilingType;\n            var color = this.color;\n            var canvasGraphicsFactory = this.canvasGraphicsFactory;\n            info('TilingType: ' + tilingType);\n            var x0 = bbox[0],\n              y0 = bbox[1],\n              x1 = bbox[2],\n              y1 = bbox[3];\n            var topLeft = [x0, y0];\n            // we want the canvas to be as large as the step size\n            var botRight = [x0 + xstep, y0 + ystep];\n            var width = botRight[0] - topLeft[0];\n            var height = botRight[1] - topLeft[1];\n\n            // Obtain scale from matrix and current transformation matrix.\n            var matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n            var curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);\n            var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n\n            // MAX_PATTERN_SIZE is used to avoid OOM situation.\n            // Use width and height values that are as close as possible to the end\n            // result when the pattern is used. Too low value makes the pattern look\n            // blurry. Too large value makes it look too crispy.\n            width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);\n            height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);\n            var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);\n            var tmpCtx = tmpCanvas.context;\n            var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n            graphics.groupLevel = owner.groupLevel;\n            this.setFillAndStrokeStyleToContext(tmpCtx, paintType, color);\n            this.setScale(width, height, xstep, ystep);\n            this.transformToScale(graphics);\n\n            // transform coordinates to pattern space\n            var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];\n            graphics.transform.apply(graphics, tmpTranslate);\n            this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n            graphics.executeOperatorList(operatorList);\n            return tmpCanvas.canvas;\n          },\n          setScale: function TilingPattern_setScale(width, height, xstep, ystep) {\n            this.scale = [width / xstep, height / ystep];\n          },\n          transformToScale: function TilingPattern_transformToScale(graphics) {\n            var scale = this.scale;\n            var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];\n            graphics.transform.apply(graphics, tmpScale);\n          },\n          scaleToContext: function TilingPattern_scaleToContext() {\n            var scale = this.scale;\n            this.ctx.scale(1 / scale[0], 1 / scale[1]);\n          },\n          clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n            if (bbox && isArray(bbox) && bbox.length === 4) {\n              var bboxWidth = x1 - x0;\n              var bboxHeight = y1 - y0;\n              graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n              graphics.clip();\n              graphics.endPath();\n            }\n          },\n          setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(context, paintType, color) {\n            switch (paintType) {\n              case PaintType.COLORED:\n                var ctx = this.ctx;\n                context.fillStyle = ctx.fillStyle;\n                context.strokeStyle = ctx.strokeStyle;\n                break;\n              case PaintType.UNCOLORED:\n                var cssColor = Util.makeCssRgb(color[0], color[1], color[2]);\n                context.fillStyle = cssColor;\n                context.strokeStyle = cssColor;\n                break;\n              default:\n                error('Unsupported paint type: ' + paintType);\n            }\n          },\n          getPattern: function TilingPattern_getPattern(ctx, owner) {\n            var temporaryPatternCanvas = this.createPatternCanvas(owner);\n            ctx = this.ctx;\n            ctx.setTransform.apply(ctx, this.baseTransform);\n            ctx.transform.apply(ctx, this.matrix);\n            this.scaleToContext();\n            return ctx.createPattern(temporaryPatternCanvas, 'repeat');\n          }\n        };\n        return TilingPattern;\n      }();\n      exports.getShadingPatternFromIR = getShadingPatternFromIR;\n      exports.TilingPattern = TilingPattern;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayCanvas = {}, root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils, root.pdfjsDisplayPatternHelper, root.pdfjsDisplayWebGL);\n      }\n    })(this, function (exports, sharedUtil, displayDOMUtils, displayPatternHelper, displayWebGL) {\n      var FONT_IDENTITY_MATRIX = sharedUtil.FONT_IDENTITY_MATRIX;\n      var IDENTITY_MATRIX = sharedUtil.IDENTITY_MATRIX;\n      var ImageKind = sharedUtil.ImageKind;\n      var OPS = sharedUtil.OPS;\n      var TextRenderingMode = sharedUtil.TextRenderingMode;\n      var Uint32ArrayView = sharedUtil.Uint32ArrayView;\n      var Util = sharedUtil.Util;\n      var assert = sharedUtil.assert;\n      var info = sharedUtil.info;\n      var isNum = sharedUtil.isNum;\n      var isArray = sharedUtil.isArray;\n      var isLittleEndian = sharedUtil.isLittleEndian;\n      var error = sharedUtil.error;\n      var shadow = sharedUtil.shadow;\n      var warn = sharedUtil.warn;\n      var TilingPattern = displayPatternHelper.TilingPattern;\n      var getShadingPatternFromIR = displayPatternHelper.getShadingPatternFromIR;\n      var WebGLUtils = displayWebGL.WebGLUtils;\n      var hasCanvasTypedArrays = displayDOMUtils.hasCanvasTypedArrays;\n\n      // <canvas> contexts store most of the state we need natively.\n      // However, PDF needs a bit more state, which we store here.\n\n      // Minimal font size that would be used during canvas fillText operations.\n      var MIN_FONT_SIZE = 16;\n      // Maximum font size that would be used during canvas fillText operations.\n      var MAX_FONT_SIZE = 100;\n      var MAX_GROUP_SIZE = 4096;\n\n      // Heuristic value used when enforcing minimum line widths.\n      var MIN_WIDTH_FACTOR = 0.65;\n      var COMPILE_TYPE3_GLYPHS = true;\n      var MAX_SIZE_TO_COMPILE = 1000;\n      var FULL_CHUNK_HEIGHT = 16;\n      var HasCanvasTypedArraysCached = {\n        get value() {\n          return shadow(HasCanvasTypedArraysCached, 'value', hasCanvasTypedArrays());\n        }\n      };\n      var IsLittleEndianCached = {\n        get value() {\n          return shadow(IsLittleEndianCached, 'value', isLittleEndian());\n        }\n      };\n      function createScratchCanvas(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n      }\n      function addContextCurrentTransform(ctx) {\n        // If the context doesn't expose a `mozCurrentTransform`, add a JS based one.\n        if (!ctx.mozCurrentTransform) {\n          ctx._originalSave = ctx.save;\n          ctx._originalRestore = ctx.restore;\n          ctx._originalRotate = ctx.rotate;\n          ctx._originalScale = ctx.scale;\n          ctx._originalTranslate = ctx.translate;\n          ctx._originalTransform = ctx.transform;\n          ctx._originalSetTransform = ctx.setTransform;\n          ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n          ctx._transformStack = [];\n          Object.defineProperty(ctx, 'mozCurrentTransform', {\n            get: function getCurrentTransform() {\n              return this._transformMatrix;\n            }\n          });\n          Object.defineProperty(ctx, 'mozCurrentTransformInverse', {\n            get: function getCurrentTransformInverse() {\n              // Calculation done using WolframAlpha:\n              // http://www.wolframalpha.com/input/?\n              //   i=Inverse+{{a%2C+c%2C+e}%2C+{b%2C+d%2C+f}%2C+{0%2C+0%2C+1}}\n\n              var m = this._transformMatrix;\n              var a = m[0],\n                b = m[1],\n                c = m[2],\n                d = m[3],\n                e = m[4],\n                f = m[5];\n              var ad_bc = a * d - b * c;\n              var bc_ad = b * c - a * d;\n              return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n            }\n          });\n          ctx.save = function ctxSave() {\n            var old = this._transformMatrix;\n            this._transformStack.push(old);\n            this._transformMatrix = old.slice(0, 6);\n            this._originalSave();\n          };\n          ctx.restore = function ctxRestore() {\n            var prev = this._transformStack.pop();\n            if (prev) {\n              this._transformMatrix = prev;\n              this._originalRestore();\n            }\n          };\n          ctx.translate = function ctxTranslate(x, y) {\n            var m = this._transformMatrix;\n            m[4] = m[0] * x + m[2] * y + m[4];\n            m[5] = m[1] * x + m[3] * y + m[5];\n            this._originalTranslate(x, y);\n          };\n          ctx.scale = function ctxScale(x, y) {\n            var m = this._transformMatrix;\n            m[0] = m[0] * x;\n            m[1] = m[1] * x;\n            m[2] = m[2] * y;\n            m[3] = m[3] * y;\n            this._originalScale(x, y);\n          };\n          ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n            var m = this._transformMatrix;\n            this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n            ctx._originalTransform(a, b, c, d, e, f);\n          };\n          ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n            this._transformMatrix = [a, b, c, d, e, f];\n            ctx._originalSetTransform(a, b, c, d, e, f);\n          };\n          ctx.rotate = function ctxRotate(angle) {\n            var cosValue = Math.cos(angle);\n            var sinValue = Math.sin(angle);\n            var m = this._transformMatrix;\n            this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n            this._originalRotate(angle);\n          };\n        }\n      }\n      var CachedCanvases = function CachedCanvasesClosure() {\n        function CachedCanvases() {\n          this.cache = Object.create(null);\n        }\n        CachedCanvases.prototype = {\n          getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\n            var canvasEntry;\n            if (this.cache[id] !== undefined) {\n              canvasEntry = this.cache[id];\n              canvasEntry.canvas.width = width;\n              canvasEntry.canvas.height = height;\n              // reset canvas transform for emulated mozCurrentTransform, if needed\n              canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n            } else {\n              var canvas = createScratchCanvas(width, height);\n              var ctx = canvas.getContext('2d');\n              if (trackTransform) {\n                addContextCurrentTransform(ctx);\n              }\n              this.cache[id] = canvasEntry = {\n                canvas: canvas,\n                context: ctx\n              };\n            }\n            return canvasEntry;\n          },\n          clear: function clear() {\n            for (var id in this.cache) {\n              var canvasEntry = this.cache[id];\n              // Zeroing the width and height causes Firefox to release graphics\n              // resources immediately, which can greatly reduce memory consumption.\n              canvasEntry.canvas.width = 0;\n              canvasEntry.canvas.height = 0;\n              delete this.cache[id];\n            }\n          }\n        };\n        return CachedCanvases;\n      }();\n      function compileType3Glyph(imgData) {\n        var POINT_TO_PROCESS_LIMIT = 1000;\n        var width = imgData.width,\n          height = imgData.height;\n        var i,\n          j,\n          j0,\n          width1 = width + 1;\n        var points = new Uint8Array(width1 * (height + 1));\n        var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n\n        // decodes bit-packed mask data\n        var lineSize = width + 7 & ~7,\n          data0 = imgData.data;\n        var data = new Uint8Array(lineSize * height),\n          pos = 0,\n          ii;\n        for (i = 0, ii = data0.length; i < ii; i++) {\n          var mask = 128,\n            elem = data0[i];\n          while (mask > 0) {\n            data[pos++] = elem & mask ? 0 : 255;\n            mask >>= 1;\n          }\n        }\n\n        // finding iteresting points: every point is located between mask pixels,\n        // so there will be points of the (width + 1)x(height + 1) grid. Every point\n        // will have flags assigned based on neighboring mask pixels:\n        //   4 | 8\n        //   --P--\n        //   2 | 1\n        // We are interested only in points with the flags:\n        //   - outside corners: 1, 2, 4, 8;\n        //   - inside corners: 7, 11, 13, 14;\n        //   - and, intersections: 5, 10.\n        var count = 0;\n        pos = 0;\n        if (data[pos] !== 0) {\n          points[0] = 1;\n          ++count;\n        }\n        for (j = 1; j < width; j++) {\n          if (data[pos] !== data[pos + 1]) {\n            points[j] = data[pos] ? 2 : 1;\n            ++count;\n          }\n          pos++;\n        }\n        if (data[pos] !== 0) {\n          points[j] = 2;\n          ++count;\n        }\n        for (i = 1; i < height; i++) {\n          pos = i * lineSize;\n          j0 = i * width1;\n          if (data[pos - lineSize] !== data[pos]) {\n            points[j0] = data[pos] ? 1 : 8;\n            ++count;\n          }\n          // 'sum' is the position of the current pixel configuration in the 'TYPES'\n          // array (in order 8-1-2-4, so we can use '>>2' to shift the column).\n          var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n          for (j = 1; j < width; j++) {\n            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n            if (POINT_TYPES[sum]) {\n              points[j0 + j] = POINT_TYPES[sum];\n              ++count;\n            }\n            pos++;\n          }\n          if (data[pos - lineSize] !== data[pos]) {\n            points[j0 + j] = data[pos] ? 2 : 4;\n            ++count;\n          }\n          if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n          }\n        }\n        pos = lineSize * (height - 1);\n        j0 = i * width1;\n        if (data[pos] !== 0) {\n          points[j0] = 8;\n          ++count;\n        }\n        for (j = 1; j < width; j++) {\n          if (data[pos] !== data[pos + 1]) {\n            points[j0 + j] = data[pos] ? 4 : 8;\n            ++count;\n          }\n          pos++;\n        }\n        if (data[pos] !== 0) {\n          points[j0 + j] = 4;\n          ++count;\n        }\n        if (count > POINT_TO_PROCESS_LIMIT) {\n          return null;\n        }\n\n        // building outlines\n        var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n        var outlines = [];\n        for (i = 0; count && i <= height; i++) {\n          var p = i * width1;\n          var end = p + width;\n          while (p < end && !points[p]) {\n            p++;\n          }\n          if (p === end) {\n            continue;\n          }\n          var coords = [p % width1, i];\n          var type = points[p],\n            p0 = p,\n            pp;\n          do {\n            var step = steps[type];\n            do {\n              p += step;\n            } while (!points[p]);\n            pp = points[p];\n            if (pp !== 5 && pp !== 10) {\n              // set new direction\n              type = pp;\n              // delete mark\n              points[p] = 0;\n            } else {\n              // type is 5 or 10, ie, a crossing\n              // set new direction\n              type = pp & 0x33 * type >> 4;\n              // set new type for \"future hit\"\n              points[p] &= type >> 2 | type << 2;\n            }\n            coords.push(p % width1);\n            coords.push(p / width1 | 0);\n            --count;\n          } while (p0 !== p);\n          outlines.push(coords);\n          --i;\n        }\n        var drawOutline = function drawOutline(c) {\n          c.save();\n          // the path shall be painted in [0..1]x[0..1] space\n          c.scale(1 / width, -1 / height);\n          c.translate(0, -height);\n          c.beginPath();\n          for (var i = 0, ii = outlines.length; i < ii; i++) {\n            var o = outlines[i];\n            c.moveTo(o[0], o[1]);\n            for (var j = 2, jj = o.length; j < jj; j += 2) {\n              c.lineTo(o[j], o[j + 1]);\n            }\n          }\n          c.fill();\n          c.beginPath();\n          c.restore();\n        };\n        return drawOutline;\n      }\n      var CanvasExtraState = function CanvasExtraStateClosure() {\n        function CanvasExtraState(old) {\n          // Are soft masks and alpha values shapes or opacities?\n          this.alphaIsShape = false;\n          this.fontSize = 0;\n          this.fontSizeScale = 1;\n          this.textMatrix = IDENTITY_MATRIX;\n          this.textMatrixScale = 1;\n          this.fontMatrix = FONT_IDENTITY_MATRIX;\n          this.leading = 0;\n          // Current point (in user coordinates)\n          this.x = 0;\n          this.y = 0;\n          // Start of text line (in text coordinates)\n          this.lineX = 0;\n          this.lineY = 0;\n          // Character and word spacing\n          this.charSpacing = 0;\n          this.wordSpacing = 0;\n          this.textHScale = 1;\n          this.textRenderingMode = TextRenderingMode.FILL;\n          this.textRise = 0;\n          // Default fore and background colors\n          this.fillColor = '#000000';\n          this.strokeColor = '#000000';\n          this.patternFill = false;\n          // Note: fill alpha applies to all non-stroking operations\n          this.fillAlpha = 1;\n          this.strokeAlpha = 1;\n          this.lineWidth = 1;\n          this.activeSMask = null;\n          this.resumeSMaskCtx = null; // nonclonable field (see the save method below)\n\n          this.old = old;\n        }\n        CanvasExtraState.prototype = {\n          clone: function CanvasExtraState_clone() {\n            return Object.create(this);\n          },\n          setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n            this.x = x;\n            this.y = y;\n          }\n        };\n        return CanvasExtraState;\n      }();\n      var CanvasGraphics = function CanvasGraphicsClosure() {\n        // Defines the time the executeOperatorList is going to be executing\n        // before it stops and shedules a continue of execution.\n        var EXECUTION_TIME = 15;\n        // Defines the number of steps before checking the execution time\n        var EXECUTION_STEPS = 10;\n        function CanvasGraphics(canvasCtx, commonObjs, objs, imageLayer) {\n          this.ctx = canvasCtx;\n          this.current = new CanvasExtraState();\n          this.stateStack = [];\n          this.pendingClip = null;\n          this.pendingEOFill = false;\n          this.res = null;\n          this.xobjs = null;\n          this.commonObjs = commonObjs;\n          this.objs = objs;\n          this.imageLayer = imageLayer;\n          this.groupStack = [];\n          this.processingType3 = null;\n          // Patterns are painted relative to the initial page/form transform, see pdf\n          // spec 8.7.2 NOTE 1.\n          this.baseTransform = null;\n          this.baseTransformStack = [];\n          this.groupLevel = 0;\n          this.smaskStack = [];\n          this.smaskCounter = 0;\n          this.tempSMask = null;\n          this.cachedCanvases = new CachedCanvases();\n          if (canvasCtx) {\n            // NOTE: if mozCurrentTransform is polyfilled, then the current state of\n            // the transformation must already be set in canvasCtx._transformMatrix.\n            addContextCurrentTransform(canvasCtx);\n          }\n          this.cachedGetSinglePixelWidth = null;\n        }\n        function putBinaryImageData(ctx, imgData) {\n          if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {\n            ctx.putImageData(imgData, 0, 0);\n            return;\n          }\n\n          // Put the image data to the canvas in chunks, rather than putting the\n          // whole image at once.  This saves JS memory, because the ImageData object\n          // is smaller. It also possibly saves C++ memory within the implementation\n          // of putImageData(). (E.g. in Firefox we make two short-lived copies of\n          // the data passed to putImageData()). |n| shouldn't be too small, however,\n          // because too many putImageData() calls will slow things down.\n          //\n          // Note: as written, if the last chunk is partial, the putImageData() call\n          // will (conceptually) put pixels past the bounds of the canvas.  But\n          // that's ok; any such pixels are ignored.\n\n          var height = imgData.height,\n            width = imgData.width;\n          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n          var srcPos = 0,\n            destPos;\n          var src = imgData.data;\n          var dest = chunkImgData.data;\n          var i, j, thisChunkHeight, elemsInThisChunk;\n\n          // There are multiple forms in which the pixel data can be passed, and\n          // imgData.kind tells us which one this is.\n          if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {\n            // Grayscale, 1 bit per pixel (i.e. black-and-white).\n            var srcLength = src.byteLength;\n            var dest32 = HasCanvasTypedArraysCached.value ? new Uint32Array(dest.buffer) : new Uint32ArrayView(dest);\n            var dest32DataLength = dest32.length;\n            var fullSrcDiff = width + 7 >> 3;\n            var white = 0xFFFFFFFF;\n            var black = IsLittleEndianCached.value || !HasCanvasTypedArraysCached.value ? 0xFF000000 : 0x000000FF;\n            for (i = 0; i < totalChunks; i++) {\n              thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n              destPos = 0;\n              for (j = 0; j < thisChunkHeight; j++) {\n                var srcDiff = srcLength - srcPos;\n                var k = 0;\n                var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                var kEndUnrolled = kEnd & ~7;\n                var mask = 0;\n                var srcByte = 0;\n                for (; k < kEndUnrolled; k += 8) {\n                  srcByte = src[srcPos++];\n                  dest32[destPos++] = srcByte & 128 ? white : black;\n                  dest32[destPos++] = srcByte & 64 ? white : black;\n                  dest32[destPos++] = srcByte & 32 ? white : black;\n                  dest32[destPos++] = srcByte & 16 ? white : black;\n                  dest32[destPos++] = srcByte & 8 ? white : black;\n                  dest32[destPos++] = srcByte & 4 ? white : black;\n                  dest32[destPos++] = srcByte & 2 ? white : black;\n                  dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for (; k < kEnd; k++) {\n                  if (mask === 0) {\n                    srcByte = src[srcPos++];\n                    mask = 128;\n                  }\n                  dest32[destPos++] = srcByte & mask ? white : black;\n                  mask >>= 1;\n                }\n              }\n              // We ran out of input. Make all remaining pixels transparent.\n              while (destPos < dest32DataLength) {\n                dest32[destPos++] = 0;\n              }\n              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n            }\n          } else if (imgData.kind === ImageKind.RGBA_32BPP) {\n            // RGBA, 32-bits per pixel.\n\n            j = 0;\n            elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n            for (i = 0; i < fullChunks; i++) {\n              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n              srcPos += elemsInThisChunk;\n              ctx.putImageData(chunkImgData, 0, j);\n              j += FULL_CHUNK_HEIGHT;\n            }\n            if (i < totalChunks) {\n              elemsInThisChunk = width * partialChunkHeight * 4;\n              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n              ctx.putImageData(chunkImgData, 0, j);\n            }\n          } else if (imgData.kind === ImageKind.RGB_24BPP) {\n            // RGB, 24-bits per pixel.\n            thisChunkHeight = FULL_CHUNK_HEIGHT;\n            elemsInThisChunk = width * thisChunkHeight;\n            for (i = 0; i < totalChunks; i++) {\n              if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n              }\n              destPos = 0;\n              for (j = elemsInThisChunk; j--;) {\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n              }\n              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n            }\n          } else {\n            error('bad image kind: ' + imgData.kind);\n          }\n        }\n        function putBinaryImageMask(ctx, imgData) {\n          var height = imgData.height,\n            width = imgData.width;\n          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n          var srcPos = 0;\n          var src = imgData.data;\n          var dest = chunkImgData.data;\n          for (var i = 0; i < totalChunks; i++) {\n            var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n\n            // Expand the mask so it can be used by the canvas.  Any required\n            // inversion has already been handled.\n            var destPos = 3; // alpha component offset\n            for (var j = 0; j < thisChunkHeight; j++) {\n              var mask = 0;\n              for (var k = 0; k < width; k++) {\n                if (!mask) {\n                  var elem = src[srcPos++];\n                  mask = 128;\n                }\n                dest[destPos] = elem & mask ? 0 : 255;\n                destPos += 4;\n                mask >>= 1;\n              }\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n          }\n        }\n        function copyCtxState(sourceCtx, destCtx) {\n          var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];\n          for (var i = 0, ii = properties.length; i < ii; i++) {\n            var property = properties[i];\n            if (sourceCtx[property] !== undefined) {\n              destCtx[property] = sourceCtx[property];\n            }\n          }\n          if (sourceCtx.setLineDash !== undefined) {\n            destCtx.setLineDash(sourceCtx.getLineDash());\n            destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n          } else if (sourceCtx.mozDashOffset !== undefined) {\n            destCtx.mozDash = sourceCtx.mozDash;\n            destCtx.mozDashOffset = sourceCtx.mozDashOffset;\n          }\n        }\n        function composeSMaskBackdrop(bytes, r0, g0, b0) {\n          var length = bytes.length;\n          for (var i = 3; i < length; i += 4) {\n            var alpha = bytes[i];\n            if (alpha === 0) {\n              bytes[i - 3] = r0;\n              bytes[i - 2] = g0;\n              bytes[i - 1] = b0;\n            } else if (alpha < 255) {\n              var alpha_ = 255 - alpha;\n              bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n              bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n              bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n            }\n          }\n        }\n        function composeSMaskAlpha(maskData, layerData, transferMap) {\n          var length = maskData.length;\n          var scale = 1 / 255;\n          for (var i = 3; i < length; i += 4) {\n            var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n            layerData[i] = layerData[i] * alpha * scale | 0;\n          }\n        }\n        function composeSMaskLuminosity(maskData, layerData, transferMap) {\n          var length = maskData.length;\n          for (var i = 3; i < length; i += 4) {\n            var y = maskData[i - 3] * 77 +\n            // * 0.3 / 255 * 0x10000\n            maskData[i - 2] * 152 +\n            // * 0.59 ....\n            maskData[i - 1] * 28; // * 0.11 ....\n            layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n          }\n        }\n        function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\n          var hasBackdrop = !!backdrop;\n          var r0 = hasBackdrop ? backdrop[0] : 0;\n          var g0 = hasBackdrop ? backdrop[1] : 0;\n          var b0 = hasBackdrop ? backdrop[2] : 0;\n          var composeFn;\n          if (subtype === 'Luminosity') {\n            composeFn = composeSMaskLuminosity;\n          } else {\n            composeFn = composeSMaskAlpha;\n          }\n\n          // processing image in chunks to save memory\n          var PIXELS_TO_PROCESS = 1048576;\n          var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n          for (var row = 0; row < height; row += chunkSize) {\n            var chunkHeight = Math.min(chunkSize, height - row);\n            var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n            var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n            if (hasBackdrop) {\n              composeSMaskBackdrop(maskData.data, r0, g0, b0);\n            }\n            composeFn(maskData.data, layerData.data, transferMap);\n            maskCtx.putImageData(layerData, 0, row);\n          }\n        }\n        function composeSMask(ctx, smask, layerCtx) {\n          var mask = smask.canvas;\n          var maskCtx = smask.context;\n          ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\n          var backdrop = smask.backdrop || null;\n          if (!smask.transferMap && WebGLUtils.isEnabled) {\n            var composed = WebGLUtils.composeSMask(layerCtx.canvas, mask, {\n              subtype: smask.subtype,\n              backdrop: backdrop\n            });\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n            return;\n          }\n          genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\n          ctx.drawImage(mask, 0, 0);\n        }\n        var LINE_CAP_STYLES = ['butt', 'round', 'square'];\n        var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\n        var NORMAL_CLIP = {};\n        var EO_CLIP = {};\n        CanvasGraphics.prototype = {\n          beginDrawing: function CanvasGraphics_beginDrawing(transform, viewport, transparency) {\n            // For pdfs that use blend modes we have to clear the canvas else certain\n            // blend modes can look wrong since we'd be blending with a white\n            // backdrop. The problem with a transparent backdrop though is we then\n            // don't get sub pixel anti aliasing on text, creating temporary\n            // transparent canvas when we have blend modes.\n            var width = this.ctx.canvas.width;\n            var height = this.ctx.canvas.height;\n            this.ctx.save();\n            this.ctx.fillStyle = 'rgb(255, 255, 255)';\n            this.ctx.fillRect(0, 0, width, height);\n            this.ctx.restore();\n            if (transparency) {\n              var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);\n              this.compositeCtx = this.ctx;\n              this.transparentCanvas = transparentCanvas.canvas;\n              this.ctx = transparentCanvas.context;\n              this.ctx.save();\n              // The transform can be applied before rendering, transferring it to\n              // the new canvas.\n              this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n            }\n            this.ctx.save();\n            if (transform) {\n              this.ctx.transform.apply(this.ctx, transform);\n            }\n            this.ctx.transform.apply(this.ctx, viewport.transform);\n            this.baseTransform = this.ctx.mozCurrentTransform.slice();\n            if (this.imageLayer) {\n              this.imageLayer.beginLayout();\n            }\n          },\n          executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n            var argsArray = operatorList.argsArray;\n            var fnArray = operatorList.fnArray;\n            var i = executionStartIdx || 0;\n            var argsArrayLen = argsArray.length;\n\n            // Sometimes the OperatorList to execute is empty.\n            if (argsArrayLen === i) {\n              return i;\n            }\n            var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function';\n            var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n            var steps = 0;\n            var commonObjs = this.commonObjs;\n            var objs = this.objs;\n            var fnId;\n            while (true) {\n              if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n              }\n              fnId = fnArray[i];\n              if (fnId !== OPS.dependency) {\n                this[fnId].apply(this, argsArray[i]);\n              } else {\n                var deps = argsArray[i];\n                for (var n = 0, nn = deps.length; n < nn; n++) {\n                  var depObjId = deps[n];\n                  var common = depObjId[0] === 'g' && depObjId[1] === '_';\n                  var objsPool = common ? commonObjs : objs;\n\n                  // If the promise isn't resolved yet, add the continueCallback\n                  // to the promise and bail out.\n                  if (!objsPool.isResolved(depObjId)) {\n                    objsPool.get(depObjId, continueCallback);\n                    return i;\n                  }\n                }\n              }\n              i++;\n\n              // If the entire operatorList was executed, stop as were done.\n              if (i === argsArrayLen) {\n                return i;\n              }\n\n              // If the execution took longer then a certain amount of time and\n              // `continueCallback` is specified, interrupt the execution.\n              if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                  continueCallback();\n                  return i;\n                }\n                steps = 0;\n              }\n\n              // If the operatorList isn't executed completely yet OR the execution\n              // time was short enough, do another execution round.\n            }\n          },\n          endDrawing: function CanvasGraphics_endDrawing() {\n            // Finishing all opened operations such as SMask group painting.\n            if (this.current.activeSMask !== null) {\n              this.endSMaskGroup();\n            }\n            this.ctx.restore();\n            if (this.transparentCanvas) {\n              this.ctx = this.compositeCtx;\n              this.ctx.save();\n              this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice\n              this.ctx.drawImage(this.transparentCanvas, 0, 0);\n              this.ctx.restore();\n              this.transparentCanvas = null;\n            }\n            this.cachedCanvases.clear();\n            WebGLUtils.clear();\n            if (this.imageLayer) {\n              this.imageLayer.endLayout();\n            }\n          },\n          // Graphics state\n          setLineWidth: function CanvasGraphics_setLineWidth(width) {\n            this.current.lineWidth = width;\n            this.ctx.lineWidth = width;\n          },\n          setLineCap: function CanvasGraphics_setLineCap(style) {\n            this.ctx.lineCap = LINE_CAP_STYLES[style];\n          },\n          setLineJoin: function CanvasGraphics_setLineJoin(style) {\n            this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n          },\n          setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n            this.ctx.miterLimit = limit;\n          },\n          setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n            var ctx = this.ctx;\n            if (ctx.setLineDash !== undefined) {\n              ctx.setLineDash(dashArray);\n              ctx.lineDashOffset = dashPhase;\n            } else {\n              ctx.mozDash = dashArray;\n              ctx.mozDashOffset = dashPhase;\n            }\n          },\n          setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {\n            // Maybe if we one day fully support color spaces this will be important\n            // for now we can ignore.\n            // TODO set rendering intent?\n          },\n          setFlatness: function CanvasGraphics_setFlatness(flatness) {\n            // There's no way to control this with canvas, but we can safely ignore.\n            // TODO set flatness?\n          },\n          setGState: function CanvasGraphics_setGState(states) {\n            for (var i = 0, ii = states.length; i < ii; i++) {\n              var state = states[i];\n              var key = state[0];\n              var value = state[1];\n              switch (key) {\n                case 'LW':\n                  this.setLineWidth(value);\n                  break;\n                case 'LC':\n                  this.setLineCap(value);\n                  break;\n                case 'LJ':\n                  this.setLineJoin(value);\n                  break;\n                case 'ML':\n                  this.setMiterLimit(value);\n                  break;\n                case 'D':\n                  this.setDash(value[0], value[1]);\n                  break;\n                case 'RI':\n                  this.setRenderingIntent(value);\n                  break;\n                case 'FL':\n                  this.setFlatness(value);\n                  break;\n                case 'Font':\n                  this.setFont(value[0], value[1]);\n                  break;\n                case 'CA':\n                  this.current.strokeAlpha = state[1];\n                  break;\n                case 'ca':\n                  this.current.fillAlpha = state[1];\n                  this.ctx.globalAlpha = state[1];\n                  break;\n                case 'BM':\n                  if (value && value.name && value.name !== 'Normal') {\n                    var mode = value.name.replace(/([A-Z])/g, function (c) {\n                      return '-' + c.toLowerCase();\n                    }).substring(1);\n                    this.ctx.globalCompositeOperation = mode;\n                    if (this.ctx.globalCompositeOperation !== mode) {\n                      warn('globalCompositeOperation \"' + mode + '\" is not supported');\n                    }\n                  } else {\n                    this.ctx.globalCompositeOperation = 'source-over';\n                  }\n                  break;\n                case 'SMask':\n                  if (this.current.activeSMask) {\n                    // If SMask is currrenly used, it needs to be suspended or\n                    // finished. Suspend only makes sense when at least one save()\n                    // was performed and state needs to be reverted on restore().\n                    if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\n                      this.suspendSMaskGroup();\n                    } else {\n                      this.endSMaskGroup();\n                    }\n                  }\n                  this.current.activeSMask = value ? this.tempSMask : null;\n                  if (this.current.activeSMask) {\n                    this.beginSMaskGroup();\n                  }\n                  this.tempSMask = null;\n                  break;\n              }\n            }\n          },\n          beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n            var activeSMask = this.current.activeSMask;\n            var drawnWidth = activeSMask.canvas.width;\n            var drawnHeight = activeSMask.canvas.height;\n            var cacheId = 'smaskGroupAt' + this.groupLevel;\n            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n            var currentCtx = this.ctx;\n            var currentTransform = currentCtx.mozCurrentTransform;\n            this.ctx.save();\n            var groupCtx = scratchCanvas.context;\n            groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n            groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n            groupCtx.transform.apply(groupCtx, currentTransform);\n            activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\n            copyCtxState(currentCtx, groupCtx);\n            this.ctx = groupCtx;\n            this.setGState([['BM', 'Normal'], ['ca', 1], ['CA', 1]]);\n            this.groupStack.push(currentCtx);\n            this.groupLevel++;\n          },\n          suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n            // Similar to endSMaskGroup, the intermediate canvas has to be composed\n            // and future ctx state restored.\n            var groupCtx = this.ctx;\n            this.groupLevel--;\n            this.ctx = this.groupStack.pop();\n            composeSMask(this.ctx, this.current.activeSMask, groupCtx);\n            this.ctx.restore();\n            this.ctx.save(); // save is needed since SMask will be resumed.\n            copyCtxState(groupCtx, this.ctx);\n\n            // Saving state for resuming.\n            this.current.resumeSMaskCtx = groupCtx;\n            // Transform was changed in the SMask canvas, reflecting this change on\n            // this.ctx.\n            var deltaTransform = Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n            this.ctx.transform.apply(this.ctx, deltaTransform);\n\n            // SMask was composed, the results at the groupCtx can be cleared.\n            groupCtx.save();\n            groupCtx.setTransform(1, 0, 0, 1, 0, 0);\n            groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\n            groupCtx.restore();\n          },\n          resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n            // Resuming state saved by suspendSMaskGroup. We don't need to restore\n            // any groupCtx state since restore() command (the only caller) will do\n            // that for us. See also beginSMaskGroup.\n            var groupCtx = this.current.resumeSMaskCtx;\n            var currentCtx = this.ctx;\n            this.ctx = groupCtx;\n            this.groupStack.push(currentCtx);\n            this.groupLevel++;\n          },\n          endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n            var groupCtx = this.ctx;\n            this.groupLevel--;\n            this.ctx = this.groupStack.pop();\n            composeSMask(this.ctx, this.current.activeSMask, groupCtx);\n            this.ctx.restore();\n            copyCtxState(groupCtx, this.ctx);\n            // Transform was changed in the SMask canvas, reflecting this change on\n            // this.ctx.\n            var deltaTransform = Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n            this.ctx.transform.apply(this.ctx, deltaTransform);\n          },\n          save: function CanvasGraphics_save() {\n            this.ctx.save();\n            var old = this.current;\n            this.stateStack.push(old);\n            this.current = old.clone();\n            this.current.resumeSMaskCtx = null;\n          },\n          restore: function CanvasGraphics_restore() {\n            // SMask was suspended, we just need to resume it.\n            if (this.current.resumeSMaskCtx) {\n              this.resumeSMaskGroup();\n            }\n            // SMask has to be finished once there is no states that are using the\n            // same SMask.\n            if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\n              this.endSMaskGroup();\n            }\n            if (this.stateStack.length !== 0) {\n              this.current = this.stateStack.pop();\n              this.ctx.restore();\n\n              // Ensure that the clipping path is reset (fixes issue6413.pdf).\n              this.pendingClip = null;\n              this.cachedGetSinglePixelWidth = null;\n            }\n          },\n          transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n            this.ctx.transform(a, b, c, d, e, f);\n            this.cachedGetSinglePixelWidth = null;\n          },\n          // Path\n          constructPath: function CanvasGraphics_constructPath(ops, args) {\n            var ctx = this.ctx;\n            var current = this.current;\n            var x = current.x,\n              y = current.y;\n            for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n              switch (ops[i] | 0) {\n                case OPS.rectangle:\n                  x = args[j++];\n                  y = args[j++];\n                  var width = args[j++];\n                  var height = args[j++];\n                  if (width === 0) {\n                    width = this.getSinglePixelWidth();\n                  }\n                  if (height === 0) {\n                    height = this.getSinglePixelWidth();\n                  }\n                  var xw = x + width;\n                  var yh = y + height;\n                  this.ctx.moveTo(x, y);\n                  this.ctx.lineTo(xw, y);\n                  this.ctx.lineTo(xw, yh);\n                  this.ctx.lineTo(x, yh);\n                  this.ctx.lineTo(x, y);\n                  this.ctx.closePath();\n                  break;\n                case OPS.moveTo:\n                  x = args[j++];\n                  y = args[j++];\n                  ctx.moveTo(x, y);\n                  break;\n                case OPS.lineTo:\n                  x = args[j++];\n                  y = args[j++];\n                  ctx.lineTo(x, y);\n                  break;\n                case OPS.curveTo:\n                  x = args[j + 4];\n                  y = args[j + 5];\n                  ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                  j += 6;\n                  break;\n                case OPS.curveTo2:\n                  ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  j += 4;\n                  break;\n                case OPS.curveTo3:\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                  j += 4;\n                  break;\n                case OPS.closePath:\n                  ctx.closePath();\n                  break;\n              }\n            }\n            current.setCurrentPoint(x, y);\n          },\n          closePath: function CanvasGraphics_closePath() {\n            this.ctx.closePath();\n          },\n          stroke: function CanvasGraphics_stroke(consumePath) {\n            consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\n            var ctx = this.ctx;\n            var strokeColor = this.current.strokeColor;\n            // Prevent drawing too thin lines by enforcing a minimum line width.\n            ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);\n            // For stroke we want to temporarily change the global alpha to the\n            // stroking alpha.\n            ctx.globalAlpha = this.current.strokeAlpha;\n            if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {\n              // for patterns, we transform to pattern space, calculate\n              // the pattern, call stroke, and restore to user space\n              ctx.save();\n              ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n              ctx.stroke();\n              ctx.restore();\n            } else {\n              ctx.stroke();\n            }\n            if (consumePath) {\n              this.consumePath();\n            }\n            // Restore the global alpha to the fill alpha\n            ctx.globalAlpha = this.current.fillAlpha;\n          },\n          closeStroke: function CanvasGraphics_closeStroke() {\n            this.closePath();\n            this.stroke();\n          },\n          fill: function CanvasGraphics_fill(consumePath) {\n            consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\n            var ctx = this.ctx;\n            var fillColor = this.current.fillColor;\n            var isPatternFill = this.current.patternFill;\n            var needRestore = false;\n            if (isPatternFill) {\n              ctx.save();\n              if (this.baseTransform) {\n                ctx.setTransform.apply(ctx, this.baseTransform);\n              }\n              ctx.fillStyle = fillColor.getPattern(ctx, this);\n              needRestore = true;\n            }\n            if (this.pendingEOFill) {\n              if (ctx.mozFillRule !== undefined) {\n                ctx.mozFillRule = 'evenodd';\n                ctx.fill();\n                ctx.mozFillRule = 'nonzero';\n              } else {\n                ctx.fill('evenodd');\n              }\n              this.pendingEOFill = false;\n            } else {\n              ctx.fill();\n            }\n            if (needRestore) {\n              ctx.restore();\n            }\n            if (consumePath) {\n              this.consumePath();\n            }\n          },\n          eoFill: function CanvasGraphics_eoFill() {\n            this.pendingEOFill = true;\n            this.fill();\n          },\n          fillStroke: function CanvasGraphics_fillStroke() {\n            this.fill(false);\n            this.stroke(false);\n            this.consumePath();\n          },\n          eoFillStroke: function CanvasGraphics_eoFillStroke() {\n            this.pendingEOFill = true;\n            this.fillStroke();\n          },\n          closeFillStroke: function CanvasGraphics_closeFillStroke() {\n            this.closePath();\n            this.fillStroke();\n          },\n          closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n            this.pendingEOFill = true;\n            this.closePath();\n            this.fillStroke();\n          },\n          endPath: function CanvasGraphics_endPath() {\n            this.consumePath();\n          },\n          // Clipping\n          clip: function CanvasGraphics_clip() {\n            this.pendingClip = NORMAL_CLIP;\n          },\n          eoClip: function CanvasGraphics_eoClip() {\n            this.pendingClip = EO_CLIP;\n          },\n          // Text\n          beginText: function CanvasGraphics_beginText() {\n            this.current.textMatrix = IDENTITY_MATRIX;\n            this.current.textMatrixScale = 1;\n            this.current.x = this.current.lineX = 0;\n            this.current.y = this.current.lineY = 0;\n          },\n          endText: function CanvasGraphics_endText() {\n            var paths = this.pendingTextPaths;\n            var ctx = this.ctx;\n            if (paths === undefined) {\n              ctx.beginPath();\n              return;\n            }\n            ctx.save();\n            ctx.beginPath();\n            for (var i = 0; i < paths.length; i++) {\n              var path = paths[i];\n              ctx.setTransform.apply(ctx, path.transform);\n              ctx.translate(path.x, path.y);\n              path.addToPath(ctx, path.fontSize);\n            }\n            ctx.restore();\n            ctx.clip();\n            ctx.beginPath();\n            delete this.pendingTextPaths;\n          },\n          setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n            this.current.charSpacing = spacing;\n          },\n          setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n            this.current.wordSpacing = spacing;\n          },\n          setHScale: function CanvasGraphics_setHScale(scale) {\n            this.current.textHScale = scale / 100;\n          },\n          setLeading: function CanvasGraphics_setLeading(leading) {\n            this.current.leading = -leading;\n          },\n          setFont: function CanvasGraphics_setFont(fontRefName, size) {\n            var fontObj = this.commonObjs.get(fontRefName);\n            var current = this.current;\n            if (!fontObj) {\n              error('Can\\'t find font for ' + fontRefName);\n            }\n            current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : FONT_IDENTITY_MATRIX;\n\n            // A valid matrix needs all main diagonal elements to be non-zero\n            // This also ensures we bypass FF bugzilla bug #719844.\n            if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n              warn('Invalid font matrix for font ' + fontRefName);\n            }\n\n            // The spec for Tf (setFont) says that 'size' specifies the font 'scale',\n            // and in some docs this can be negative (inverted x-y axes).\n            if (size < 0) {\n              size = -size;\n              current.fontDirection = -1;\n            } else {\n              current.fontDirection = 1;\n            }\n            this.current.font = fontObj;\n            this.current.fontSize = size;\n            if (fontObj.isType3Font) {\n              return; // we don't need ctx.font for Type3 fonts\n            }\n            var name = fontObj.loadedName || 'sans-serif';\n            var bold = fontObj.black ? fontObj.bold ? '900' : 'bold' : fontObj.bold ? 'bold' : 'normal';\n            var italic = fontObj.italic ? 'italic' : 'normal';\n            var typeface = '\"' + name + '\", ' + fontObj.fallbackName;\n\n            // Some font backends cannot handle fonts below certain size.\n            // Keeping the font at minimal size and using the fontSizeScale to change\n            // the current transformation matrix before the fillText/strokeText.\n            // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227\n            var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;\n            this.current.fontSizeScale = size / browserFontSize;\n            var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;\n            this.ctx.font = rule;\n          },\n          setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n            this.current.textRenderingMode = mode;\n          },\n          setTextRise: function CanvasGraphics_setTextRise(rise) {\n            this.current.textRise = rise;\n          },\n          moveText: function CanvasGraphics_moveText(x, y) {\n            this.current.x = this.current.lineX += x;\n            this.current.y = this.current.lineY += y;\n          },\n          setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n            this.setLeading(-y);\n            this.moveText(x, y);\n          },\n          setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n            this.current.textMatrix = [a, b, c, d, e, f];\n            this.current.textMatrixScale = Math.sqrt(a * a + b * b);\n            this.current.x = this.current.lineX = 0;\n            this.current.y = this.current.lineY = 0;\n          },\n          nextLine: function CanvasGraphics_nextLine() {\n            this.moveText(0, this.current.leading);\n          },\n          paintChar: function CanvasGraphics_paintChar(character, x, y) {\n            var ctx = this.ctx;\n            var current = this.current;\n            var font = current.font;\n            var textRenderingMode = current.textRenderingMode;\n            var fontSize = current.fontSize / current.fontSizeScale;\n            var fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            var isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n            var addToPath;\n            if (font.disableFontFace || isAddToPathSet) {\n              addToPath = font.getPathGenerator(this.commonObjs, character);\n            }\n            if (font.disableFontFace) {\n              ctx.save();\n              ctx.translate(x, y);\n              ctx.beginPath();\n              addToPath(ctx, fontSize);\n              if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fill();\n              }\n              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.stroke();\n              }\n              ctx.restore();\n            } else {\n              if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n              }\n              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.strokeText(character, x, y);\n              }\n            }\n            if (isAddToPathSet) {\n              var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n              paths.push({\n                transform: ctx.mozCurrentTransform,\n                x: x,\n                y: y,\n                fontSize: fontSize,\n                addToPath: addToPath\n              });\n            }\n          },\n          get isFontSubpixelAAEnabled() {\n            // Checks if anti-aliasing is enabled when scaled text is painted.\n            // On Windows GDI scaled fonts looks bad.\n            var ctx = document.createElement('canvas').getContext('2d');\n            ctx.scale(1.5, 1);\n            ctx.fillText('I', 0, 10);\n            var data = ctx.getImageData(0, 0, 10, 10).data;\n            var enabled = false;\n            for (var i = 3; i < data.length; i += 4) {\n              if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n              }\n            }\n            return shadow(this, 'isFontSubpixelAAEnabled', enabled);\n          },\n          showText: function CanvasGraphics_showText(glyphs) {\n            var current = this.current;\n            var font = current.font;\n            if (font.isType3Font) {\n              return this.showType3Text(glyphs);\n            }\n            var fontSize = current.fontSize;\n            if (fontSize === 0) {\n              return;\n            }\n            var ctx = this.ctx;\n            var fontSizeScale = current.fontSizeScale;\n            var charSpacing = current.charSpacing;\n            var wordSpacing = current.wordSpacing;\n            var fontDirection = current.fontDirection;\n            var textHScale = current.textHScale * fontDirection;\n            var glyphsLength = glyphs.length;\n            var vertical = font.vertical;\n            var spacingDir = vertical ? 1 : -1;\n            var defaultVMetrics = font.defaultVMetrics;\n            var widthAdvanceScale = fontSize * current.fontMatrix[0];\n            var simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace;\n            ctx.save();\n            ctx.transform.apply(ctx, current.textMatrix);\n            ctx.translate(current.x, current.y + current.textRise);\n            if (current.patternFill) {\n              // TODO: Some shading patterns are not applied correctly to text,\n              //       e.g. issues 3988 and 5432, and ShowText-ShadingPattern.pdf.\n              ctx.fillStyle = current.fillColor.getPattern(ctx, this);\n            }\n            if (fontDirection > 0) {\n              ctx.scale(textHScale, -1);\n            } else {\n              ctx.scale(textHScale, 1);\n            }\n            var lineWidth = current.lineWidth;\n            var scale = current.textMatrixScale;\n            if (scale === 0 || lineWidth === 0) {\n              var fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                this.cachedGetSinglePixelWidth = null;\n                lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;\n              }\n            } else {\n              lineWidth /= scale;\n            }\n            if (fontSizeScale !== 1.0) {\n              ctx.scale(fontSizeScale, fontSizeScale);\n              lineWidth /= fontSizeScale;\n            }\n            ctx.lineWidth = lineWidth;\n            var x = 0,\n              i;\n            for (i = 0; i < glyphsLength; ++i) {\n              var glyph = glyphs[i];\n              if (isNum(glyph)) {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n              }\n              var restoreNeeded = false;\n              var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n              var character = glyph.fontChar;\n              var accent = glyph.accent;\n              var scaledX, scaledY, scaledAccentX, scaledAccentY;\n              var width = glyph.width;\n              if (vertical) {\n                var vmetric, vx, vy;\n                vmetric = glyph.vmetric || defaultVMetrics;\n                vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n                vx = -vx * widthAdvanceScale;\n                vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n              } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n              }\n              if (font.remeasure && width > 0) {\n                // Some standard fonts may not have the exact width: rescale per\n                // character if measured width is greater than expected glyph width\n                // and subpixel-aa is enabled, otherwise just center the glyph.\n                var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                  var characterScaleX = width / measuredWidth;\n                  restoreNeeded = true;\n                  ctx.save();\n                  ctx.scale(characterScaleX, 1);\n                  scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                  scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n              }\n\n              // Only attempt to draw the glyph if it is actually in the embedded font\n              // file or if there isn't a font file so the fallback font is shown.\n              if (glyph.isInFont || font.missingFile) {\n                if (simpleFillText && !accent) {\n                  // common case\n                  ctx.fillText(character, scaledX, scaledY);\n                } else {\n                  this.paintChar(character, scaledX, scaledY);\n                  if (accent) {\n                    scaledAccentX = scaledX + accent.offset.x / fontSizeScale;\n                    scaledAccentY = scaledY - accent.offset.y / fontSizeScale;\n                    this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);\n                  }\n                }\n              }\n              var charWidth = width * widthAdvanceScale + spacing * fontDirection;\n              x += charWidth;\n              if (restoreNeeded) {\n                ctx.restore();\n              }\n            }\n            if (vertical) {\n              current.y -= x * textHScale;\n            } else {\n              current.x += x * textHScale;\n            }\n            ctx.restore();\n          },\n          showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n            // Type3 fonts - each glyph is a \"mini-PDF\"\n            var ctx = this.ctx;\n            var current = this.current;\n            var font = current.font;\n            var fontSize = current.fontSize;\n            var fontDirection = current.fontDirection;\n            var spacingDir = font.vertical ? 1 : -1;\n            var charSpacing = current.charSpacing;\n            var wordSpacing = current.wordSpacing;\n            var textHScale = current.textHScale * fontDirection;\n            var fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n            var glyphsLength = glyphs.length;\n            var isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n            var i, glyph, width, spacingLength;\n            if (isTextInvisible || fontSize === 0) {\n              return;\n            }\n            this.cachedGetSinglePixelWidth = null;\n            ctx.save();\n            ctx.transform.apply(ctx, current.textMatrix);\n            ctx.translate(current.x, current.y);\n            ctx.scale(textHScale, fontDirection);\n            for (i = 0; i < glyphsLength; ++i) {\n              glyph = glyphs[i];\n              if (isNum(glyph)) {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n              }\n              var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n              var operatorList = font.charProcOperatorList[glyph.operatorListId];\n              if (!operatorList) {\n                warn('Type3 character \\\"' + glyph.operatorListId + '\\\" is not available');\n                continue;\n              }\n              this.processingType3 = glyph;\n              this.save();\n              ctx.scale(fontSize, fontSize);\n              ctx.transform.apply(ctx, fontMatrix);\n              this.executeOperatorList(operatorList);\n              this.restore();\n              var transformed = Util.applyTransform([glyph.width, 0], fontMatrix);\n              width = transformed[0] * fontSize + spacing;\n              ctx.translate(width, 0);\n              current.x += width * textHScale;\n            }\n            ctx.restore();\n            this.processingType3 = null;\n          },\n          // Type3 fonts\n          setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {\n            // We can safely ignore this since the width should be the same\n            // as the width in the Widths array.\n          },\n          setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n            // TODO According to the spec we're also suppose to ignore any operators\n            // that set color or include images while processing this type3 font.\n            this.ctx.rect(llx, lly, urx - llx, ury - lly);\n            this.clip();\n            this.endPath();\n          },\n          // Color\n          getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n            var pattern;\n            if (IR[0] === 'TilingPattern') {\n              var color = IR[1];\n              var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n              var self = this;\n              var canvasGraphicsFactory = {\n                createCanvasGraphics: function createCanvasGraphics(ctx) {\n                  return new CanvasGraphics(ctx, self.commonObjs, self.objs);\n                }\n              };\n              pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n            } else {\n              pattern = getShadingPatternFromIR(IR);\n            }\n            return pattern;\n          },\n          setStrokeColorN: function CanvasGraphics_setStrokeColorN( /*...*/\n          ) {\n            this.current.strokeColor = this.getColorN_Pattern(arguments);\n          },\n          setFillColorN: function CanvasGraphics_setFillColorN( /*...*/\n          ) {\n            this.current.fillColor = this.getColorN_Pattern(arguments);\n            this.current.patternFill = true;\n          },\n          setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n            var color = Util.makeCssRgb(r, g, b);\n            this.ctx.strokeStyle = color;\n            this.current.strokeColor = color;\n          },\n          setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n            var color = Util.makeCssRgb(r, g, b);\n            this.ctx.fillStyle = color;\n            this.current.fillColor = color;\n            this.current.patternFill = false;\n          },\n          shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n            var ctx = this.ctx;\n            this.save();\n            var pattern = getShadingPatternFromIR(patternIR);\n            ctx.fillStyle = pattern.getPattern(ctx, this, true);\n            var inv = ctx.mozCurrentTransformInverse;\n            if (inv) {\n              var canvas = ctx.canvas;\n              var width = canvas.width;\n              var height = canvas.height;\n              var bl = Util.applyTransform([0, 0], inv);\n              var br = Util.applyTransform([0, height], inv);\n              var ul = Util.applyTransform([width, 0], inv);\n              var ur = Util.applyTransform([width, height], inv);\n              var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n              var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n              var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n              var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n              this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n            } else {\n              // HACK to draw the gradient onto an infinite rectangle.\n              // PDF gradients are drawn across the entire image while\n              // Canvas only allows gradients to be drawn in a rectangle\n              // The following bug should allow us to remove this.\n              // https://bugzilla.mozilla.org/show_bug.cgi?id=664884\n\n              this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n            }\n            this.restore();\n          },\n          // Images\n          beginInlineImage: function CanvasGraphics_beginInlineImage() {\n            error('Should not call beginInlineImage');\n          },\n          beginImageData: function CanvasGraphics_beginImageData() {\n            error('Should not call beginImageData');\n          },\n          paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\n            this.save();\n            this.baseTransformStack.push(this.baseTransform);\n            if (isArray(matrix) && 6 === matrix.length) {\n              this.transform.apply(this, matrix);\n            }\n            this.baseTransform = this.ctx.mozCurrentTransform;\n            if (isArray(bbox) && 4 === bbox.length) {\n              var width = bbox[2] - bbox[0];\n              var height = bbox[3] - bbox[1];\n              this.ctx.rect(bbox[0], bbox[1], width, height);\n              this.clip();\n              this.endPath();\n            }\n          },\n          paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n            this.restore();\n            this.baseTransform = this.baseTransformStack.pop();\n          },\n          beginGroup: function CanvasGraphics_beginGroup(group) {\n            this.save();\n            var currentCtx = this.ctx;\n            // TODO non-isolated groups - according to Rik at adobe non-isolated\n            // group results aren't usually that different and they even have tools\n            // that ignore this setting. Notes from Rik on implmenting:\n            // - When you encounter an transparency group, create a new canvas with\n            // the dimensions of the bbox\n            // - copy the content from the previous canvas to the new canvas\n            // - draw as usual\n            // - remove the backdrop alpha:\n            // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha\n            // value of your transparency group and 'alphaBackdrop' the alpha of the\n            // backdrop\n            // - remove background color:\n            // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)\n            if (!group.isolated) {\n              info('TODO: Support non-isolated groups.');\n            }\n\n            // TODO knockout - supposedly possible with the clever use of compositing\n            // modes.\n            if (group.knockout) {\n              warn('Knockout groups not supported.');\n            }\n            var currentTransform = currentCtx.mozCurrentTransform;\n            if (group.matrix) {\n              currentCtx.transform.apply(currentCtx, group.matrix);\n            }\n            assert(group.bbox, 'Bounding box is required.');\n\n            // Based on the current transform figure out how big the bounding box\n            // will actually be.\n            var bounds = Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n            // Clip the bounding box to the current canvas.\n            var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n            bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n            // Use ceil in case we're between sizes so we don't create canvas that is\n            // too small and make the canvas at least 1x1 pixels.\n            var offsetX = Math.floor(bounds[0]);\n            var offsetY = Math.floor(bounds[1]);\n            var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n            var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n            var scaleX = 1,\n              scaleY = 1;\n            if (drawnWidth > MAX_GROUP_SIZE) {\n              scaleX = drawnWidth / MAX_GROUP_SIZE;\n              drawnWidth = MAX_GROUP_SIZE;\n            }\n            if (drawnHeight > MAX_GROUP_SIZE) {\n              scaleY = drawnHeight / MAX_GROUP_SIZE;\n              drawnHeight = MAX_GROUP_SIZE;\n            }\n            var cacheId = 'groupAt' + this.groupLevel;\n            if (group.smask) {\n              // Using two cache entries is case if masks are used one after another.\n              cacheId += '_smask_' + this.smaskCounter++ % 2;\n            }\n            var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n            var groupCtx = scratchCanvas.context;\n\n            // Since we created a new canvas that is just the size of the bounding box\n            // we have to translate the group ctx.\n            groupCtx.scale(1 / scaleX, 1 / scaleY);\n            groupCtx.translate(-offsetX, -offsetY);\n            groupCtx.transform.apply(groupCtx, currentTransform);\n            if (group.smask) {\n              // Saving state and cached mask to be used in setGState.\n              this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX: offsetX,\n                offsetY: offsetY,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null // used during suspend operation\n              });\n            } else {\n              // Setup the current ctx so when the group is popped we draw it at the\n              // right location.\n              currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n              currentCtx.translate(offsetX, offsetY);\n              currentCtx.scale(scaleX, scaleY);\n            }\n            // The transparency group inherits all off the current graphics state\n            // except the blend mode, soft mask, and alpha constants.\n            copyCtxState(currentCtx, groupCtx);\n            this.ctx = groupCtx;\n            this.setGState([['BM', 'Normal'], ['ca', 1], ['CA', 1]]);\n            this.groupStack.push(currentCtx);\n            this.groupLevel++;\n\n            // Reseting mask state, masks will be applied on restore of the group.\n            this.current.activeSMask = null;\n          },\n          endGroup: function CanvasGraphics_endGroup(group) {\n            this.groupLevel--;\n            var groupCtx = this.ctx;\n            this.ctx = this.groupStack.pop();\n            // Turn off image smoothing to avoid sub pixel interpolation which can\n            // look kind of blurry for some pdfs.\n            if (this.ctx.imageSmoothingEnabled !== undefined) {\n              this.ctx.imageSmoothingEnabled = false;\n            } else {\n              this.ctx.mozImageSmoothingEnabled = false;\n            }\n            if (group.smask) {\n              this.tempSMask = this.smaskStack.pop();\n            } else {\n              this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            }\n            this.restore();\n          },\n          beginAnnotations: function CanvasGraphics_beginAnnotations() {\n            this.save();\n            this.current = new CanvasExtraState();\n            if (this.baseTransform) {\n              this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n            }\n          },\n          endAnnotations: function CanvasGraphics_endAnnotations() {\n            this.restore();\n          },\n          beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\n            this.save();\n            if (isArray(rect) && 4 === rect.length) {\n              var width = rect[2] - rect[0];\n              var height = rect[3] - rect[1];\n              this.ctx.rect(rect[0], rect[1], width, height);\n              this.clip();\n              this.endPath();\n            }\n            this.transform.apply(this, transform);\n            this.transform.apply(this, matrix);\n          },\n          endAnnotation: function CanvasGraphics_endAnnotation() {\n            this.restore();\n          },\n          paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {\n            var domImage = this.objs.get(objId);\n            if (!domImage) {\n              warn('Dependent image isn\\'t ready yet');\n              return;\n            }\n            this.save();\n            var ctx = this.ctx;\n            // scale the image to the unit square\n            ctx.scale(1 / w, -1 / h);\n            ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);\n            if (this.imageLayer) {\n              var currentTransform = ctx.mozCurrentTransformInverse;\n              var position = this.getCanvasPosition(0, 0);\n              this.imageLayer.appendImage({\n                objId: objId,\n                left: position[0],\n                top: position[1],\n                width: w / currentTransform[0],\n                height: h / currentTransform[3]\n              });\n            }\n            this.restore();\n          },\n          paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n            var ctx = this.ctx;\n            var width = img.width,\n              height = img.height;\n            var fillColor = this.current.fillColor;\n            var isPatternFill = this.current.patternFill;\n            var glyph = this.processingType3;\n            if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n              if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n                glyph.compiled = compileType3Glyph({\n                  data: img.data,\n                  width: width,\n                  height: height\n                });\n              } else {\n                glyph.compiled = null;\n              }\n            }\n            if (glyph && glyph.compiled) {\n              glyph.compiled(ctx);\n              return;\n            }\n            var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\n            var maskCtx = maskCanvas.context;\n            maskCtx.save();\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = 'source-in';\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            this.paintInlineImageXObject(maskCanvas.canvas);\n          },\n          paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {\n            var width = imgData.width;\n            var height = imgData.height;\n            var fillColor = this.current.fillColor;\n            var isPatternFill = this.current.patternFill;\n            var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\n            var maskCtx = maskCanvas.context;\n            maskCtx.save();\n            putBinaryImageMask(maskCtx, imgData);\n            maskCtx.globalCompositeOperation = 'source-in';\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            var ctx = this.ctx;\n            for (var i = 0, ii = positions.length; i < ii; i += 2) {\n              ctx.save();\n              ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);\n              ctx.scale(1, -1);\n              ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n              ctx.restore();\n            }\n          },\n          paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n            var ctx = this.ctx;\n            var fillColor = this.current.fillColor;\n            var isPatternFill = this.current.patternFill;\n            for (var i = 0, ii = images.length; i < ii; i++) {\n              var image = images[i];\n              var width = image.width,\n                height = image.height;\n              var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\n              var maskCtx = maskCanvas.context;\n              maskCtx.save();\n              putBinaryImageMask(maskCtx, image);\n              maskCtx.globalCompositeOperation = 'source-in';\n              maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n              maskCtx.fillRect(0, 0, width, height);\n              maskCtx.restore();\n              ctx.save();\n              ctx.transform.apply(ctx, image.transform);\n              ctx.scale(1, -1);\n              ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n              ctx.restore();\n            }\n          },\n          paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n            var imgData = this.objs.get(objId);\n            if (!imgData) {\n              warn('Dependent image isn\\'t ready yet');\n              return;\n            }\n            this.paintInlineImageXObject(imgData);\n          },\n          paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n            var imgData = this.objs.get(objId);\n            if (!imgData) {\n              warn('Dependent image isn\\'t ready yet');\n              return;\n            }\n            var width = imgData.width;\n            var height = imgData.height;\n            var map = [];\n            for (var i = 0, ii = positions.length; i < ii; i += 2) {\n              map.push({\n                transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n              });\n            }\n            this.paintInlineImageXObjectGroup(imgData, map);\n          },\n          paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\n            var width = imgData.width;\n            var height = imgData.height;\n            var ctx = this.ctx;\n            this.save();\n            // scale the image to the unit square\n            ctx.scale(1 / width, -1 / height);\n            var currentTransform = ctx.mozCurrentTransformInverse;\n            var a = currentTransform[0],\n              b = currentTransform[1];\n            var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\n            var c = currentTransform[2],\n              d = currentTransform[3];\n            var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\n            var imgToPaint, tmpCanvas;\n            // instanceof HTMLElement does not work in jsdom node.js module\n            if (imgData instanceof HTMLElement || !imgData.data) {\n              imgToPaint = imgData;\n            } else {\n              tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);\n              var tmpCtx = tmpCanvas.context;\n              putBinaryImageData(tmpCtx, imgData);\n              imgToPaint = tmpCanvas.canvas;\n            }\n            var paintWidth = width,\n              paintHeight = height;\n            var tmpCanvasId = 'prescale1';\n            // Vertial or horizontal scaling shall not be more than 2 to not loose the\n            // pixels during drawImage operation, painting on the temporary canvas(es)\n            // that are twice smaller in size\n            while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n              var newWidth = paintWidth,\n                newHeight = paintHeight;\n              if (widthScale > 2 && paintWidth > 1) {\n                newWidth = Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n              }\n              if (heightScale > 2 && paintHeight > 1) {\n                newHeight = Math.ceil(paintHeight / 2);\n                heightScale /= paintHeight / newHeight;\n              }\n              tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n              tmpCtx = tmpCanvas.context;\n              tmpCtx.clearRect(0, 0, newWidth, newHeight);\n              tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n              imgToPaint = tmpCanvas.canvas;\n              paintWidth = newWidth;\n              paintHeight = newHeight;\n              tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';\n            }\n            ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\n            if (this.imageLayer) {\n              var position = this.getCanvasPosition(0, -height);\n              this.imageLayer.appendImage({\n                imgData: imgData,\n                left: position[0],\n                top: position[1],\n                width: width / currentTransform[0],\n                height: height / currentTransform[3]\n              });\n            }\n            this.restore();\n          },\n          paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n            var ctx = this.ctx;\n            var w = imgData.width;\n            var h = imgData.height;\n            var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);\n            var tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            for (var i = 0, ii = map.length; i < ii; i++) {\n              var entry = map[i];\n              ctx.save();\n              ctx.transform.apply(ctx, entry.transform);\n              ctx.scale(1, -1);\n              ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n              if (this.imageLayer) {\n                var position = this.getCanvasPosition(entry.x, entry.y);\n                this.imageLayer.appendImage({\n                  imgData: imgData,\n                  left: position[0],\n                  top: position[1],\n                  width: w,\n                  height: h\n                });\n              }\n              ctx.restore();\n            }\n          },\n          paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\n            this.ctx.fillRect(0, 0, 1, 1);\n          },\n          paintXObject: function CanvasGraphics_paintXObject() {\n            warn('Unsupported \\'paintXObject\\' command.');\n          },\n          // Marked content\n\n          markPoint: function CanvasGraphics_markPoint(tag) {\n            // TODO Marked content.\n          },\n          markPointProps: function CanvasGraphics_markPointProps(tag, properties) {\n            // TODO Marked content.\n          },\n          beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n            // TODO Marked content.\n          },\n          beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\n            // TODO Marked content.\n          },\n          endMarkedContent: function CanvasGraphics_endMarkedContent() {\n            // TODO Marked content.\n          },\n          // Compatibility\n\n          beginCompat: function CanvasGraphics_beginCompat() {\n            // TODO ignore undefined operators (should we do that anyway?)\n          },\n          endCompat: function CanvasGraphics_endCompat() {\n            // TODO stop ignoring undefined operators\n          },\n          // Helper functions\n\n          consumePath: function CanvasGraphics_consumePath() {\n            var ctx = this.ctx;\n            if (this.pendingClip) {\n              if (this.pendingClip === EO_CLIP) {\n                if (ctx.mozFillRule !== undefined) {\n                  ctx.mozFillRule = 'evenodd';\n                  ctx.clip();\n                  ctx.mozFillRule = 'nonzero';\n                } else {\n                  ctx.clip('evenodd');\n                }\n              } else {\n                ctx.clip();\n              }\n              this.pendingClip = null;\n            }\n            ctx.beginPath();\n          },\n          getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {\n            if (this.cachedGetSinglePixelWidth === null) {\n              var inverse = this.ctx.mozCurrentTransformInverse;\n              // max of the current horizontal and vertical scale\n              this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));\n            }\n            return this.cachedGetSinglePixelWidth;\n          },\n          getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n            var transform = this.ctx.mozCurrentTransform;\n            return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n          }\n        };\n        for (var op in OPS) {\n          CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n        }\n        return CanvasGraphics;\n      }();\n      exports.CanvasGraphics = CanvasGraphics;\n      exports.createScratchCanvas = createScratchCanvas;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayAPI = {}, root.pdfjsSharedUtil, root.pdfjsDisplayFontLoader, root.pdfjsDisplayCanvas, root.pdfjsDisplayMetadata, root.pdfjsDisplayDOMUtils);\n      }\n    })(this, function (exports, sharedUtil, displayFontLoader, displayCanvas, displayMetadata, displayDOMUtils, amdRequire) {\n      var InvalidPDFException = sharedUtil.InvalidPDFException;\n      var MessageHandler = sharedUtil.MessageHandler;\n      var MissingPDFException = sharedUtil.MissingPDFException;\n      var PageViewport = sharedUtil.PageViewport;\n      var PasswordResponses = sharedUtil.PasswordResponses;\n      var PasswordException = sharedUtil.PasswordException;\n      var StatTimer = sharedUtil.StatTimer;\n      var UnexpectedResponseException = sharedUtil.UnexpectedResponseException;\n      var UnknownErrorException = sharedUtil.UnknownErrorException;\n      var Util = sharedUtil.Util;\n      var createPromiseCapability = sharedUtil.createPromiseCapability;\n      var error = sharedUtil.error;\n      var deprecated = sharedUtil.deprecated;\n      var getVerbosityLevel = sharedUtil.getVerbosityLevel;\n      var info = sharedUtil.info;\n      var isArrayBuffer = sharedUtil.isArrayBuffer;\n      var isSameOrigin = sharedUtil.isSameOrigin;\n      var loadJpegStream = sharedUtil.loadJpegStream;\n      var stringToBytes = sharedUtil.stringToBytes;\n      var globalScope = sharedUtil.globalScope;\n      var warn = sharedUtil.warn;\n      var FontFaceObject = displayFontLoader.FontFaceObject;\n      var FontLoader = displayFontLoader.FontLoader;\n      var CanvasGraphics = displayCanvas.CanvasGraphics;\n      var createScratchCanvas = displayCanvas.createScratchCanvas;\n      var Metadata = displayMetadata.Metadata;\n      var getDefaultSetting = displayDOMUtils.getDefaultSetting;\n      var DEFAULT_RANGE_CHUNK_SIZE = 65536; // 2^16 = 65536\n\n      var isWorkerDisabled = false;\n      var workerSrc;\n      var isPostMessageTransfersDisabled = false;\n      var useRequireEnsure = false;\n      if (typeof window === 'undefined') {\n        // node.js - disable worker and set require.ensure.\n        isWorkerDisabled = true;\n        if (typeof require.ensure === 'undefined') {\n          require.ensure = require('node-ensure');\n        }\n        useRequireEnsure = true;\n      }\n      if (typeof __webpack_require__ !== 'undefined') {\n        useRequireEnsure = true;\n      }\n      if (typeof requirejs !== 'undefined' && requirejs.toUrl) {\n        workerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');\n      }\n      var dynamicLoaderSupported = typeof requirejs !== 'undefined' && requirejs.load;\n      var fakeWorkerFilesLoader = useRequireEnsure ? function (callback) {\n        require.ensure([], function () {\n          var worker = require('./pdf.worker.js');\n          callback(worker.WorkerMessageHandler);\n        });\n      } : dynamicLoaderSupported ? function (callback) {\n        requirejs(['pdfjs-dist/build/pdf.worker'], function (worker) {\n          callback(worker.WorkerMessageHandler);\n        });\n      } : null;\n\n      /**\r\n       * Document initialization / loading parameters object.\r\n       *\r\n       * @typedef {Object} DocumentInitParameters\r\n       * @property {string}     url   - The URL of the PDF.\r\n       * @property {TypedArray|Array|string} data - Binary PDF data. Use typed arrays\r\n       *   (Uint8Array) to improve the memory usage. If PDF data is BASE64-encoded,\r\n       *   use atob() to convert it to a binary string first.\r\n       * @property {Object}     httpHeaders - Basic authentication headers.\r\n       * @property {boolean}    withCredentials - Indicates whether or not cross-site\r\n       *   Access-Control requests should be made using credentials such as cookies\r\n       *   or authorization headers. The default is false.\r\n       * @property {string}     password - For decrypting password-protected PDFs.\r\n       * @property {TypedArray} initialData - A typed array with the first portion or\r\n       *   all of the pdf data. Used by the extension since some data is already\r\n       *   loaded before the switch to range requests.\r\n       * @property {number}     length - The PDF file length. It's used for progress\r\n       *   reports and range requests operations.\r\n       * @property {PDFDataRangeTransport} range\r\n       * @property {number}     rangeChunkSize - Optional parameter to specify\r\n       *   maximum number of bytes fetched per range request. The default value is\r\n       *   2^16 = 65536.\r\n       * @property {PDFWorker}  worker - The worker that will be used for the loading\r\n       *   and parsing of the PDF data.\r\n       */\n\n      /**\r\n       * @typedef {Object} PDFDocumentStats\r\n       * @property {Array} streamTypes - Used stream types in the document (an item\r\n       *   is set to true if specific stream ID was used in the document).\r\n       * @property {Array} fontTypes - Used font type in the document (an item is set\r\n       *   to true if specific font ID was used in the document).\r\n       */\n\n      /**\r\n       * This is the main entry point for loading a PDF and interacting with it.\r\n       * NOTE: If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR)\r\n       * is used, which means it must follow the same origin rules that any XHR does\r\n       * e.g. No cross domain requests without CORS.\r\n       *\r\n       * @param {string|TypedArray|DocumentInitParameters|PDFDataRangeTransport} src\r\n       * Can be a url to where a PDF is located, a typed array (Uint8Array)\r\n       * already populated with data or parameter object.\r\n       *\r\n       * @param {PDFDataRangeTransport} pdfDataRangeTransport (deprecated) It is used\r\n       * if you want to manually serve range requests for data in the PDF.\r\n       *\r\n       * @param {function} passwordCallback (deprecated) It is used to request a\r\n       * password if wrong or no password was provided. The callback receives two\r\n       * parameters: function that needs to be called with new password and reason\r\n       * (see {PasswordResponses}).\r\n       *\r\n       * @param {function} progressCallback (deprecated) It is used to be able to\r\n       * monitor the loading progress of the PDF file (necessary to implement e.g.\r\n       * a loading bar). The callback receives an {Object} with the properties:\r\n       * {number} loaded and {number} total.\r\n       *\r\n       * @return {PDFDocumentLoadingTask}\r\n       */\n      function getDocument(src, pdfDataRangeTransport, passwordCallback, progressCallback) {\n        var task = new PDFDocumentLoadingTask();\n\n        // Support of the obsolete arguments (for compatibility with API v1.0)\n        if (arguments.length > 1) {\n          deprecated('getDocument is called with pdfDataRangeTransport, ' + 'passwordCallback or progressCallback argument');\n        }\n        if (pdfDataRangeTransport) {\n          if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {\n            // Not a PDFDataRangeTransport instance, trying to add missing properties.\n            pdfDataRangeTransport = Object.create(pdfDataRangeTransport);\n            pdfDataRangeTransport.length = src.length;\n            pdfDataRangeTransport.initialData = src.initialData;\n            if (!pdfDataRangeTransport.abort) {\n              pdfDataRangeTransport.abort = function () {};\n            }\n          }\n          src = Object.create(src);\n          src.range = pdfDataRangeTransport;\n        }\n        task.onPassword = passwordCallback || null;\n        task.onProgress = progressCallback || null;\n        var source;\n        if (typeof src === 'string') {\n          source = {\n            url: src\n          };\n        } else if (isArrayBuffer(src)) {\n          source = {\n            data: src\n          };\n        } else if (src instanceof PDFDataRangeTransport) {\n          source = {\n            range: src\n          };\n        } else {\n          if (typeof src !== 'object') {\n            error('Invalid parameter in getDocument, need either Uint8Array, ' + 'string or a parameter object');\n          }\n          if (!src.url && !src.data && !src.range) {\n            error('Invalid parameter object: need either .data, .range or .url');\n          }\n          source = src;\n        }\n        var params = {};\n        var rangeTransport = null;\n        var worker = null;\n        for (var key in source) {\n          if (key === 'url' && typeof window !== 'undefined') {\n            // The full path is required in the 'url' field.\n            params[key] = new URL(source[key], window.location).href;\n            continue;\n          } else if (key === 'range') {\n            rangeTransport = source[key];\n            continue;\n          } else if (key === 'worker') {\n            worker = source[key];\n            continue;\n          } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {\n            // Converting string or array-like data to Uint8Array.\n            var pdfBytes = source[key];\n            if (typeof pdfBytes === 'string') {\n              params[key] = stringToBytes(pdfBytes);\n            } else if (typeof pdfBytes === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {\n              params[key] = new Uint8Array(pdfBytes);\n            } else if (isArrayBuffer(pdfBytes)) {\n              params[key] = new Uint8Array(pdfBytes);\n            } else {\n              error('Invalid PDF binary data: either typed array, string or ' + 'array-like object is expected in the data property.');\n            }\n            continue;\n          }\n          params[key] = source[key];\n        }\n        params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n        if (!worker) {\n          // Worker was not provided -- creating and owning our own.\n          worker = new PDFWorker();\n          task._worker = worker;\n        }\n        var docId = task.docId;\n        worker.promise.then(function () {\n          if (task.destroyed) {\n            throw new Error('Loading aborted');\n          }\n          return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {\n            if (task.destroyed) {\n              throw new Error('Loading aborted');\n            }\n            var messageHandler = new MessageHandler(docId, workerId, worker.port);\n            var transport = new WorkerTransport(messageHandler, task, rangeTransport);\n            task._transport = transport;\n            messageHandler.send('Ready', null);\n          });\n        }).catch(task._capability.reject);\n        return task;\n      }\n\n      /**\r\n       * Starts fetching of specified PDF document/data.\r\n       * @param {PDFWorker} worker\r\n       * @param {Object} source\r\n       * @param {PDFDataRangeTransport} pdfDataRangeTransport\r\n       * @param {string} docId Unique document id, used as MessageHandler id.\r\n       * @returns {Promise} The promise, which is resolved when worker id of\r\n       *                    MessageHandler is known.\r\n       * @private\r\n       */\n      function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n        if (worker.destroyed) {\n          return Promise.reject(new Error('Worker was destroyed'));\n        }\n        source.disableAutoFetch = getDefaultSetting('disableAutoFetch');\n        source.disableStream = getDefaultSetting('disableStream');\n        source.chunkedViewerLoading = !!pdfDataRangeTransport;\n        if (pdfDataRangeTransport) {\n          source.length = pdfDataRangeTransport.length;\n          source.initialData = pdfDataRangeTransport.initialData;\n        }\n        return worker.messageHandler.sendWithPromise('GetDocRequest', {\n          docId: docId,\n          source: source,\n          disableRange: getDefaultSetting('disableRange'),\n          maxImageSize: getDefaultSetting('maxImageSize'),\n          cMapUrl: getDefaultSetting('cMapUrl'),\n          cMapPacked: getDefaultSetting('cMapPacked'),\n          disableFontFace: getDefaultSetting('disableFontFace'),\n          disableCreateObjectURL: getDefaultSetting('disableCreateObjectURL'),\n          postMessageTransfers: getDefaultSetting('postMessageTransfers') && !isPostMessageTransfersDisabled\n        }).then(function (workerId) {\n          if (worker.destroyed) {\n            throw new Error('Worker was destroyed');\n          }\n          return workerId;\n        });\n      }\n\n      /**\r\n       * PDF document loading operation.\r\n       * @class\r\n       * @alias PDFDocumentLoadingTask\r\n       */\n      var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\n        var nextDocumentId = 0;\n\n        /** @constructs PDFDocumentLoadingTask */\n        function PDFDocumentLoadingTask() {\n          this._capability = createPromiseCapability();\n          this._transport = null;\n          this._worker = null;\n\n          /**\r\n           * Unique document loading task id -- used in MessageHandlers.\r\n           * @type {string}\r\n           */\n          this.docId = 'd' + nextDocumentId++;\n\n          /**\r\n           * Shows if loading task is destroyed.\r\n           * @type {boolean}\r\n           */\n          this.destroyed = false;\n\n          /**\r\n           * Callback to request a password if wrong or no password was provided.\r\n           * The callback receives two parameters: function that needs to be called\r\n           * with new password and reason (see {PasswordResponses}).\r\n           */\n          this.onPassword = null;\n\n          /**\r\n           * Callback to be able to monitor the loading progress of the PDF file\r\n           * (necessary to implement e.g. a loading bar). The callback receives\r\n           * an {Object} with the properties: {number} loaded and {number} total.\r\n           */\n          this.onProgress = null;\n\n          /**\r\n           * Callback to when unsupported feature is used. The callback receives\r\n           * an {UNSUPPORTED_FEATURES} argument.\r\n           */\n          this.onUnsupportedFeature = null;\n        }\n        PDFDocumentLoadingTask.prototype = /** @lends PDFDocumentLoadingTask.prototype */{\n          /**\r\n           * @return {Promise}\r\n           */\n          get promise() {\n            return this._capability.promise;\n          },\n          /**\r\n           * Aborts all network requests and destroys worker.\r\n           * @return {Promise} A promise that is resolved after destruction activity\r\n           *                   is completed.\r\n           */\n          destroy: function destroy() {\n            this.destroyed = true;\n            var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\n            return transportDestroyed.then(function () {\n              this._transport = null;\n              if (this._worker) {\n                this._worker.destroy();\n                this._worker = null;\n              }\n            }.bind(this));\n          },\n          /**\r\n           * Registers callbacks to indicate the document loading completion.\r\n           *\r\n           * @param {function} onFulfilled The callback for the loading completion.\r\n           * @param {function} onRejected The callback for the loading failure.\r\n           * @return {Promise} A promise that is resolved after the onFulfilled or\r\n           *                   onRejected callback.\r\n           */\n          then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {\n            return this.promise.then.apply(this.promise, arguments);\n          }\n        };\n        return PDFDocumentLoadingTask;\n      }();\n\n      /**\r\n       * Abstract class to support range requests file loading.\r\n       * @class\r\n       * @alias PDFDataRangeTransport\r\n       * @param {number} length\r\n       * @param {Uint8Array} initialData\r\n       */\n      var PDFDataRangeTransport = function pdfDataRangeTransportClosure() {\n        function PDFDataRangeTransport(length, initialData) {\n          this.length = length;\n          this.initialData = initialData;\n          this._rangeListeners = [];\n          this._progressListeners = [];\n          this._progressiveReadListeners = [];\n          this._readyCapability = createPromiseCapability();\n        }\n        PDFDataRangeTransport.prototype = /** @lends PDFDataRangeTransport.prototype */{\n          addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {\n            this._rangeListeners.push(listener);\n          },\n          addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {\n            this._progressListeners.push(listener);\n          },\n          addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {\n            this._progressiveReadListeners.push(listener);\n          },\n          onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {\n            var listeners = this._rangeListeners;\n            for (var i = 0, n = listeners.length; i < n; ++i) {\n              listeners[i](begin, chunk);\n            }\n          },\n          onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {\n            this._readyCapability.promise.then(function () {\n              var listeners = this._progressListeners;\n              for (var i = 0, n = listeners.length; i < n; ++i) {\n                listeners[i](loaded);\n              }\n            }.bind(this));\n          },\n          onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {\n            this._readyCapability.promise.then(function () {\n              var listeners = this._progressiveReadListeners;\n              for (var i = 0, n = listeners.length; i < n; ++i) {\n                listeners[i](chunk);\n              }\n            }.bind(this));\n          },\n          transportReady: function PDFDataRangeTransport_transportReady() {\n            this._readyCapability.resolve();\n          },\n          requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {\n            throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');\n          },\n          abort: function PDFDataRangeTransport_abort() {}\n        };\n        return PDFDataRangeTransport;\n      }();\n\n      /**\r\n       * Proxy to a PDFDocument in the worker thread. Also, contains commonly used\r\n       * properties that can be read synchronously.\r\n       * @class\r\n       * @alias PDFDocumentProxy\r\n       */\n      var PDFDocumentProxy = function PDFDocumentProxyClosure() {\n        function PDFDocumentProxy(pdfInfo, transport, loadingTask) {\n          this.pdfInfo = pdfInfo;\n          this.transport = transport;\n          this.loadingTask = loadingTask;\n        }\n        PDFDocumentProxy.prototype = /** @lends PDFDocumentProxy.prototype */{\n          /**\r\n           * @return {number} Total number of pages the PDF contains.\r\n           */\n          get numPages() {\n            return this.pdfInfo.numPages;\n          },\n          /**\r\n           * @return {string} A unique ID to identify a PDF. Not guaranteed to be\r\n           * unique.\r\n           */\n          get fingerprint() {\n            return this.pdfInfo.fingerprint;\n          },\n          /**\r\n           * @param {number} pageNumber The page number to get. The first page is 1.\r\n           * @return {Promise} A promise that is resolved with a {@link PDFPageProxy}\r\n           * object.\r\n           */\n          getPage: function PDFDocumentProxy_getPage(pageNumber) {\n            return this.transport.getPage(pageNumber);\n          },\n          /**\r\n           * @param {{num: number, gen: number}} ref The page reference. Must have\r\n           *   the 'num' and 'gen' properties.\r\n           * @return {Promise} A promise that is resolved with the page index that is\r\n           * associated with the reference.\r\n           */\n          getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {\n            return this.transport.getPageIndex(ref);\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with a lookup table for\r\n           * mapping named destinations to reference numbers.\r\n           *\r\n           * This can be slow for large documents: use getDestination instead\r\n           */\n          getDestinations: function PDFDocumentProxy_getDestinations() {\n            return this.transport.getDestinations();\n          },\n          /**\r\n           * @param {string} id The named destination to get.\r\n           * @return {Promise} A promise that is resolved with all information\r\n           * of the given named destination.\r\n           */\n          getDestination: function PDFDocumentProxy_getDestination(id) {\n            return this.transport.getDestination(id);\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with:\r\n           *   an Array containing the pageLabels that correspond to the pageIndexes,\r\n           *   or `null` when no pageLabels are present in the PDF file.\r\n           */\n          getPageLabels: function PDFDocumentProxy_getPageLabels() {\n            return this.transport.getPageLabels();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with a lookup table for\r\n           * mapping named attachments to their content.\r\n           */\n          getAttachments: function PDFDocumentProxy_getAttachments() {\n            return this.transport.getAttachments();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with an array of all the\r\n           * JavaScript strings in the name tree.\r\n           */\n          getJavaScript: function PDFDocumentProxy_getJavaScript() {\n            return this.transport.getJavaScript();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with an {Array} that is a\r\n           * tree outline (if it has one) of the PDF. The tree is in the format of:\r\n           * [\r\n           *  {\r\n           *   title: string,\r\n           *   bold: boolean,\r\n           *   italic: boolean,\r\n           *   color: rgb Uint8Array,\r\n           *   dest: dest obj,\r\n           *   url: string,\r\n           *   items: array of more items like this\r\n           *  },\r\n           *  ...\r\n           * ].\r\n           */\n          getOutline: function PDFDocumentProxy_getOutline() {\n            return this.transport.getOutline();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with an {Object} that has\r\n           * info and metadata properties.  Info is an {Object} filled with anything\r\n           * available in the information dictionary and similarly metadata is a\r\n           * {Metadata} object with information from the metadata section of the PDF.\r\n           */\n          getMetadata: function PDFDocumentProxy_getMetadata() {\n            return this.transport.getMetadata();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved with a TypedArray that has\r\n           * the raw data from the PDF.\r\n           */\n          getData: function PDFDocumentProxy_getData() {\n            return this.transport.getData();\n          },\n          /**\r\n           * @return {Promise} A promise that is resolved when the document's data\r\n           * is loaded. It is resolved with an {Object} that contains the length\r\n           * property that indicates size of the PDF data in bytes.\r\n           */\n          getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {\n            return this.transport.downloadInfoCapability.promise;\n          },\n          /**\r\n           * @return {Promise} A promise this is resolved with current stats about\r\n           * document structures (see {@link PDFDocumentStats}).\r\n           */\n          getStats: function PDFDocumentProxy_getStats() {\n            return this.transport.getStats();\n          },\n          /**\r\n           * Cleans up resources allocated by the document, e.g. created @font-face.\r\n           */\n          cleanup: function PDFDocumentProxy_cleanup() {\n            this.transport.startCleanup();\n          },\n          /**\r\n           * Destroys current document instance and terminates worker.\r\n           */\n          destroy: function PDFDocumentProxy_destroy() {\n            return this.loadingTask.destroy();\n          }\n        };\n        return PDFDocumentProxy;\n      }();\n\n      /**\r\n       * Page getTextContent parameters.\r\n       *\r\n       * @typedef {Object} getTextContentParameters\r\n       * @param {boolean} normalizeWhitespace - replaces all occurrences of\r\n       *   whitespace with standard spaces (0x20). The default value is `false`.\r\n       */\n\n      /**\r\n       * Page text content.\r\n       *\r\n       * @typedef {Object} TextContent\r\n       * @property {array} items - array of {@link TextItem}\r\n       * @property {Object} styles - {@link TextStyles} objects, indexed by font\r\n       *                    name.\r\n       */\n\n      /**\r\n       * Page text content part.\r\n       *\r\n       * @typedef {Object} TextItem\r\n       * @property {string} str - text content.\r\n       * @property {string} dir - text direction: 'ttb', 'ltr' or 'rtl'.\r\n       * @property {array} transform - transformation matrix.\r\n       * @property {number} width - width in device space.\r\n       * @property {number} height - height in device space.\r\n       * @property {string} fontName - font name used by pdf.js for converted font.\r\n       */\n\n      /**\r\n       * Text style.\r\n       *\r\n       * @typedef {Object} TextStyle\r\n       * @property {number} ascent - font ascent.\r\n       * @property {number} descent - font descent.\r\n       * @property {boolean} vertical - text is in vertical mode.\r\n       * @property {string} fontFamily - possible font family\r\n       */\n\n      /**\r\n       * Page annotation parameters.\r\n       *\r\n       * @typedef {Object} GetAnnotationsParameters\r\n       * @param {string} intent - Determines the annotations that will be fetched,\r\n       *                 can be either 'display' (viewable annotations) or 'print'\r\n       *                 (printable annotations).\r\n       *                 If the parameter is omitted, all annotations are fetched.\r\n       */\n\n      /**\r\n       * Page render parameters.\r\n       *\r\n       * @typedef {Object} RenderParameters\r\n       * @property {Object} canvasContext - A 2D context of a DOM Canvas object.\r\n       * @property {PageViewport} viewport - Rendering viewport obtained by\r\n       *                                calling of PDFPage.getViewport method.\r\n       * @property {string} intent - Rendering intent, can be 'display' or 'print'\r\n       *                    (default value is 'display').\r\n       * @property {Array}  transform - (optional) Additional transform, applied\r\n       *                    just before viewport transform.\r\n       * @property {Object} imageLayer - (optional) An object that has beginLayout,\r\n       *                    endLayout and appendImage functions.\r\n       * @property {function} continueCallback - (deprecated) A function that will be\r\n       *                      called each time the rendering is paused.  To continue\r\n       *                      rendering call the function that is the first argument\r\n       *                      to the callback.\r\n       */\n\n      /**\r\n       * PDF page operator list.\r\n       *\r\n       * @typedef {Object} PDFOperatorList\r\n       * @property {Array} fnArray - Array containing the operator functions.\r\n       * @property {Array} argsArray - Array containing the arguments of the\r\n       *                               functions.\r\n       */\n\n      /**\r\n       * Proxy to a PDFPage in the worker thread.\r\n       * @class\r\n       * @alias PDFPageProxy\r\n       */\n      var PDFPageProxy = function PDFPageProxyClosure() {\n        function PDFPageProxy(pageIndex, pageInfo, transport) {\n          this.pageIndex = pageIndex;\n          this.pageInfo = pageInfo;\n          this.transport = transport;\n          this.stats = new StatTimer();\n          this.stats.enabled = getDefaultSetting('enableStats');\n          this.commonObjs = transport.commonObjs;\n          this.objs = new PDFObjects();\n          this.cleanupAfterRender = false;\n          this.pendingCleanup = false;\n          this.intentStates = Object.create(null);\n          this.destroyed = false;\n        }\n        PDFPageProxy.prototype = /** @lends PDFPageProxy.prototype */{\n          /**\r\n           * @return {number} Page number of the page. First page is 1.\r\n           */\n          get pageNumber() {\n            return this.pageIndex + 1;\n          },\n          /**\r\n           * @return {number} The number of degrees the page is rotated clockwise.\r\n           */\n          get rotate() {\n            return this.pageInfo.rotate;\n          },\n          /**\r\n           * @return {Object} The reference that points to this page. It has 'num' and\r\n           * 'gen' properties.\r\n           */\n          get ref() {\n            return this.pageInfo.ref;\n          },\n          /**\r\n           * @return {Array} An array of the visible portion of the PDF page in the\r\n           * user space units - [x1, y1, x2, y2].\r\n           */\n          get view() {\n            return this.pageInfo.view;\n          },\n          /**\r\n           * @param {number} scale The desired scale of the viewport.\r\n           * @param {number} rotate Degrees to rotate the viewport. If omitted this\r\n           * defaults to the page rotation.\r\n           * @return {PageViewport} Contains 'width' and 'height' properties\r\n           * along with transforms required for rendering.\r\n           */\n          getViewport: function PDFPageProxy_getViewport(scale, rotate) {\n            if (arguments.length < 2) {\n              rotate = this.rotate;\n            }\n            return new PageViewport(this.view, scale, rotate, 0, 0);\n          },\n          /**\r\n           * @param {GetAnnotationsParameters} params - Annotation parameters.\r\n           * @return {Promise} A promise that is resolved with an {Array} of the\r\n           * annotation objects.\r\n           */\n          getAnnotations: function PDFPageProxy_getAnnotations(params) {\n            var intent = params && params.intent || null;\n            if (!this.annotationsPromise || this.annotationsIntent !== intent) {\n              this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);\n              this.annotationsIntent = intent;\n            }\n            return this.annotationsPromise;\n          },\n          /**\r\n           * Begins the process of rendering a page to the desired context.\r\n           * @param {RenderParameters} params Page render parameters.\r\n           * @return {RenderTask} An object that contains the promise, which\r\n           *                      is resolved when the page finishes rendering.\r\n           */\n          render: function PDFPageProxy_render(params) {\n            var stats = this.stats;\n            stats.time('Overall');\n\n            // If there was a pending destroy cancel it so no cleanup happens during\n            // this call to render.\n            this.pendingCleanup = false;\n            var renderingIntent = params.intent === 'print' ? 'print' : 'display';\n            if (!this.intentStates[renderingIntent]) {\n              this.intentStates[renderingIntent] = Object.create(null);\n            }\n            var intentState = this.intentStates[renderingIntent];\n\n            // If there's no displayReadyCapability yet, then the operatorList\n            // was never requested before. Make the request and create the promise.\n            if (!intentState.displayReadyCapability) {\n              intentState.receivingOperatorList = true;\n              intentState.displayReadyCapability = createPromiseCapability();\n              intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false\n              };\n              this.stats.time('Page Request');\n              this.transport.messageHandler.send('RenderPageRequest', {\n                pageIndex: this.pageNumber - 1,\n                intent: renderingIntent\n              });\n            }\n            var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber);\n            internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';\n            if (!intentState.renderTasks) {\n              intentState.renderTasks = [];\n            }\n            intentState.renderTasks.push(internalRenderTask);\n            var renderTask = internalRenderTask.task;\n\n            // Obsolete parameter support\n            if (params.continueCallback) {\n              deprecated('render is used with continueCallback parameter');\n              renderTask.onContinue = params.continueCallback;\n            }\n            var self = this;\n            intentState.displayReadyCapability.promise.then(function pageDisplayReadyPromise(transparency) {\n              if (self.pendingCleanup) {\n                complete();\n                return;\n              }\n              stats.time('Rendering');\n              internalRenderTask.initalizeGraphics(transparency);\n              internalRenderTask.operatorListChanged();\n            }, function pageDisplayReadPromiseError(reason) {\n              complete(reason);\n            });\n            function complete(error) {\n              var i = intentState.renderTasks.indexOf(internalRenderTask);\n              if (i >= 0) {\n                intentState.renderTasks.splice(i, 1);\n              }\n              if (self.cleanupAfterRender) {\n                self.pendingCleanup = true;\n              }\n              self._tryCleanup();\n              if (error) {\n                internalRenderTask.capability.reject(error);\n              } else {\n                internalRenderTask.capability.resolve();\n              }\n              stats.timeEnd('Rendering');\n              stats.timeEnd('Overall');\n            }\n            return renderTask;\n          },\n          /**\r\n           * @return {Promise} A promise resolved with an {@link PDFOperatorList}\r\n           * object that represents page's operator list.\r\n           */\n          getOperatorList: function PDFPageProxy_getOperatorList() {\n            function operatorListChanged() {\n              if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                var i = intentState.renderTasks.indexOf(opListTask);\n                if (i >= 0) {\n                  intentState.renderTasks.splice(i, 1);\n                }\n              }\n            }\n            var renderingIntent = 'oplist';\n            if (!this.intentStates[renderingIntent]) {\n              this.intentStates[renderingIntent] = Object.create(null);\n            }\n            var intentState = this.intentStates[renderingIntent];\n            var opListTask;\n            if (!intentState.opListReadCapability) {\n              opListTask = {};\n              opListTask.operatorListChanged = operatorListChanged;\n              intentState.receivingOperatorList = true;\n              intentState.opListReadCapability = createPromiseCapability();\n              intentState.renderTasks = [];\n              intentState.renderTasks.push(opListTask);\n              intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false\n              };\n              this.transport.messageHandler.send('RenderPageRequest', {\n                pageIndex: this.pageIndex,\n                intent: renderingIntent\n              });\n            }\n            return intentState.opListReadCapability.promise;\n          },\n          /**\r\n           * @param {getTextContentParameters} params - getTextContent parameters.\r\n           * @return {Promise} That is resolved a {@link TextContent}\r\n           * object that represent the page text content.\r\n           */\n          getTextContent: function PDFPageProxy_getTextContent(params) {\n            var normalizeWhitespace = params && params.normalizeWhitespace || false;\n            return this.transport.messageHandler.sendWithPromise('GetTextContent', {\n              pageIndex: this.pageNumber - 1,\n              normalizeWhitespace: normalizeWhitespace\n            });\n          },\n          /**\r\n           * Destroys page object.\r\n           */\n          _destroy: function PDFPageProxy_destroy() {\n            this.destroyed = true;\n            this.transport.pageCache[this.pageIndex] = null;\n            var waitOn = [];\n            Object.keys(this.intentStates).forEach(function (intent) {\n              if (intent === 'oplist') {\n                // Avoid errors below, since the renderTasks are just stubs.\n                return;\n              }\n              var intentState = this.intentStates[intent];\n              intentState.renderTasks.forEach(function (renderTask) {\n                var renderCompleted = renderTask.capability.promise.catch(function () {}); // ignoring failures\n                waitOn.push(renderCompleted);\n                renderTask.cancel();\n              });\n            }, this);\n            this.objs.clear();\n            this.annotationsPromise = null;\n            this.pendingCleanup = false;\n            return Promise.all(waitOn);\n          },\n          /**\r\n           * Cleans up resources allocated by the page. (deprecated)\r\n           */\n          destroy: function destroy() {\n            deprecated('page destroy method, use cleanup() instead');\n            this.cleanup();\n          },\n          /**\r\n           * Cleans up resources allocated by the page.\r\n           */\n          cleanup: function PDFPageProxy_cleanup() {\n            this.pendingCleanup = true;\n            this._tryCleanup();\n          },\n          /**\r\n           * For internal use only. Attempts to clean up if rendering is in a state\r\n           * where that's possible.\r\n           * @ignore\r\n           */\n          _tryCleanup: function PDFPageProxy_tryCleanup() {\n            if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {\n              var intentState = this.intentStates[intent];\n              return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;\n            }, this)) {\n              return;\n            }\n            Object.keys(this.intentStates).forEach(function (intent) {\n              delete this.intentStates[intent];\n            }, this);\n            this.objs.clear();\n            this.annotationsPromise = null;\n            this.pendingCleanup = false;\n          },\n          /**\r\n           * For internal use only.\r\n           * @ignore\r\n           */\n          _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {\n            var intentState = this.intentStates[intent];\n            // TODO Refactor RenderPageRequest to separate rendering\n            // and operator list logic\n            if (intentState.displayReadyCapability) {\n              intentState.displayReadyCapability.resolve(transparency);\n            }\n          },\n          /**\r\n           * For internal use only.\r\n           * @ignore\r\n           */\n          _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {\n            var intentState = this.intentStates[intent];\n            var i, ii;\n            // Add the new chunk to the current operator list.\n            for (i = 0, ii = operatorListChunk.length; i < ii; i++) {\n              intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n              intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n            }\n            intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n            // Notify all the rendering tasks there are more operators to be consumed.\n            for (i = 0; i < intentState.renderTasks.length; i++) {\n              intentState.renderTasks[i].operatorListChanged();\n            }\n            if (operatorListChunk.lastChunk) {\n              intentState.receivingOperatorList = false;\n              this._tryCleanup();\n            }\n          }\n        };\n        return PDFPageProxy;\n      }();\n\n      /**\r\n       * PDF.js web worker abstraction, it controls instantiation of PDF documents and\r\n       * WorkerTransport for them.  If creation of a web worker is not possible,\r\n       * a \"fake\" worker will be used instead.\r\n       * @class\r\n       */\n      var PDFWorker = function PDFWorkerClosure() {\n        var nextFakeWorkerId = 0;\n        function getWorkerSrc() {\n          if (typeof workerSrc !== 'undefined') {\n            return workerSrc;\n          }\n          if (getDefaultSetting('workerSrc')) {\n            return getDefaultSetting('workerSrc');\n          }\n          if (pdfjsFilePath) {\n            return pdfjsFilePath.replace(/\\.js$/i, '.worker.js');\n          }\n          error('No PDFJS.workerSrc specified');\n        }\n        var fakeWorkerFilesLoadedCapability;\n\n        // Loads worker code into main thread.\n        function setupFakeWorkerGlobal() {\n          var WorkerMessageHandler;\n          if (!fakeWorkerFilesLoadedCapability) {\n            fakeWorkerFilesLoadedCapability = createPromiseCapability();\n            // In the developer build load worker_loader which in turn loads all the\n            // other files and resolves the promise. In production only the\n            // pdf.worker.js file is needed.\n            var loader = fakeWorkerFilesLoader || function (callback) {\n              Util.loadScript(getWorkerSrc(), function () {\n                callback(window.pdfjsDistBuildPdfWorker.WorkerMessageHandler);\n              });\n            };\n            loader(fakeWorkerFilesLoadedCapability.resolve);\n          }\n          return fakeWorkerFilesLoadedCapability.promise;\n        }\n        function createCDNWrapper(url) {\n          // We will rely on blob URL's property to specify origin.\n          // We want this function to fail in case if createObjectURL or Blob do not\n          // exist or fail for some reason -- our Worker creation will fail anyway.\n          var wrapper = 'importScripts(\\'' + url + '\\');';\n          return URL.createObjectURL(new Blob([wrapper]));\n        }\n        function PDFWorker(name) {\n          this.name = name;\n          this.destroyed = false;\n          this._readyCapability = createPromiseCapability();\n          this._port = null;\n          this._webWorker = null;\n          this._messageHandler = null;\n          this._initialize();\n        }\n        PDFWorker.prototype = /** @lends PDFWorker.prototype */{\n          get promise() {\n            return this._readyCapability.promise;\n          },\n          get port() {\n            return this._port;\n          },\n          get messageHandler() {\n            return this._messageHandler;\n          },\n          _initialize: function PDFWorker_initialize() {\n            // If worker support isn't disabled explicit and the browser has worker\n            // support, create a new web worker and test if it/the browser fulfills\n            // all requirements to run parts of pdf.js in a web worker.\n            // Right now, the requirement is, that an Uint8Array is still an\n            // Uint8Array as it arrives on the worker. (Chrome added this with v.15.)\n            if (!isWorkerDisabled && !getDefaultSetting('disableWorker') && typeof Worker !== 'undefined') {\n              var workerSrc = getWorkerSrc();\n              try {\n                // Wraps workerSrc path into blob URL, if the former does not belong\n                // to the same origin.\n                if (!isSameOrigin(window.location.href, workerSrc)) {\n                  workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\n                }\n                // Some versions of FF can't create a worker on localhost, see:\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=683280\n                var worker = new Worker(workerSrc);\n                var messageHandler = new MessageHandler('main', 'worker', worker);\n                var terminateEarly = function () {\n                  worker.removeEventListener('error', onWorkerError);\n                  messageHandler.destroy();\n                  worker.terminate();\n                  if (this.destroyed) {\n                    this._readyCapability.reject(new Error('Worker was destroyed'));\n                  } else {\n                    // Fall back to fake worker if the termination is caused by an\n                    // error (e.g. NetworkError / SecurityError).\n                    this._setupFakeWorker();\n                  }\n                }.bind(this);\n                var onWorkerError = function (event) {\n                  if (!this._webWorker) {\n                    // Worker failed to initialize due to an error. Clean up and fall\n                    // back to the fake worker.\n                    terminateEarly();\n                  }\n                }.bind(this);\n                worker.addEventListener('error', onWorkerError);\n                messageHandler.on('test', function PDFWorker_test(data) {\n                  worker.removeEventListener('error', onWorkerError);\n                  if (this.destroyed) {\n                    terminateEarly();\n                    return; // worker was destroyed\n                  }\n                  var supportTypedArray = data && data.supportTypedArray;\n                  if (supportTypedArray) {\n                    this._messageHandler = messageHandler;\n                    this._port = worker;\n                    this._webWorker = worker;\n                    if (!data.supportTransfers) {\n                      isPostMessageTransfersDisabled = true;\n                    }\n                    this._readyCapability.resolve();\n                    // Send global setting, e.g. verbosity level.\n                    messageHandler.send('configure', {\n                      verbosity: getVerbosityLevel()\n                    });\n                  } else {\n                    this._setupFakeWorker();\n                    messageHandler.destroy();\n                    worker.terminate();\n                  }\n                }.bind(this));\n                messageHandler.on('console_log', function (data) {\n                  console.log.apply(console, data);\n                });\n                messageHandler.on('console_error', function (data) {\n                  console.error.apply(console, data);\n                });\n                messageHandler.on('ready', function (data) {\n                  worker.removeEventListener('error', onWorkerError);\n                  if (this.destroyed) {\n                    terminateEarly();\n                    return; // worker was destroyed\n                  }\n                  try {\n                    sendTest();\n                  } catch (e) {\n                    // We need fallback to a faked worker.\n                    this._setupFakeWorker();\n                  }\n                }.bind(this));\n                var sendTest = function sendTest() {\n                  var postMessageTransfers = getDefaultSetting('postMessageTransfers') && !isPostMessageTransfersDisabled;\n                  var testObj = new Uint8Array([postMessageTransfers ? 255 : 0]);\n                  // Some versions of Opera throw a DATA_CLONE_ERR on serializing the\n                  // typed array. Also, checking if we can use transfers.\n                  try {\n                    messageHandler.send('test', testObj, [testObj.buffer]);\n                  } catch (ex) {\n                    info('Cannot use postMessage transfers');\n                    testObj[0] = 0;\n                    messageHandler.send('test', testObj);\n                  }\n                };\n\n                // It might take time for worker to initialize (especially when AMD\n                // loader is used). We will try to send test immediately, and then\n                // when 'ready' message will arrive. The worker shall process only\n                // first received 'test'.\n                sendTest();\n                return;\n              } catch (e) {\n                info('The worker has been disabled.');\n              }\n            }\n            // Either workers are disabled, not supported or have thrown an exception.\n            // Thus, we fallback to a faked worker.\n            this._setupFakeWorker();\n          },\n          _setupFakeWorker: function PDFWorker_setupFakeWorker() {\n            if (!isWorkerDisabled && !getDefaultSetting('disableWorker')) {\n              warn('Setting up fake worker.');\n              isWorkerDisabled = true;\n            }\n            setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {\n              if (this.destroyed) {\n                this._readyCapability.reject(new Error('Worker was destroyed'));\n                return;\n              }\n\n              // If we don't use a worker, just post/sendMessage to the main thread.\n              var port = {\n                _listeners: [],\n                postMessage: function postMessage(obj) {\n                  var e = {\n                    data: obj\n                  };\n                  this._listeners.forEach(function (listener) {\n                    listener.call(this, e);\n                  }, this);\n                },\n                addEventListener: function addEventListener(name, listener) {\n                  this._listeners.push(listener);\n                },\n                removeEventListener: function removeEventListener(name, listener) {\n                  var i = this._listeners.indexOf(listener);\n                  this._listeners.splice(i, 1);\n                },\n                terminate: function terminate() {}\n              };\n              this._port = port;\n\n              // All fake workers use the same port, making id unique.\n              var id = 'fake' + nextFakeWorkerId++;\n\n              // If the main thread is our worker, setup the handling for the\n              // messages -- the main thread sends to it self.\n              var workerHandler = new MessageHandler(id + '_worker', id, port);\n              WorkerMessageHandler.setup(workerHandler, port);\n              var messageHandler = new MessageHandler(id, id + '_worker', port);\n              this._messageHandler = messageHandler;\n              this._readyCapability.resolve();\n            }.bind(this));\n          },\n          /**\r\n           * Destroys the worker instance.\r\n           */\n          destroy: function PDFWorker_destroy() {\n            this.destroyed = true;\n            if (this._webWorker) {\n              // We need to terminate only web worker created resource.\n              this._webWorker.terminate();\n              this._webWorker = null;\n            }\n            this._port = null;\n            if (this._messageHandler) {\n              this._messageHandler.destroy();\n              this._messageHandler = null;\n            }\n          }\n        };\n        return PDFWorker;\n      }();\n\n      /**\r\n       * For internal use only.\r\n       * @ignore\r\n       */\n      var WorkerTransport = function WorkerTransportClosure() {\n        function WorkerTransport(messageHandler, loadingTask, pdfDataRangeTransport) {\n          this.messageHandler = messageHandler;\n          this.loadingTask = loadingTask;\n          this.pdfDataRangeTransport = pdfDataRangeTransport;\n          this.commonObjs = new PDFObjects();\n          this.fontLoader = new FontLoader(loadingTask.docId);\n          this.destroyed = false;\n          this.destroyCapability = null;\n          this.pageCache = [];\n          this.pagePromises = [];\n          this.downloadInfoCapability = createPromiseCapability();\n          this.setupMessageHandler();\n        }\n        WorkerTransport.prototype = {\n          destroy: function WorkerTransport_destroy() {\n            if (this.destroyCapability) {\n              return this.destroyCapability.promise;\n            }\n            this.destroyed = true;\n            this.destroyCapability = createPromiseCapability();\n            var waitOn = [];\n            // We need to wait for all renderings to be completed, e.g.\n            // timeout/rAF can take a long time.\n            this.pageCache.forEach(function (page) {\n              if (page) {\n                waitOn.push(page._destroy());\n              }\n            });\n            this.pageCache = [];\n            this.pagePromises = [];\n            var self = this;\n            // We also need to wait for the worker to finish its long running tasks.\n            var terminated = this.messageHandler.sendWithPromise('Terminate', null);\n            waitOn.push(terminated);\n            Promise.all(waitOn).then(function () {\n              self.fontLoader.clear();\n              if (self.pdfDataRangeTransport) {\n                self.pdfDataRangeTransport.abort();\n                self.pdfDataRangeTransport = null;\n              }\n              if (self.messageHandler) {\n                self.messageHandler.destroy();\n                self.messageHandler = null;\n              }\n              self.destroyCapability.resolve();\n            }, this.destroyCapability.reject);\n            return this.destroyCapability.promise;\n          },\n          setupMessageHandler: function WorkerTransport_setupMessageHandler() {\n            var messageHandler = this.messageHandler;\n            function updatePassword(password) {\n              messageHandler.send('UpdatePassword', password);\n            }\n            var pdfDataRangeTransport = this.pdfDataRangeTransport;\n            if (pdfDataRangeTransport) {\n              pdfDataRangeTransport.addRangeListener(function (begin, chunk) {\n                messageHandler.send('OnDataRange', {\n                  begin: begin,\n                  chunk: chunk\n                });\n              });\n              pdfDataRangeTransport.addProgressListener(function (loaded) {\n                messageHandler.send('OnDataProgress', {\n                  loaded: loaded\n                });\n              });\n              pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {\n                messageHandler.send('OnDataRange', {\n                  chunk: chunk\n                });\n              });\n              messageHandler.on('RequestDataRange', function transportDataRange(data) {\n                pdfDataRangeTransport.requestDataRange(data.begin, data.end);\n              }, this);\n            }\n            messageHandler.on('GetDoc', function transportDoc(data) {\n              var pdfInfo = data.pdfInfo;\n              this.numPages = data.pdfInfo.numPages;\n              var loadingTask = this.loadingTask;\n              var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);\n              this.pdfDocument = pdfDocument;\n              loadingTask._capability.resolve(pdfDocument);\n            }, this);\n            messageHandler.on('NeedPassword', function transportNeedPassword(exception) {\n              var loadingTask = this.loadingTask;\n              if (loadingTask.onPassword) {\n                return loadingTask.onPassword(updatePassword, PasswordResponses.NEED_PASSWORD);\n              }\n              loadingTask._capability.reject(new PasswordException(exception.message, exception.code));\n            }, this);\n            messageHandler.on('IncorrectPassword', function transportIncorrectPassword(exception) {\n              var loadingTask = this.loadingTask;\n              if (loadingTask.onPassword) {\n                return loadingTask.onPassword(updatePassword, PasswordResponses.INCORRECT_PASSWORD);\n              }\n              loadingTask._capability.reject(new PasswordException(exception.message, exception.code));\n            }, this);\n            messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {\n              this.loadingTask._capability.reject(new InvalidPDFException(exception.message));\n            }, this);\n            messageHandler.on('MissingPDF', function transportMissingPDF(exception) {\n              this.loadingTask._capability.reject(new MissingPDFException(exception.message));\n            }, this);\n            messageHandler.on('UnexpectedResponse', function transportUnexpectedResponse(exception) {\n              this.loadingTask._capability.reject(new UnexpectedResponseException(exception.message, exception.status));\n            }, this);\n            messageHandler.on('UnknownError', function transportUnknownError(exception) {\n              this.loadingTask._capability.reject(new UnknownErrorException(exception.message, exception.details));\n            }, this);\n            messageHandler.on('DataLoaded', function transportPage(data) {\n              this.downloadInfoCapability.resolve(data);\n            }, this);\n            messageHandler.on('PDFManagerReady', function transportPage(data) {\n              if (this.pdfDataRangeTransport) {\n                this.pdfDataRangeTransport.transportReady();\n              }\n            }, this);\n            messageHandler.on('StartRenderPage', function transportRender(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var page = this.pageCache[data.pageIndex];\n              page.stats.timeEnd('Page Request');\n              page._startRenderPage(data.transparency, data.intent);\n            }, this);\n            messageHandler.on('RenderPageChunk', function transportRender(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var page = this.pageCache[data.pageIndex];\n              page._renderPageChunk(data.operatorList, data.intent);\n            }, this);\n            messageHandler.on('commonobj', function transportObj(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var id = data[0];\n              var type = data[1];\n              if (this.commonObjs.hasData(id)) {\n                return;\n              }\n              switch (type) {\n                case 'Font':\n                  var exportedData = data[2];\n                  var font;\n                  if ('error' in exportedData) {\n                    var error = exportedData.error;\n                    warn('Error during font loading: ' + error);\n                    this.commonObjs.resolve(id, error);\n                    break;\n                  } else {\n                    var fontRegistry = null;\n                    if (getDefaultSetting('pdfBug') && globalScope.FontInspector && globalScope['FontInspector'].enabled) {\n                      fontRegistry = {\n                        registerFont: function registerFont(font, url) {\n                          globalScope['FontInspector'].fontAdded(font, url);\n                        }\n                      };\n                    }\n                    font = new FontFaceObject(exportedData, {\n                      isEvalSuported: getDefaultSetting('isEvalSupported'),\n                      disableFontFace: getDefaultSetting('disableFontFace'),\n                      fontRegistry: fontRegistry\n                    });\n                  }\n                  this.fontLoader.bind([font], function fontReady(fontObjs) {\n                    this.commonObjs.resolve(id, font);\n                  }.bind(this));\n                  break;\n                case 'FontPath':\n                  this.commonObjs.resolve(id, data[2]);\n                  break;\n                default:\n                  error('Got unknown common object type ' + type);\n              }\n            }, this);\n            messageHandler.on('obj', function transportObj(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var id = data[0];\n              var pageIndex = data[1];\n              var type = data[2];\n              var pageProxy = this.pageCache[pageIndex];\n              var imageData;\n              if (pageProxy.objs.hasData(id)) {\n                return;\n              }\n              switch (type) {\n                case 'JpegStream':\n                  imageData = data[3];\n                  loadJpegStream(id, imageData, pageProxy.objs);\n                  break;\n                case 'Image':\n                  imageData = data[3];\n                  pageProxy.objs.resolve(id, imageData);\n\n                  // heuristics that will allow not to store large data\n                  var MAX_IMAGE_SIZE_TO_STORE = 8000000;\n                  if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {\n                    pageProxy.cleanupAfterRender = true;\n                  }\n                  break;\n                default:\n                  error('Got unknown object type ' + type);\n              }\n            }, this);\n            messageHandler.on('DocProgress', function transportDocProgress(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var loadingTask = this.loadingTask;\n              if (loadingTask.onProgress) {\n                loadingTask.onProgress({\n                  loaded: data.loaded,\n                  total: data.total\n                });\n              }\n            }, this);\n            messageHandler.on('PageError', function transportError(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var page = this.pageCache[data.pageNum - 1];\n              var intentState = page.intentStates[data.intent];\n              if (intentState.displayReadyCapability) {\n                intentState.displayReadyCapability.reject(data.error);\n              } else {\n                error(data.error);\n              }\n              if (intentState.operatorList) {\n                // Mark operator list as complete.\n                intentState.operatorList.lastChunk = true;\n                for (var i = 0; i < intentState.renderTasks.length; i++) {\n                  intentState.renderTasks[i].operatorListChanged();\n                }\n              }\n            }, this);\n            messageHandler.on('UnsupportedFeature', function transportUnsupportedFeature(data) {\n              if (this.destroyed) {\n                return; // Ignore any pending requests if the worker was terminated.\n              }\n              var featureId = data.featureId;\n              var loadingTask = this.loadingTask;\n              if (loadingTask.onUnsupportedFeature) {\n                loadingTask.onUnsupportedFeature(featureId);\n              }\n              _UnsupportedManager.notify(featureId);\n            }, this);\n            messageHandler.on('JpegDecode', function (data) {\n              if (this.destroyed) {\n                return Promise.reject('Worker was terminated');\n              }\n              var imageUrl = data[0];\n              var components = data[1];\n              if (components !== 3 && components !== 1) {\n                return Promise.reject(new Error('Only 3 components or 1 component can be returned'));\n              }\n              return new Promise(function (resolve, reject) {\n                var img = new Image();\n                img.onload = function () {\n                  var width = img.width;\n                  var height = img.height;\n                  var size = width * height;\n                  var rgbaLength = size * 4;\n                  var buf = new Uint8Array(size * components);\n                  var tmpCanvas = createScratchCanvas(width, height);\n                  var tmpCtx = tmpCanvas.getContext('2d');\n                  tmpCtx.drawImage(img, 0, 0);\n                  var data = tmpCtx.getImageData(0, 0, width, height).data;\n                  var i, j;\n                  if (components === 3) {\n                    for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {\n                      buf[j] = data[i];\n                      buf[j + 1] = data[i + 1];\n                      buf[j + 2] = data[i + 2];\n                    }\n                  } else if (components === 1) {\n                    for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {\n                      buf[j] = data[i];\n                    }\n                  }\n                  resolve({\n                    data: buf,\n                    width: width,\n                    height: height\n                  });\n                };\n                img.onerror = function () {\n                  reject(new Error('JpegDecode failed to load image'));\n                };\n                img.src = imageUrl;\n              });\n            }, this);\n          },\n          getData: function WorkerTransport_getData() {\n            return this.messageHandler.sendWithPromise('GetData', null);\n          },\n          getPage: function WorkerTransport_getPage(pageNumber, capability) {\n            if (pageNumber <= 0 || pageNumber > this.numPages || (pageNumber | 0) !== pageNumber) {\n              return Promise.reject(new Error('Invalid page request'));\n            }\n            var pageIndex = pageNumber - 1;\n            if (pageIndex in this.pagePromises) {\n              return this.pagePromises[pageIndex];\n            }\n            var promise = this.messageHandler.sendWithPromise('GetPage', {\n              pageIndex: pageIndex\n            }).then(function (pageInfo) {\n              if (this.destroyed) {\n                throw new Error('Transport destroyed');\n              }\n              var page = new PDFPageProxy(pageIndex, pageInfo, this);\n              this.pageCache[pageIndex] = page;\n              return page;\n            }.bind(this));\n            this.pagePromises[pageIndex] = promise;\n            return promise;\n          },\n          getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {\n            return this.messageHandler.sendWithPromise('GetPageIndex', {\n              ref: ref\n            });\n          },\n          getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {\n            return this.messageHandler.sendWithPromise('GetAnnotations', {\n              pageIndex: pageIndex,\n              intent: intent\n            });\n          },\n          getDestinations: function WorkerTransport_getDestinations() {\n            return this.messageHandler.sendWithPromise('GetDestinations', null);\n          },\n          getDestination: function WorkerTransport_getDestination(id) {\n            return this.messageHandler.sendWithPromise('GetDestination', {\n              id: id\n            });\n          },\n          getPageLabels: function WorkerTransport_getPageLabels() {\n            return this.messageHandler.sendWithPromise('GetPageLabels', null);\n          },\n          getAttachments: function WorkerTransport_getAttachments() {\n            return this.messageHandler.sendWithPromise('GetAttachments', null);\n          },\n          getJavaScript: function WorkerTransport_getJavaScript() {\n            return this.messageHandler.sendWithPromise('GetJavaScript', null);\n          },\n          getOutline: function WorkerTransport_getOutline() {\n            return this.messageHandler.sendWithPromise('GetOutline', null);\n          },\n          getMetadata: function WorkerTransport_getMetadata() {\n            return this.messageHandler.sendWithPromise('GetMetadata', null).then(function transportMetadata(results) {\n              return {\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null\n              };\n            });\n          },\n          getStats: function WorkerTransport_getStats() {\n            return this.messageHandler.sendWithPromise('GetStats', null);\n          },\n          startCleanup: function WorkerTransport_startCleanup() {\n            this.messageHandler.sendWithPromise('Cleanup', null).then(function endCleanup() {\n              for (var i = 0, ii = this.pageCache.length; i < ii; i++) {\n                var page = this.pageCache[i];\n                if (page) {\n                  page.cleanup();\n                }\n              }\n              this.commonObjs.clear();\n              this.fontLoader.clear();\n            }.bind(this));\n          }\n        };\n        return WorkerTransport;\n      }();\n\n      /**\r\n       * A PDF document and page is built of many objects. E.g. there are objects\r\n       * for fonts, images, rendering code and such. These objects might get processed\r\n       * inside of a worker. The `PDFObjects` implements some basic functions to\r\n       * manage these objects.\r\n       * @ignore\r\n       */\n      var PDFObjects = function PDFObjectsClosure() {\n        function PDFObjects() {\n          this.objs = Object.create(null);\n        }\n        PDFObjects.prototype = {\n          /**\r\n           * Internal function.\r\n           * Ensures there is an object defined for `objId`.\r\n           */\n          ensureObj: function PDFObjects_ensureObj(objId) {\n            if (this.objs[objId]) {\n              return this.objs[objId];\n            }\n            var obj = {\n              capability: createPromiseCapability(),\n              data: null,\n              resolved: false\n            };\n            this.objs[objId] = obj;\n            return obj;\n          },\n          /**\r\n           * If called *without* callback, this returns the data of `objId` but the\r\n           * object needs to be resolved. If it isn't, this function throws.\r\n           *\r\n           * If called *with* a callback, the callback is called with the data of the\r\n           * object once the object is resolved. That means, if you call this\r\n           * function and the object is already resolved, the callback gets called\r\n           * right away.\r\n           */\n          get: function PDFObjects_get(objId, callback) {\n            // If there is a callback, then the get can be async and the object is\n            // not required to be resolved right now\n            if (callback) {\n              this.ensureObj(objId).capability.promise.then(callback);\n              return null;\n            }\n\n            // If there isn't a callback, the user expects to get the resolved data\n            // directly.\n            var obj = this.objs[objId];\n\n            // If there isn't an object yet or the object isn't resolved, then the\n            // data isn't ready yet!\n            if (!obj || !obj.resolved) {\n              error('Requesting object that isn\\'t resolved yet ' + objId);\n            }\n            return obj.data;\n          },\n          /**\r\n           * Resolves the object `objId` with optional `data`.\r\n           */\n          resolve: function PDFObjects_resolve(objId, data) {\n            var obj = this.ensureObj(objId);\n            obj.resolved = true;\n            obj.data = data;\n            obj.capability.resolve(data);\n          },\n          isResolved: function PDFObjects_isResolved(objId) {\n            var objs = this.objs;\n            if (!objs[objId]) {\n              return false;\n            } else {\n              return objs[objId].resolved;\n            }\n          },\n          hasData: function PDFObjects_hasData(objId) {\n            return this.isResolved(objId);\n          },\n          /**\r\n           * Returns the data of `objId` if object exists, null otherwise.\r\n           */\n          getData: function PDFObjects_getData(objId) {\n            var objs = this.objs;\n            if (!objs[objId] || !objs[objId].resolved) {\n              return null;\n            } else {\n              return objs[objId].data;\n            }\n          },\n          clear: function PDFObjects_clear() {\n            this.objs = Object.create(null);\n          }\n        };\n        return PDFObjects;\n      }();\n\n      /**\r\n       * Allows controlling of the rendering tasks.\r\n       * @class\r\n       * @alias RenderTask\r\n       */\n      var RenderTask = function RenderTaskClosure() {\n        function RenderTask(internalRenderTask) {\n          this._internalRenderTask = internalRenderTask;\n\n          /**\r\n           * Callback for incremental rendering -- a function that will be called\r\n           * each time the rendering is paused.  To continue rendering call the\r\n           * function that is the first argument to the callback.\r\n           * @type {function}\r\n           */\n          this.onContinue = null;\n        }\n        RenderTask.prototype = /** @lends RenderTask.prototype */{\n          /**\r\n           * Promise for rendering task completion.\r\n           * @return {Promise}\r\n           */\n          get promise() {\n            return this._internalRenderTask.capability.promise;\n          },\n          /**\r\n           * Cancels the rendering task. If the task is currently rendering it will\r\n           * not be cancelled until graphics pauses with a timeout. The promise that\r\n           * this object extends will resolved when cancelled.\r\n           */\n          cancel: function RenderTask_cancel() {\n            this._internalRenderTask.cancel();\n          },\n          /**\r\n           * Registers callbacks to indicate the rendering task completion.\r\n           *\r\n           * @param {function} onFulfilled The callback for the rendering completion.\r\n           * @param {function} onRejected The callback for the rendering failure.\r\n           * @return {Promise} A promise that is resolved after the onFulfilled or\r\n           *                   onRejected callback.\r\n           */\n          then: function RenderTask_then(onFulfilled, onRejected) {\n            return this.promise.then.apply(this.promise, arguments);\n          }\n        };\n        return RenderTask;\n      }();\n\n      /**\r\n       * For internal use only.\r\n       * @ignore\r\n       */\n      var InternalRenderTask = function InternalRenderTaskClosure() {\n        function InternalRenderTask(callback, params, objs, commonObjs, operatorList, pageNumber) {\n          this.callback = callback;\n          this.params = params;\n          this.objs = objs;\n          this.commonObjs = commonObjs;\n          this.operatorListIdx = null;\n          this.operatorList = operatorList;\n          this.pageNumber = pageNumber;\n          this.running = false;\n          this.graphicsReadyCallback = null;\n          this.graphicsReady = false;\n          this.useRequestAnimationFrame = false;\n          this.cancelled = false;\n          this.capability = createPromiseCapability();\n          this.task = new RenderTask(this);\n          // caching this-bound methods\n          this._continueBound = this._continue.bind(this);\n          this._scheduleNextBound = this._scheduleNext.bind(this);\n          this._nextBound = this._next.bind(this);\n        }\n        InternalRenderTask.prototype = {\n          initalizeGraphics: function InternalRenderTask_initalizeGraphics(transparency) {\n            if (this.cancelled) {\n              return;\n            }\n            if (getDefaultSetting('pdfBug') && globalScope.StepperManager && globalScope.StepperManager.enabled) {\n              this.stepper = globalScope.StepperManager.create(this.pageNumber - 1);\n              this.stepper.init(this.operatorList);\n              this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n            }\n            var params = this.params;\n            this.gfx = new CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, params.imageLayer);\n            this.gfx.beginDrawing(params.transform, params.viewport, transparency);\n            this.operatorListIdx = 0;\n            this.graphicsReady = true;\n            if (this.graphicsReadyCallback) {\n              this.graphicsReadyCallback();\n            }\n          },\n          cancel: function InternalRenderTask_cancel() {\n            this.running = false;\n            this.cancelled = true;\n            this.callback('cancelled');\n          },\n          operatorListChanged: function InternalRenderTask_operatorListChanged() {\n            if (!this.graphicsReady) {\n              if (!this.graphicsReadyCallback) {\n                this.graphicsReadyCallback = this._continueBound;\n              }\n              return;\n            }\n            if (this.stepper) {\n              this.stepper.updateOperatorList(this.operatorList);\n            }\n            if (this.running) {\n              return;\n            }\n            this._continue();\n          },\n          _continue: function InternalRenderTask__continue() {\n            this.running = true;\n            if (this.cancelled) {\n              return;\n            }\n            if (this.task.onContinue) {\n              this.task.onContinue.call(this.task, this._scheduleNextBound);\n            } else {\n              this._scheduleNext();\n            }\n          },\n          _scheduleNext: function InternalRenderTask__scheduleNext() {\n            if (this.useRequestAnimationFrame && typeof window !== 'undefined') {\n              window.requestAnimationFrame(this._nextBound);\n            } else {\n              Promise.resolve(undefined).then(this._nextBound);\n            }\n          },\n          _next: function InternalRenderTask__next() {\n            if (this.cancelled) {\n              return;\n            }\n            this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n            if (this.operatorListIdx === this.operatorList.argsArray.length) {\n              this.running = false;\n              if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                this.callback();\n              }\n            }\n          }\n        };\n        return InternalRenderTask;\n      }();\n\n      /**\r\n       * (Deprecated) Global observer of unsupported feature usages. Use\r\n       * onUnsupportedFeature callback of the {PDFDocumentLoadingTask} instance.\r\n       */\n      var _UnsupportedManager = function UnsupportedManagerClosure() {\n        var listeners = [];\n        return {\n          listen: function listen(cb) {\n            deprecated('Global UnsupportedManager.listen is used: ' + ' use PDFDocumentLoadingTask.onUnsupportedFeature instead');\n            listeners.push(cb);\n          },\n          notify: function notify(featureId) {\n            for (var i = 0, ii = listeners.length; i < ii; i++) {\n              listeners[i](featureId);\n            }\n          }\n        };\n      }();\n      if (typeof pdfjsVersion !== 'undefined') {\n        exports.version = pdfjsVersion;\n      }\n      if (typeof pdfjsBuild !== 'undefined') {\n        exports.build = pdfjsBuild;\n      }\n      exports.getDocument = getDocument;\n      exports.PDFDataRangeTransport = PDFDataRangeTransport;\n      exports.PDFWorker = PDFWorker;\n      exports.PDFDocumentProxy = PDFDocumentProxy;\n      exports.PDFPageProxy = PDFPageProxy;\n      exports._UnsupportedManager = _UnsupportedManager;\n    });\n    (function (root, factory) {\n      {\n        factory(root.pdfjsDisplayGlobal = {}, root.pdfjsSharedUtil, root.pdfjsDisplayDOMUtils, root.pdfjsDisplayAPI, root.pdfjsDisplayAnnotationLayer, root.pdfjsDisplayTextLayer, root.pdfjsDisplayMetadata, root.pdfjsDisplaySVG);\n      }\n    })(this, function (exports, sharedUtil, displayDOMUtils, displayAPI, displayAnnotationLayer, displayTextLayer, displayMetadata, displaySVG) {\n      var globalScope = sharedUtil.globalScope;\n      var deprecated = sharedUtil.deprecated;\n      var warn = sharedUtil.warn;\n      var LinkTarget = displayDOMUtils.LinkTarget;\n      var isWorker = typeof window === 'undefined';\n\n      // The global PDFJS object is now deprecated and will not be supported in\n      // the future. The members below are maintained for backward  compatibility\n      // and shall not be extended or modified. If the global.js is included as\n      // a module, we will create a global PDFJS object instance or use existing.\n      if (!globalScope.PDFJS) {\n        globalScope.PDFJS = {};\n      }\n      var PDFJS = globalScope.PDFJS;\n      if (typeof pdfjsVersion !== 'undefined') {\n        PDFJS.version = pdfjsVersion;\n      }\n      if (typeof pdfjsBuild !== 'undefined') {\n        PDFJS.build = pdfjsBuild;\n      }\n      PDFJS.pdfBug = false;\n      if (PDFJS.verbosity !== undefined) {\n        sharedUtil.setVerbosityLevel(PDFJS.verbosity);\n      }\n      delete PDFJS.verbosity;\n      Object.defineProperty(PDFJS, 'verbosity', {\n        get: function get() {\n          return sharedUtil.getVerbosityLevel();\n        },\n        set: function set(level) {\n          sharedUtil.setVerbosityLevel(level);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      PDFJS.VERBOSITY_LEVELS = sharedUtil.VERBOSITY_LEVELS;\n      PDFJS.OPS = sharedUtil.OPS;\n      PDFJS.UNSUPPORTED_FEATURES = sharedUtil.UNSUPPORTED_FEATURES;\n      PDFJS.isValidUrl = sharedUtil.isValidUrl;\n      PDFJS.shadow = sharedUtil.shadow;\n      PDFJS.createBlob = sharedUtil.createBlob;\n      PDFJS.createObjectURL = function PDFJS_createObjectURL(data, contentType) {\n        return sharedUtil.createObjectURL(data, contentType, PDFJS.disableCreateObjectURL);\n      };\n      Object.defineProperty(PDFJS, 'isLittleEndian', {\n        configurable: true,\n        get: function PDFJS_isLittleEndian() {\n          var value = sharedUtil.isLittleEndian();\n          return sharedUtil.shadow(PDFJS, 'isLittleEndian', value);\n        }\n      });\n      PDFJS.removeNullCharacters = sharedUtil.removeNullCharacters;\n      PDFJS.PasswordResponses = sharedUtil.PasswordResponses;\n      PDFJS.PasswordException = sharedUtil.PasswordException;\n      PDFJS.UnknownErrorException = sharedUtil.UnknownErrorException;\n      PDFJS.InvalidPDFException = sharedUtil.InvalidPDFException;\n      PDFJS.MissingPDFException = sharedUtil.MissingPDFException;\n      PDFJS.UnexpectedResponseException = sharedUtil.UnexpectedResponseException;\n      PDFJS.Util = sharedUtil.Util;\n      PDFJS.PageViewport = sharedUtil.PageViewport;\n      PDFJS.createPromiseCapability = sharedUtil.createPromiseCapability;\n\n      /**\r\n       * The maximum allowed image size in total pixels e.g. width * height. Images\r\n       * above this value will not be drawn. Use -1 for no limit.\r\n       * @var {number}\r\n       */\n      PDFJS.maxImageSize = PDFJS.maxImageSize === undefined ? -1 : PDFJS.maxImageSize;\n\n      /**\r\n       * The url of where the predefined Adobe CMaps are located. Include trailing\r\n       * slash.\r\n       * @var {string}\r\n       */\n      PDFJS.cMapUrl = PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl;\n\n      /**\r\n       * Specifies if CMaps are binary packed.\r\n       * @var {boolean}\r\n       */\n      PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;\n\n      /**\r\n       * By default fonts are converted to OpenType fonts and loaded via font face\r\n       * rules. If disabled, the font will be rendered using a built in font\r\n       * renderer that constructs the glyphs with primitive path commands.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableFontFace = PDFJS.disableFontFace === undefined ? false : PDFJS.disableFontFace;\n\n      /**\r\n       * Path for image resources, mainly for annotation icons. Include trailing\r\n       * slash.\r\n       * @var {string}\r\n       */\n      PDFJS.imageResourcesPath = PDFJS.imageResourcesPath === undefined ? '' : PDFJS.imageResourcesPath;\n\n      /**\r\n       * Disable the web worker and run all code on the main thread. This will\r\n       * happen automatically if the browser doesn't support workers or sending\r\n       * typed arrays to workers.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableWorker = PDFJS.disableWorker === undefined ? false : PDFJS.disableWorker;\n\n      /**\r\n       * Path and filename of the worker file. Required when the worker is enabled\r\n       * in development mode. If unspecified in the production build, the worker\r\n       * will be loaded based on the location of the pdf.js file. It is recommended\r\n       * that the workerSrc is set in a custom application to prevent issues caused\r\n       * by third-party frameworks and libraries.\r\n       * @var {string}\r\n       */\n      PDFJS.workerSrc = PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc;\n\n      /**\r\n       * Disable range request loading of PDF files. When enabled and if the server\r\n       * supports partial content requests then the PDF will be fetched in chunks.\r\n       * Enabled (false) by default.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableRange = PDFJS.disableRange === undefined ? false : PDFJS.disableRange;\n\n      /**\r\n       * Disable streaming of PDF file data. By default PDF.js attempts to load PDF\r\n       * in chunks. This default behavior can be disabled.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableStream = PDFJS.disableStream === undefined ? false : PDFJS.disableStream;\n\n      /**\r\n       * Disable pre-fetching of PDF file data. When range requests are enabled\r\n       * PDF.js will automatically keep fetching more data even if it isn't needed\r\n       * to display the current page. This default behavior can be disabled.\r\n       *\r\n       * NOTE: It is also necessary to disable streaming, see above,\r\n       *       in order for disabling of pre-fetching to work correctly.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableAutoFetch = PDFJS.disableAutoFetch === undefined ? false : PDFJS.disableAutoFetch;\n\n      /**\r\n       * Enables special hooks for debugging PDF.js.\r\n       * @var {boolean}\r\n       */\n      PDFJS.pdfBug = PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug;\n\n      /**\r\n       * Enables transfer usage in postMessage for ArrayBuffers.\r\n       * @var {boolean}\r\n       */\n      PDFJS.postMessageTransfers = PDFJS.postMessageTransfers === undefined ? true : PDFJS.postMessageTransfers;\n\n      /**\r\n       * Disables URL.createObjectURL usage.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableCreateObjectURL = PDFJS.disableCreateObjectURL === undefined ? false : PDFJS.disableCreateObjectURL;\n\n      /**\r\n       * Disables WebGL usage.\r\n       * @var {boolean}\r\n       */\n      PDFJS.disableWebGL = PDFJS.disableWebGL === undefined ? true : PDFJS.disableWebGL;\n\n      /**\r\n       * Specifies the |target| attribute for external links.\r\n       * The constants from PDFJS.LinkTarget should be used:\r\n       *  - NONE [default]\r\n       *  - SELF\r\n       *  - BLANK\r\n       *  - PARENT\r\n       *  - TOP\r\n       * @var {number}\r\n       */\n      PDFJS.externalLinkTarget = PDFJS.externalLinkTarget === undefined ? LinkTarget.NONE : PDFJS.externalLinkTarget;\n\n      /**\r\n       * Specifies the |rel| attribute for external links. Defaults to stripping\r\n       * the referrer.\r\n       * @var {string}\r\n       */\n      PDFJS.externalLinkRel = PDFJS.externalLinkRel === undefined ? 'noreferrer' : PDFJS.externalLinkRel;\n\n      /**\r\n        * Determines if we can eval strings as JS. Primarily used to improve\r\n        * performance for font rendering.\r\n        * @var {boolean}\r\n        */\n      PDFJS.isEvalSupported = PDFJS.isEvalSupported === undefined ? true : PDFJS.isEvalSupported;\n      var savedOpenExternalLinksInNewWindow = PDFJS.openExternalLinksInNewWindow;\n      delete PDFJS.openExternalLinksInNewWindow;\n      Object.defineProperty(PDFJS, 'openExternalLinksInNewWindow', {\n        get: function get() {\n          return PDFJS.externalLinkTarget === LinkTarget.BLANK;\n        },\n        set: function set(value) {\n          if (value) {\n            deprecated('PDFJS.openExternalLinksInNewWindow, please use ' + '\"PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK\" instead.');\n          }\n          if (PDFJS.externalLinkTarget !== LinkTarget.NONE) {\n            warn('PDFJS.externalLinkTarget is already initialized');\n            return;\n          }\n          PDFJS.externalLinkTarget = value ? LinkTarget.BLANK : LinkTarget.NONE;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      if (savedOpenExternalLinksInNewWindow) {\n        /**\r\n         * (Deprecated) Opens external links in a new window if enabled.\r\n         * The default behavior opens external links in the PDF.js window.\r\n         *\r\n         * NOTE: This property has been deprecated, please use\r\n         *       `PDFJS.externalLinkTarget = PDFJS.LinkTarget.BLANK` instead.\r\n         * @var {boolean}\r\n         */\n        PDFJS.openExternalLinksInNewWindow = savedOpenExternalLinksInNewWindow;\n      }\n      PDFJS.getDocument = displayAPI.getDocument;\n      PDFJS.PDFDataRangeTransport = displayAPI.PDFDataRangeTransport;\n      PDFJS.PDFWorker = displayAPI.PDFWorker;\n      Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {\n        configurable: true,\n        get: function PDFJS_hasCanvasTypedArrays() {\n          var value = displayDOMUtils.hasCanvasTypedArrays();\n          return sharedUtil.shadow(PDFJS, 'hasCanvasTypedArrays', value);\n        }\n      });\n      PDFJS.CustomStyle = displayDOMUtils.CustomStyle;\n      PDFJS.LinkTarget = LinkTarget;\n      PDFJS.addLinkAttributes = displayDOMUtils.addLinkAttributes;\n      PDFJS.getFilenameFromUrl = displayDOMUtils.getFilenameFromUrl;\n      PDFJS.isExternalLinkTargetSet = displayDOMUtils.isExternalLinkTargetSet;\n      PDFJS.AnnotationLayer = displayAnnotationLayer.AnnotationLayer;\n      PDFJS.renderTextLayer = displayTextLayer.renderTextLayer;\n      PDFJS.Metadata = displayMetadata.Metadata;\n      PDFJS.SVGGraphics = displaySVG.SVGGraphics;\n      PDFJS.UnsupportedManager = displayAPI._UnsupportedManager;\n      exports.globalScope = globalScope;\n      exports.isWorker = isWorker;\n      exports.PDFJS = globalScope.PDFJS;\n    });\n  }).call(pdfjsLibs);\n  exports.PDFJS = pdfjsLibs.pdfjsDisplayGlobal.PDFJS;\n  exports.build = pdfjsLibs.pdfjsDisplayAPI.build;\n  exports.version = pdfjsLibs.pdfjsDisplayAPI.version;\n  exports.getDocument = pdfjsLibs.pdfjsDisplayAPI.getDocument;\n  exports.PDFDataRangeTransport = pdfjsLibs.pdfjsDisplayAPI.PDFDataRangeTransport;\n  exports.PDFWorker = pdfjsLibs.pdfjsDisplayAPI.PDFWorker;\n  exports.renderTextLayer = pdfjsLibs.pdfjsDisplayTextLayer.renderTextLayer;\n  exports.AnnotationLayer = pdfjsLibs.pdfjsDisplayAnnotationLayer.AnnotationLayer;\n  exports.CustomStyle = pdfjsLibs.pdfjsDisplayDOMUtils.CustomStyle;\n  exports.PasswordResponses = pdfjsLibs.pdfjsSharedUtil.PasswordResponses;\n  exports.InvalidPDFException = pdfjsLibs.pdfjsSharedUtil.InvalidPDFException;\n  exports.MissingPDFException = pdfjsLibs.pdfjsSharedUtil.MissingPDFException;\n  exports.SVGGraphics = pdfjsLibs.pdfjsDisplaySVG.SVGGraphics;\n  exports.UnexpectedResponseException = pdfjsLibs.pdfjsSharedUtil.UnexpectedResponseException;\n  exports.OPS = pdfjsLibs.pdfjsSharedUtil.OPS;\n  exports.UNSUPPORTED_FEATURES = pdfjsLibs.pdfjsSharedUtil.UNSUPPORTED_FEATURES;\n  exports.isValidUrl = pdfjsLibs.pdfjsSharedUtil.isValidUrl;\n  exports.createObjectURL = pdfjsLibs.pdfjsSharedUtil.createObjectURL;\n  exports.removeNullCharacters = pdfjsLibs.pdfjsSharedUtil.removeNullCharacters;\n  exports.shadow = pdfjsLibs.pdfjsSharedUtil.shadow;\n  exports.createBlob = pdfjsLibs.pdfjsSharedUtil.createBlob;\n  exports.getFilenameFromUrl = pdfjsLibs.pdfjsDisplayDOMUtils.getFilenameFromUrl;\n  exports.addLinkAttributes = pdfjsLibs.pdfjsDisplayDOMUtils.addLinkAttributes;\n});","map":null,"metadata":{},"sourceType":"script"}